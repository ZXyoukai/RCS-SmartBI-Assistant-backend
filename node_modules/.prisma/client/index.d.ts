
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model users
 * 
 */
export type users = $Result.DefaultSelection<Prisma.$usersPayload>
/**
 * Model queries
 * 
 */
export type queries = $Result.DefaultSelection<Prisma.$queriesPayload>
/**
 * Model results
 * 
 */
export type results = $Result.DefaultSelection<Prisma.$resultsPayload>
/**
 * Model history
 * 
 */
export type history = $Result.DefaultSelection<Prisma.$historyPayload>
/**
 * Model exports
 * 
 */
export type exports = $Result.DefaultSelection<Prisma.$exportsPayload>
/**
 * Model suggestions
 * 
 */
export type suggestions = $Result.DefaultSelection<Prisma.$suggestionsPayload>
/**
 * Model access_logs
 * 
 */
export type access_logs = $Result.DefaultSelection<Prisma.$access_logsPayload>
/**
 * Model ai_chat_sessions
 * 
 */
export type ai_chat_sessions = $Result.DefaultSelection<Prisma.$ai_chat_sessionsPayload>
/**
 * Model ai_interactions
 * 
 */
export type ai_interactions = $Result.DefaultSelection<Prisma.$ai_interactionsPayload>
/**
 * Model ai_insights
 * 
 */
export type ai_insights = $Result.DefaultSelection<Prisma.$ai_insightsPayload>
/**
 * Model ai_fallbacks
 * 
 */
export type ai_fallbacks = $Result.DefaultSelection<Prisma.$ai_fallbacksPayload>
/**
 * Model ai_response_cache
 * 
 */
export type ai_response_cache = $Result.DefaultSelection<Prisma.$ai_response_cachePayload>
/**
 * Model associated_databases
 * 
 */
export type associated_databases = $Result.DefaultSelection<Prisma.$associated_databasesPayload>

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.users.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.users.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.users`: Exposes CRUD operations for the **users** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.users.findMany()
    * ```
    */
  get users(): Prisma.usersDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.queries`: Exposes CRUD operations for the **queries** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Queries
    * const queries = await prisma.queries.findMany()
    * ```
    */
  get queries(): Prisma.queriesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.results`: Exposes CRUD operations for the **results** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Results
    * const results = await prisma.results.findMany()
    * ```
    */
  get results(): Prisma.resultsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.history`: Exposes CRUD operations for the **history** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Histories
    * const histories = await prisma.history.findMany()
    * ```
    */
  get history(): Prisma.historyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.exports`: Exposes CRUD operations for the **exports** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Exports
    * const exports = await prisma.exports.findMany()
    * ```
    */
  get exports(): Prisma.exportsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.suggestions`: Exposes CRUD operations for the **suggestions** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Suggestions
    * const suggestions = await prisma.suggestions.findMany()
    * ```
    */
  get suggestions(): Prisma.suggestionsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.access_logs`: Exposes CRUD operations for the **access_logs** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Access_logs
    * const access_logs = await prisma.access_logs.findMany()
    * ```
    */
  get access_logs(): Prisma.access_logsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.ai_chat_sessions`: Exposes CRUD operations for the **ai_chat_sessions** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Ai_chat_sessions
    * const ai_chat_sessions = await prisma.ai_chat_sessions.findMany()
    * ```
    */
  get ai_chat_sessions(): Prisma.ai_chat_sessionsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.ai_interactions`: Exposes CRUD operations for the **ai_interactions** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Ai_interactions
    * const ai_interactions = await prisma.ai_interactions.findMany()
    * ```
    */
  get ai_interactions(): Prisma.ai_interactionsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.ai_insights`: Exposes CRUD operations for the **ai_insights** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Ai_insights
    * const ai_insights = await prisma.ai_insights.findMany()
    * ```
    */
  get ai_insights(): Prisma.ai_insightsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.ai_fallbacks`: Exposes CRUD operations for the **ai_fallbacks** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Ai_fallbacks
    * const ai_fallbacks = await prisma.ai_fallbacks.findMany()
    * ```
    */
  get ai_fallbacks(): Prisma.ai_fallbacksDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.ai_response_cache`: Exposes CRUD operations for the **ai_response_cache** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Ai_response_caches
    * const ai_response_caches = await prisma.ai_response_cache.findMany()
    * ```
    */
  get ai_response_cache(): Prisma.ai_response_cacheDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.associated_databases`: Exposes CRUD operations for the **associated_databases** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Associated_databases
    * const associated_databases = await prisma.associated_databases.findMany()
    * ```
    */
  get associated_databases(): Prisma.associated_databasesDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.13.0
   * Query Engine version: 361e86d0ea4987e9f53a565309b3eed797a6bcbd
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    users: 'users',
    queries: 'queries',
    results: 'results',
    history: 'history',
    exports: 'exports',
    suggestions: 'suggestions',
    access_logs: 'access_logs',
    ai_chat_sessions: 'ai_chat_sessions',
    ai_interactions: 'ai_interactions',
    ai_insights: 'ai_insights',
    ai_fallbacks: 'ai_fallbacks',
    ai_response_cache: 'ai_response_cache',
    associated_databases: 'associated_databases'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "users" | "queries" | "results" | "history" | "exports" | "suggestions" | "access_logs" | "ai_chat_sessions" | "ai_interactions" | "ai_insights" | "ai_fallbacks" | "ai_response_cache" | "associated_databases"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      users: {
        payload: Prisma.$usersPayload<ExtArgs>
        fields: Prisma.usersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.usersFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.usersFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          findFirst: {
            args: Prisma.usersFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.usersFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          findMany: {
            args: Prisma.usersFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>[]
          }
          create: {
            args: Prisma.usersCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          createMany: {
            args: Prisma.usersCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.usersCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>[]
          }
          delete: {
            args: Prisma.usersDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          update: {
            args: Prisma.usersUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          deleteMany: {
            args: Prisma.usersDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.usersUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.usersUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>[]
          }
          upsert: {
            args: Prisma.usersUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          aggregate: {
            args: Prisma.UsersAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUsers>
          }
          groupBy: {
            args: Prisma.usersGroupByArgs<ExtArgs>
            result: $Utils.Optional<UsersGroupByOutputType>[]
          }
          count: {
            args: Prisma.usersCountArgs<ExtArgs>
            result: $Utils.Optional<UsersCountAggregateOutputType> | number
          }
        }
      }
      queries: {
        payload: Prisma.$queriesPayload<ExtArgs>
        fields: Prisma.queriesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.queriesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$queriesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.queriesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$queriesPayload>
          }
          findFirst: {
            args: Prisma.queriesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$queriesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.queriesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$queriesPayload>
          }
          findMany: {
            args: Prisma.queriesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$queriesPayload>[]
          }
          create: {
            args: Prisma.queriesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$queriesPayload>
          }
          createMany: {
            args: Prisma.queriesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.queriesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$queriesPayload>[]
          }
          delete: {
            args: Prisma.queriesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$queriesPayload>
          }
          update: {
            args: Prisma.queriesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$queriesPayload>
          }
          deleteMany: {
            args: Prisma.queriesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.queriesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.queriesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$queriesPayload>[]
          }
          upsert: {
            args: Prisma.queriesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$queriesPayload>
          }
          aggregate: {
            args: Prisma.QueriesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQueries>
          }
          groupBy: {
            args: Prisma.queriesGroupByArgs<ExtArgs>
            result: $Utils.Optional<QueriesGroupByOutputType>[]
          }
          count: {
            args: Prisma.queriesCountArgs<ExtArgs>
            result: $Utils.Optional<QueriesCountAggregateOutputType> | number
          }
        }
      }
      results: {
        payload: Prisma.$resultsPayload<ExtArgs>
        fields: Prisma.resultsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.resultsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$resultsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.resultsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$resultsPayload>
          }
          findFirst: {
            args: Prisma.resultsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$resultsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.resultsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$resultsPayload>
          }
          findMany: {
            args: Prisma.resultsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$resultsPayload>[]
          }
          create: {
            args: Prisma.resultsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$resultsPayload>
          }
          createMany: {
            args: Prisma.resultsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.resultsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$resultsPayload>[]
          }
          delete: {
            args: Prisma.resultsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$resultsPayload>
          }
          update: {
            args: Prisma.resultsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$resultsPayload>
          }
          deleteMany: {
            args: Prisma.resultsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.resultsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.resultsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$resultsPayload>[]
          }
          upsert: {
            args: Prisma.resultsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$resultsPayload>
          }
          aggregate: {
            args: Prisma.ResultsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateResults>
          }
          groupBy: {
            args: Prisma.resultsGroupByArgs<ExtArgs>
            result: $Utils.Optional<ResultsGroupByOutputType>[]
          }
          count: {
            args: Prisma.resultsCountArgs<ExtArgs>
            result: $Utils.Optional<ResultsCountAggregateOutputType> | number
          }
        }
      }
      history: {
        payload: Prisma.$historyPayload<ExtArgs>
        fields: Prisma.historyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.historyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$historyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.historyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$historyPayload>
          }
          findFirst: {
            args: Prisma.historyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$historyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.historyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$historyPayload>
          }
          findMany: {
            args: Prisma.historyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$historyPayload>[]
          }
          create: {
            args: Prisma.historyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$historyPayload>
          }
          createMany: {
            args: Prisma.historyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.historyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$historyPayload>[]
          }
          delete: {
            args: Prisma.historyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$historyPayload>
          }
          update: {
            args: Prisma.historyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$historyPayload>
          }
          deleteMany: {
            args: Prisma.historyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.historyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.historyUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$historyPayload>[]
          }
          upsert: {
            args: Prisma.historyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$historyPayload>
          }
          aggregate: {
            args: Prisma.HistoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateHistory>
          }
          groupBy: {
            args: Prisma.historyGroupByArgs<ExtArgs>
            result: $Utils.Optional<HistoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.historyCountArgs<ExtArgs>
            result: $Utils.Optional<HistoryCountAggregateOutputType> | number
          }
        }
      }
      exports: {
        payload: Prisma.$exportsPayload<ExtArgs>
        fields: Prisma.exportsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.exportsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$exportsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.exportsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$exportsPayload>
          }
          findFirst: {
            args: Prisma.exportsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$exportsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.exportsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$exportsPayload>
          }
          findMany: {
            args: Prisma.exportsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$exportsPayload>[]
          }
          create: {
            args: Prisma.exportsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$exportsPayload>
          }
          createMany: {
            args: Prisma.exportsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.exportsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$exportsPayload>[]
          }
          delete: {
            args: Prisma.exportsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$exportsPayload>
          }
          update: {
            args: Prisma.exportsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$exportsPayload>
          }
          deleteMany: {
            args: Prisma.exportsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.exportsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.exportsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$exportsPayload>[]
          }
          upsert: {
            args: Prisma.exportsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$exportsPayload>
          }
          aggregate: {
            args: Prisma.ExportsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateExports>
          }
          groupBy: {
            args: Prisma.exportsGroupByArgs<ExtArgs>
            result: $Utils.Optional<ExportsGroupByOutputType>[]
          }
          count: {
            args: Prisma.exportsCountArgs<ExtArgs>
            result: $Utils.Optional<ExportsCountAggregateOutputType> | number
          }
        }
      }
      suggestions: {
        payload: Prisma.$suggestionsPayload<ExtArgs>
        fields: Prisma.suggestionsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.suggestionsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$suggestionsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.suggestionsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$suggestionsPayload>
          }
          findFirst: {
            args: Prisma.suggestionsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$suggestionsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.suggestionsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$suggestionsPayload>
          }
          findMany: {
            args: Prisma.suggestionsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$suggestionsPayload>[]
          }
          create: {
            args: Prisma.suggestionsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$suggestionsPayload>
          }
          createMany: {
            args: Prisma.suggestionsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.suggestionsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$suggestionsPayload>[]
          }
          delete: {
            args: Prisma.suggestionsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$suggestionsPayload>
          }
          update: {
            args: Prisma.suggestionsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$suggestionsPayload>
          }
          deleteMany: {
            args: Prisma.suggestionsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.suggestionsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.suggestionsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$suggestionsPayload>[]
          }
          upsert: {
            args: Prisma.suggestionsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$suggestionsPayload>
          }
          aggregate: {
            args: Prisma.SuggestionsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSuggestions>
          }
          groupBy: {
            args: Prisma.suggestionsGroupByArgs<ExtArgs>
            result: $Utils.Optional<SuggestionsGroupByOutputType>[]
          }
          count: {
            args: Prisma.suggestionsCountArgs<ExtArgs>
            result: $Utils.Optional<SuggestionsCountAggregateOutputType> | number
          }
        }
      }
      access_logs: {
        payload: Prisma.$access_logsPayload<ExtArgs>
        fields: Prisma.access_logsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.access_logsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$access_logsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.access_logsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$access_logsPayload>
          }
          findFirst: {
            args: Prisma.access_logsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$access_logsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.access_logsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$access_logsPayload>
          }
          findMany: {
            args: Prisma.access_logsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$access_logsPayload>[]
          }
          create: {
            args: Prisma.access_logsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$access_logsPayload>
          }
          createMany: {
            args: Prisma.access_logsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.access_logsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$access_logsPayload>[]
          }
          delete: {
            args: Prisma.access_logsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$access_logsPayload>
          }
          update: {
            args: Prisma.access_logsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$access_logsPayload>
          }
          deleteMany: {
            args: Prisma.access_logsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.access_logsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.access_logsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$access_logsPayload>[]
          }
          upsert: {
            args: Prisma.access_logsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$access_logsPayload>
          }
          aggregate: {
            args: Prisma.Access_logsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAccess_logs>
          }
          groupBy: {
            args: Prisma.access_logsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Access_logsGroupByOutputType>[]
          }
          count: {
            args: Prisma.access_logsCountArgs<ExtArgs>
            result: $Utils.Optional<Access_logsCountAggregateOutputType> | number
          }
        }
      }
      ai_chat_sessions: {
        payload: Prisma.$ai_chat_sessionsPayload<ExtArgs>
        fields: Prisma.ai_chat_sessionsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ai_chat_sessionsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ai_chat_sessionsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ai_chat_sessionsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ai_chat_sessionsPayload>
          }
          findFirst: {
            args: Prisma.ai_chat_sessionsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ai_chat_sessionsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ai_chat_sessionsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ai_chat_sessionsPayload>
          }
          findMany: {
            args: Prisma.ai_chat_sessionsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ai_chat_sessionsPayload>[]
          }
          create: {
            args: Prisma.ai_chat_sessionsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ai_chat_sessionsPayload>
          }
          createMany: {
            args: Prisma.ai_chat_sessionsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ai_chat_sessionsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ai_chat_sessionsPayload>[]
          }
          delete: {
            args: Prisma.ai_chat_sessionsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ai_chat_sessionsPayload>
          }
          update: {
            args: Prisma.ai_chat_sessionsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ai_chat_sessionsPayload>
          }
          deleteMany: {
            args: Prisma.ai_chat_sessionsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ai_chat_sessionsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ai_chat_sessionsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ai_chat_sessionsPayload>[]
          }
          upsert: {
            args: Prisma.ai_chat_sessionsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ai_chat_sessionsPayload>
          }
          aggregate: {
            args: Prisma.Ai_chat_sessionsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAi_chat_sessions>
          }
          groupBy: {
            args: Prisma.ai_chat_sessionsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Ai_chat_sessionsGroupByOutputType>[]
          }
          count: {
            args: Prisma.ai_chat_sessionsCountArgs<ExtArgs>
            result: $Utils.Optional<Ai_chat_sessionsCountAggregateOutputType> | number
          }
        }
      }
      ai_interactions: {
        payload: Prisma.$ai_interactionsPayload<ExtArgs>
        fields: Prisma.ai_interactionsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ai_interactionsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ai_interactionsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ai_interactionsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ai_interactionsPayload>
          }
          findFirst: {
            args: Prisma.ai_interactionsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ai_interactionsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ai_interactionsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ai_interactionsPayload>
          }
          findMany: {
            args: Prisma.ai_interactionsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ai_interactionsPayload>[]
          }
          create: {
            args: Prisma.ai_interactionsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ai_interactionsPayload>
          }
          createMany: {
            args: Prisma.ai_interactionsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ai_interactionsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ai_interactionsPayload>[]
          }
          delete: {
            args: Prisma.ai_interactionsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ai_interactionsPayload>
          }
          update: {
            args: Prisma.ai_interactionsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ai_interactionsPayload>
          }
          deleteMany: {
            args: Prisma.ai_interactionsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ai_interactionsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ai_interactionsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ai_interactionsPayload>[]
          }
          upsert: {
            args: Prisma.ai_interactionsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ai_interactionsPayload>
          }
          aggregate: {
            args: Prisma.Ai_interactionsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAi_interactions>
          }
          groupBy: {
            args: Prisma.ai_interactionsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Ai_interactionsGroupByOutputType>[]
          }
          count: {
            args: Prisma.ai_interactionsCountArgs<ExtArgs>
            result: $Utils.Optional<Ai_interactionsCountAggregateOutputType> | number
          }
        }
      }
      ai_insights: {
        payload: Prisma.$ai_insightsPayload<ExtArgs>
        fields: Prisma.ai_insightsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ai_insightsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ai_insightsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ai_insightsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ai_insightsPayload>
          }
          findFirst: {
            args: Prisma.ai_insightsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ai_insightsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ai_insightsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ai_insightsPayload>
          }
          findMany: {
            args: Prisma.ai_insightsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ai_insightsPayload>[]
          }
          create: {
            args: Prisma.ai_insightsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ai_insightsPayload>
          }
          createMany: {
            args: Prisma.ai_insightsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ai_insightsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ai_insightsPayload>[]
          }
          delete: {
            args: Prisma.ai_insightsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ai_insightsPayload>
          }
          update: {
            args: Prisma.ai_insightsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ai_insightsPayload>
          }
          deleteMany: {
            args: Prisma.ai_insightsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ai_insightsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ai_insightsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ai_insightsPayload>[]
          }
          upsert: {
            args: Prisma.ai_insightsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ai_insightsPayload>
          }
          aggregate: {
            args: Prisma.Ai_insightsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAi_insights>
          }
          groupBy: {
            args: Prisma.ai_insightsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Ai_insightsGroupByOutputType>[]
          }
          count: {
            args: Prisma.ai_insightsCountArgs<ExtArgs>
            result: $Utils.Optional<Ai_insightsCountAggregateOutputType> | number
          }
        }
      }
      ai_fallbacks: {
        payload: Prisma.$ai_fallbacksPayload<ExtArgs>
        fields: Prisma.ai_fallbacksFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ai_fallbacksFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ai_fallbacksPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ai_fallbacksFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ai_fallbacksPayload>
          }
          findFirst: {
            args: Prisma.ai_fallbacksFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ai_fallbacksPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ai_fallbacksFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ai_fallbacksPayload>
          }
          findMany: {
            args: Prisma.ai_fallbacksFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ai_fallbacksPayload>[]
          }
          create: {
            args: Prisma.ai_fallbacksCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ai_fallbacksPayload>
          }
          createMany: {
            args: Prisma.ai_fallbacksCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ai_fallbacksCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ai_fallbacksPayload>[]
          }
          delete: {
            args: Prisma.ai_fallbacksDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ai_fallbacksPayload>
          }
          update: {
            args: Prisma.ai_fallbacksUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ai_fallbacksPayload>
          }
          deleteMany: {
            args: Prisma.ai_fallbacksDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ai_fallbacksUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ai_fallbacksUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ai_fallbacksPayload>[]
          }
          upsert: {
            args: Prisma.ai_fallbacksUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ai_fallbacksPayload>
          }
          aggregate: {
            args: Prisma.Ai_fallbacksAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAi_fallbacks>
          }
          groupBy: {
            args: Prisma.ai_fallbacksGroupByArgs<ExtArgs>
            result: $Utils.Optional<Ai_fallbacksGroupByOutputType>[]
          }
          count: {
            args: Prisma.ai_fallbacksCountArgs<ExtArgs>
            result: $Utils.Optional<Ai_fallbacksCountAggregateOutputType> | number
          }
        }
      }
      ai_response_cache: {
        payload: Prisma.$ai_response_cachePayload<ExtArgs>
        fields: Prisma.ai_response_cacheFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ai_response_cacheFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ai_response_cachePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ai_response_cacheFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ai_response_cachePayload>
          }
          findFirst: {
            args: Prisma.ai_response_cacheFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ai_response_cachePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ai_response_cacheFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ai_response_cachePayload>
          }
          findMany: {
            args: Prisma.ai_response_cacheFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ai_response_cachePayload>[]
          }
          create: {
            args: Prisma.ai_response_cacheCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ai_response_cachePayload>
          }
          createMany: {
            args: Prisma.ai_response_cacheCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ai_response_cacheCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ai_response_cachePayload>[]
          }
          delete: {
            args: Prisma.ai_response_cacheDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ai_response_cachePayload>
          }
          update: {
            args: Prisma.ai_response_cacheUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ai_response_cachePayload>
          }
          deleteMany: {
            args: Prisma.ai_response_cacheDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ai_response_cacheUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ai_response_cacheUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ai_response_cachePayload>[]
          }
          upsert: {
            args: Prisma.ai_response_cacheUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ai_response_cachePayload>
          }
          aggregate: {
            args: Prisma.Ai_response_cacheAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAi_response_cache>
          }
          groupBy: {
            args: Prisma.ai_response_cacheGroupByArgs<ExtArgs>
            result: $Utils.Optional<Ai_response_cacheGroupByOutputType>[]
          }
          count: {
            args: Prisma.ai_response_cacheCountArgs<ExtArgs>
            result: $Utils.Optional<Ai_response_cacheCountAggregateOutputType> | number
          }
        }
      }
      associated_databases: {
        payload: Prisma.$associated_databasesPayload<ExtArgs>
        fields: Prisma.associated_databasesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.associated_databasesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$associated_databasesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.associated_databasesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$associated_databasesPayload>
          }
          findFirst: {
            args: Prisma.associated_databasesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$associated_databasesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.associated_databasesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$associated_databasesPayload>
          }
          findMany: {
            args: Prisma.associated_databasesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$associated_databasesPayload>[]
          }
          create: {
            args: Prisma.associated_databasesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$associated_databasesPayload>
          }
          createMany: {
            args: Prisma.associated_databasesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.associated_databasesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$associated_databasesPayload>[]
          }
          delete: {
            args: Prisma.associated_databasesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$associated_databasesPayload>
          }
          update: {
            args: Prisma.associated_databasesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$associated_databasesPayload>
          }
          deleteMany: {
            args: Prisma.associated_databasesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.associated_databasesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.associated_databasesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$associated_databasesPayload>[]
          }
          upsert: {
            args: Prisma.associated_databasesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$associated_databasesPayload>
          }
          aggregate: {
            args: Prisma.Associated_databasesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAssociated_databases>
          }
          groupBy: {
            args: Prisma.associated_databasesGroupByArgs<ExtArgs>
            result: $Utils.Optional<Associated_databasesGroupByOutputType>[]
          }
          count: {
            args: Prisma.associated_databasesCountArgs<ExtArgs>
            result: $Utils.Optional<Associated_databasesCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    users?: usersOmit
    queries?: queriesOmit
    results?: resultsOmit
    history?: historyOmit
    exports?: exportsOmit
    suggestions?: suggestionsOmit
    access_logs?: access_logsOmit
    ai_chat_sessions?: ai_chat_sessionsOmit
    ai_interactions?: ai_interactionsOmit
    ai_insights?: ai_insightsOmit
    ai_fallbacks?: ai_fallbacksOmit
    ai_response_cache?: ai_response_cacheOmit
    associated_databases?: associated_databasesOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UsersCountOutputType
   */

  export type UsersCountOutputType = {
    queries: number
    history: number
    exports: number
    suggestions: number
    access_logs: number
    ai_chat_sessions: number
    ai_interactions: number
    ai_insights: number
  }

  export type UsersCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    queries?: boolean | UsersCountOutputTypeCountQueriesArgs
    history?: boolean | UsersCountOutputTypeCountHistoryArgs
    exports?: boolean | UsersCountOutputTypeCountExportsArgs
    suggestions?: boolean | UsersCountOutputTypeCountSuggestionsArgs
    access_logs?: boolean | UsersCountOutputTypeCountAccess_logsArgs
    ai_chat_sessions?: boolean | UsersCountOutputTypeCountAi_chat_sessionsArgs
    ai_interactions?: boolean | UsersCountOutputTypeCountAi_interactionsArgs
    ai_insights?: boolean | UsersCountOutputTypeCountAi_insightsArgs
  }

  // Custom InputTypes
  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsersCountOutputType
     */
    select?: UsersCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountQueriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: queriesWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: historyWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountExportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: exportsWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountSuggestionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: suggestionsWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountAccess_logsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: access_logsWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountAi_chat_sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ai_chat_sessionsWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountAi_interactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ai_interactionsWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountAi_insightsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ai_insightsWhereInput
  }


  /**
   * Count Type QueriesCountOutputType
   */

  export type QueriesCountOutputType = {
    results: number
    history: number
  }

  export type QueriesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    results?: boolean | QueriesCountOutputTypeCountResultsArgs
    history?: boolean | QueriesCountOutputTypeCountHistoryArgs
  }

  // Custom InputTypes
  /**
   * QueriesCountOutputType without action
   */
  export type QueriesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QueriesCountOutputType
     */
    select?: QueriesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * QueriesCountOutputType without action
   */
  export type QueriesCountOutputTypeCountResultsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: resultsWhereInput
  }

  /**
   * QueriesCountOutputType without action
   */
  export type QueriesCountOutputTypeCountHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: historyWhereInput
  }


  /**
   * Count Type Ai_chat_sessionsCountOutputType
   */

  export type Ai_chat_sessionsCountOutputType = {
    interactions: number
  }

  export type Ai_chat_sessionsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    interactions?: boolean | Ai_chat_sessionsCountOutputTypeCountInteractionsArgs
  }

  // Custom InputTypes
  /**
   * Ai_chat_sessionsCountOutputType without action
   */
  export type Ai_chat_sessionsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ai_chat_sessionsCountOutputType
     */
    select?: Ai_chat_sessionsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Ai_chat_sessionsCountOutputType without action
   */
  export type Ai_chat_sessionsCountOutputTypeCountInteractionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ai_interactionsWhereInput
  }


  /**
   * Count Type Ai_interactionsCountOutputType
   */

  export type Ai_interactionsCountOutputType = {
    insights: number
  }

  export type Ai_interactionsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    insights?: boolean | Ai_interactionsCountOutputTypeCountInsightsArgs
  }

  // Custom InputTypes
  /**
   * Ai_interactionsCountOutputType without action
   */
  export type Ai_interactionsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ai_interactionsCountOutputType
     */
    select?: Ai_interactionsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Ai_interactionsCountOutputType without action
   */
  export type Ai_interactionsCountOutputTypeCountInsightsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ai_insightsWhereInput
  }


  /**
   * Models
   */

  /**
   * Model users
   */

  export type AggregateUsers = {
    _count: UsersCountAggregateOutputType | null
    _avg: UsersAvgAggregateOutputType | null
    _sum: UsersSumAggregateOutputType | null
    _min: UsersMinAggregateOutputType | null
    _max: UsersMaxAggregateOutputType | null
  }

  export type UsersAvgAggregateOutputType = {
    id: number | null
  }

  export type UsersSumAggregateOutputType = {
    id: number | null
  }

  export type UsersMinAggregateOutputType = {
    id: number | null
    name: string | null
    email: string | null
    password_hash: string | null
    role: string | null
    created_at: Date | null
  }

  export type UsersMaxAggregateOutputType = {
    id: number | null
    name: string | null
    email: string | null
    password_hash: string | null
    role: string | null
    created_at: Date | null
  }

  export type UsersCountAggregateOutputType = {
    id: number
    name: number
    email: number
    password_hash: number
    role: number
    created_at: number
    _all: number
  }


  export type UsersAvgAggregateInputType = {
    id?: true
  }

  export type UsersSumAggregateInputType = {
    id?: true
  }

  export type UsersMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
    password_hash?: true
    role?: true
    created_at?: true
  }

  export type UsersMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
    password_hash?: true
    role?: true
    created_at?: true
  }

  export type UsersCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    password_hash?: true
    role?: true
    created_at?: true
    _all?: true
  }

  export type UsersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which users to aggregate.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned users
    **/
    _count?: true | UsersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UsersAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UsersSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UsersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UsersMaxAggregateInputType
  }

  export type GetUsersAggregateType<T extends UsersAggregateArgs> = {
        [P in keyof T & keyof AggregateUsers]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsers[P]>
      : GetScalarType<T[P], AggregateUsers[P]>
  }




  export type usersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: usersWhereInput
    orderBy?: usersOrderByWithAggregationInput | usersOrderByWithAggregationInput[]
    by: UsersScalarFieldEnum[] | UsersScalarFieldEnum
    having?: usersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UsersCountAggregateInputType | true
    _avg?: UsersAvgAggregateInputType
    _sum?: UsersSumAggregateInputType
    _min?: UsersMinAggregateInputType
    _max?: UsersMaxAggregateInputType
  }

  export type UsersGroupByOutputType = {
    id: number
    name: string
    email: string
    password_hash: string
    role: string | null
    created_at: Date
    _count: UsersCountAggregateOutputType | null
    _avg: UsersAvgAggregateOutputType | null
    _sum: UsersSumAggregateOutputType | null
    _min: UsersMinAggregateOutputType | null
    _max: UsersMaxAggregateOutputType | null
  }

  type GetUsersGroupByPayload<T extends usersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UsersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UsersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UsersGroupByOutputType[P]>
            : GetScalarType<T[P], UsersGroupByOutputType[P]>
        }
      >
    >


  export type usersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    password_hash?: boolean
    role?: boolean
    created_at?: boolean
    queries?: boolean | users$queriesArgs<ExtArgs>
    history?: boolean | users$historyArgs<ExtArgs>
    exports?: boolean | users$exportsArgs<ExtArgs>
    suggestions?: boolean | users$suggestionsArgs<ExtArgs>
    access_logs?: boolean | users$access_logsArgs<ExtArgs>
    ai_chat_sessions?: boolean | users$ai_chat_sessionsArgs<ExtArgs>
    ai_interactions?: boolean | users$ai_interactionsArgs<ExtArgs>
    ai_insights?: boolean | users$ai_insightsArgs<ExtArgs>
    _count?: boolean | UsersCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["users"]>

  export type usersSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    password_hash?: boolean
    role?: boolean
    created_at?: boolean
  }, ExtArgs["result"]["users"]>

  export type usersSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    password_hash?: boolean
    role?: boolean
    created_at?: boolean
  }, ExtArgs["result"]["users"]>

  export type usersSelectScalar = {
    id?: boolean
    name?: boolean
    email?: boolean
    password_hash?: boolean
    role?: boolean
    created_at?: boolean
  }

  export type usersOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "email" | "password_hash" | "role" | "created_at", ExtArgs["result"]["users"]>
  export type usersInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    queries?: boolean | users$queriesArgs<ExtArgs>
    history?: boolean | users$historyArgs<ExtArgs>
    exports?: boolean | users$exportsArgs<ExtArgs>
    suggestions?: boolean | users$suggestionsArgs<ExtArgs>
    access_logs?: boolean | users$access_logsArgs<ExtArgs>
    ai_chat_sessions?: boolean | users$ai_chat_sessionsArgs<ExtArgs>
    ai_interactions?: boolean | users$ai_interactionsArgs<ExtArgs>
    ai_insights?: boolean | users$ai_insightsArgs<ExtArgs>
    _count?: boolean | UsersCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type usersIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type usersIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $usersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "users"
    objects: {
      queries: Prisma.$queriesPayload<ExtArgs>[]
      history: Prisma.$historyPayload<ExtArgs>[]
      exports: Prisma.$exportsPayload<ExtArgs>[]
      suggestions: Prisma.$suggestionsPayload<ExtArgs>[]
      access_logs: Prisma.$access_logsPayload<ExtArgs>[]
      ai_chat_sessions: Prisma.$ai_chat_sessionsPayload<ExtArgs>[]
      ai_interactions: Prisma.$ai_interactionsPayload<ExtArgs>[]
      ai_insights: Prisma.$ai_insightsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      email: string
      password_hash: string
      role: string | null
      created_at: Date
    }, ExtArgs["result"]["users"]>
    composites: {}
  }

  type usersGetPayload<S extends boolean | null | undefined | usersDefaultArgs> = $Result.GetResult<Prisma.$usersPayload, S>

  type usersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<usersFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UsersCountAggregateInputType | true
    }

  export interface usersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['users'], meta: { name: 'users' } }
    /**
     * Find zero or one Users that matches the filter.
     * @param {usersFindUniqueArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends usersFindUniqueArgs>(args: SelectSubset<T, usersFindUniqueArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Users that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {usersFindUniqueOrThrowArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends usersFindUniqueOrThrowArgs>(args: SelectSubset<T, usersFindUniqueOrThrowArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersFindFirstArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends usersFindFirstArgs>(args?: SelectSubset<T, usersFindFirstArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Users that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersFindFirstOrThrowArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends usersFindFirstOrThrowArgs>(args?: SelectSubset<T, usersFindFirstOrThrowArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.users.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.users.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const usersWithIdOnly = await prisma.users.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends usersFindManyArgs>(args?: SelectSubset<T, usersFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Users.
     * @param {usersCreateArgs} args - Arguments to create a Users.
     * @example
     * // Create one Users
     * const Users = await prisma.users.create({
     *   data: {
     *     // ... data to create a Users
     *   }
     * })
     * 
     */
    create<T extends usersCreateArgs>(args: SelectSubset<T, usersCreateArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {usersCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const users = await prisma.users.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends usersCreateManyArgs>(args?: SelectSubset<T, usersCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {usersCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const users = await prisma.users.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const usersWithIdOnly = await prisma.users.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends usersCreateManyAndReturnArgs>(args?: SelectSubset<T, usersCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Users.
     * @param {usersDeleteArgs} args - Arguments to delete one Users.
     * @example
     * // Delete one Users
     * const Users = await prisma.users.delete({
     *   where: {
     *     // ... filter to delete one Users
     *   }
     * })
     * 
     */
    delete<T extends usersDeleteArgs>(args: SelectSubset<T, usersDeleteArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Users.
     * @param {usersUpdateArgs} args - Arguments to update one Users.
     * @example
     * // Update one Users
     * const users = await prisma.users.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends usersUpdateArgs>(args: SelectSubset<T, usersUpdateArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {usersDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.users.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends usersDeleteManyArgs>(args?: SelectSubset<T, usersDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const users = await prisma.users.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends usersUpdateManyArgs>(args: SelectSubset<T, usersUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {usersUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const users = await prisma.users.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const usersWithIdOnly = await prisma.users.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends usersUpdateManyAndReturnArgs>(args: SelectSubset<T, usersUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Users.
     * @param {usersUpsertArgs} args - Arguments to update or create a Users.
     * @example
     * // Update or create a Users
     * const users = await prisma.users.upsert({
     *   create: {
     *     // ... data to create a Users
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Users we want to update
     *   }
     * })
     */
    upsert<T extends usersUpsertArgs>(args: SelectSubset<T, usersUpsertArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.users.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends usersCountArgs>(
      args?: Subset<T, usersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UsersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UsersAggregateArgs>(args: Subset<T, UsersAggregateArgs>): Prisma.PrismaPromise<GetUsersAggregateType<T>>

    /**
     * Group by Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends usersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: usersGroupByArgs['orderBy'] }
        : { orderBy?: usersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, usersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the users model
   */
  readonly fields: usersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for users.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__usersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    queries<T extends users$queriesArgs<ExtArgs> = {}>(args?: Subset<T, users$queriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$queriesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    history<T extends users$historyArgs<ExtArgs> = {}>(args?: Subset<T, users$historyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$historyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    exports<T extends users$exportsArgs<ExtArgs> = {}>(args?: Subset<T, users$exportsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$exportsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    suggestions<T extends users$suggestionsArgs<ExtArgs> = {}>(args?: Subset<T, users$suggestionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$suggestionsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    access_logs<T extends users$access_logsArgs<ExtArgs> = {}>(args?: Subset<T, users$access_logsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$access_logsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    ai_chat_sessions<T extends users$ai_chat_sessionsArgs<ExtArgs> = {}>(args?: Subset<T, users$ai_chat_sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ai_chat_sessionsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    ai_interactions<T extends users$ai_interactionsArgs<ExtArgs> = {}>(args?: Subset<T, users$ai_interactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ai_interactionsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    ai_insights<T extends users$ai_insightsArgs<ExtArgs> = {}>(args?: Subset<T, users$ai_insightsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ai_insightsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the users model
   */
  interface usersFieldRefs {
    readonly id: FieldRef<"users", 'Int'>
    readonly name: FieldRef<"users", 'String'>
    readonly email: FieldRef<"users", 'String'>
    readonly password_hash: FieldRef<"users", 'String'>
    readonly role: FieldRef<"users", 'String'>
    readonly created_at: FieldRef<"users", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * users findUnique
   */
  export type usersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users findUniqueOrThrow
   */
  export type usersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users findFirst
   */
  export type usersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users.
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users.
     */
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * users findFirstOrThrow
   */
  export type usersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users.
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users.
     */
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * users findMany
   */
  export type usersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing users.
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * users create
   */
  export type usersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * The data needed to create a users.
     */
    data: XOR<usersCreateInput, usersUncheckedCreateInput>
  }

  /**
   * users createMany
   */
  export type usersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many users.
     */
    data: usersCreateManyInput | usersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * users createManyAndReturn
   */
  export type usersCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * The data used to create many users.
     */
    data: usersCreateManyInput | usersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * users update
   */
  export type usersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * The data needed to update a users.
     */
    data: XOR<usersUpdateInput, usersUncheckedUpdateInput>
    /**
     * Choose, which users to update.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users updateMany
   */
  export type usersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update users.
     */
    data: XOR<usersUpdateManyMutationInput, usersUncheckedUpdateManyInput>
    /**
     * Filter which users to update
     */
    where?: usersWhereInput
    /**
     * Limit how many users to update.
     */
    limit?: number
  }

  /**
   * users updateManyAndReturn
   */
  export type usersUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * The data used to update users.
     */
    data: XOR<usersUpdateManyMutationInput, usersUncheckedUpdateManyInput>
    /**
     * Filter which users to update
     */
    where?: usersWhereInput
    /**
     * Limit how many users to update.
     */
    limit?: number
  }

  /**
   * users upsert
   */
  export type usersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * The filter to search for the users to update in case it exists.
     */
    where: usersWhereUniqueInput
    /**
     * In case the users found by the `where` argument doesn't exist, create a new users with this data.
     */
    create: XOR<usersCreateInput, usersUncheckedCreateInput>
    /**
     * In case the users was found with the provided `where` argument, update it with this data.
     */
    update: XOR<usersUpdateInput, usersUncheckedUpdateInput>
  }

  /**
   * users delete
   */
  export type usersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter which users to delete.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users deleteMany
   */
  export type usersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which users to delete
     */
    where?: usersWhereInput
    /**
     * Limit how many users to delete.
     */
    limit?: number
  }

  /**
   * users.queries
   */
  export type users$queriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the queries
     */
    select?: queriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the queries
     */
    omit?: queriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: queriesInclude<ExtArgs> | null
    where?: queriesWhereInput
    orderBy?: queriesOrderByWithRelationInput | queriesOrderByWithRelationInput[]
    cursor?: queriesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QueriesScalarFieldEnum | QueriesScalarFieldEnum[]
  }

  /**
   * users.history
   */
  export type users$historyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the history
     */
    select?: historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the history
     */
    omit?: historyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: historyInclude<ExtArgs> | null
    where?: historyWhereInput
    orderBy?: historyOrderByWithRelationInput | historyOrderByWithRelationInput[]
    cursor?: historyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: HistoryScalarFieldEnum | HistoryScalarFieldEnum[]
  }

  /**
   * users.exports
   */
  export type users$exportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the exports
     */
    select?: exportsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the exports
     */
    omit?: exportsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: exportsInclude<ExtArgs> | null
    where?: exportsWhereInput
    orderBy?: exportsOrderByWithRelationInput | exportsOrderByWithRelationInput[]
    cursor?: exportsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExportsScalarFieldEnum | ExportsScalarFieldEnum[]
  }

  /**
   * users.suggestions
   */
  export type users$suggestionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the suggestions
     */
    select?: suggestionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the suggestions
     */
    omit?: suggestionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: suggestionsInclude<ExtArgs> | null
    where?: suggestionsWhereInput
    orderBy?: suggestionsOrderByWithRelationInput | suggestionsOrderByWithRelationInput[]
    cursor?: suggestionsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SuggestionsScalarFieldEnum | SuggestionsScalarFieldEnum[]
  }

  /**
   * users.access_logs
   */
  export type users$access_logsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the access_logs
     */
    select?: access_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the access_logs
     */
    omit?: access_logsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: access_logsInclude<ExtArgs> | null
    where?: access_logsWhereInput
    orderBy?: access_logsOrderByWithRelationInput | access_logsOrderByWithRelationInput[]
    cursor?: access_logsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Access_logsScalarFieldEnum | Access_logsScalarFieldEnum[]
  }

  /**
   * users.ai_chat_sessions
   */
  export type users$ai_chat_sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ai_chat_sessions
     */
    select?: ai_chat_sessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ai_chat_sessions
     */
    omit?: ai_chat_sessionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ai_chat_sessionsInclude<ExtArgs> | null
    where?: ai_chat_sessionsWhereInput
    orderBy?: ai_chat_sessionsOrderByWithRelationInput | ai_chat_sessionsOrderByWithRelationInput[]
    cursor?: ai_chat_sessionsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Ai_chat_sessionsScalarFieldEnum | Ai_chat_sessionsScalarFieldEnum[]
  }

  /**
   * users.ai_interactions
   */
  export type users$ai_interactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ai_interactions
     */
    select?: ai_interactionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ai_interactions
     */
    omit?: ai_interactionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ai_interactionsInclude<ExtArgs> | null
    where?: ai_interactionsWhereInput
    orderBy?: ai_interactionsOrderByWithRelationInput | ai_interactionsOrderByWithRelationInput[]
    cursor?: ai_interactionsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Ai_interactionsScalarFieldEnum | Ai_interactionsScalarFieldEnum[]
  }

  /**
   * users.ai_insights
   */
  export type users$ai_insightsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ai_insights
     */
    select?: ai_insightsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ai_insights
     */
    omit?: ai_insightsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ai_insightsInclude<ExtArgs> | null
    where?: ai_insightsWhereInput
    orderBy?: ai_insightsOrderByWithRelationInput | ai_insightsOrderByWithRelationInput[]
    cursor?: ai_insightsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Ai_insightsScalarFieldEnum | Ai_insightsScalarFieldEnum[]
  }

  /**
   * users without action
   */
  export type usersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
  }


  /**
   * Model queries
   */

  export type AggregateQueries = {
    _count: QueriesCountAggregateOutputType | null
    _avg: QueriesAvgAggregateOutputType | null
    _sum: QueriesSumAggregateOutputType | null
    _min: QueriesMinAggregateOutputType | null
    _max: QueriesMaxAggregateOutputType | null
  }

  export type QueriesAvgAggregateOutputType = {
    id: number | null
    user_id: number | null
  }

  export type QueriesSumAggregateOutputType = {
    id: number | null
    user_id: number | null
  }

  export type QueriesMinAggregateOutputType = {
    id: number | null
    user_id: number | null
    question_text: string | null
    created_at: Date | null
  }

  export type QueriesMaxAggregateOutputType = {
    id: number | null
    user_id: number | null
    question_text: string | null
    created_at: Date | null
  }

  export type QueriesCountAggregateOutputType = {
    id: number
    user_id: number
    question_text: number
    created_at: number
    _all: number
  }


  export type QueriesAvgAggregateInputType = {
    id?: true
    user_id?: true
  }

  export type QueriesSumAggregateInputType = {
    id?: true
    user_id?: true
  }

  export type QueriesMinAggregateInputType = {
    id?: true
    user_id?: true
    question_text?: true
    created_at?: true
  }

  export type QueriesMaxAggregateInputType = {
    id?: true
    user_id?: true
    question_text?: true
    created_at?: true
  }

  export type QueriesCountAggregateInputType = {
    id?: true
    user_id?: true
    question_text?: true
    created_at?: true
    _all?: true
  }

  export type QueriesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which queries to aggregate.
     */
    where?: queriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of queries to fetch.
     */
    orderBy?: queriesOrderByWithRelationInput | queriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: queriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` queries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` queries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned queries
    **/
    _count?: true | QueriesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: QueriesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: QueriesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QueriesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QueriesMaxAggregateInputType
  }

  export type GetQueriesAggregateType<T extends QueriesAggregateArgs> = {
        [P in keyof T & keyof AggregateQueries]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQueries[P]>
      : GetScalarType<T[P], AggregateQueries[P]>
  }




  export type queriesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: queriesWhereInput
    orderBy?: queriesOrderByWithAggregationInput | queriesOrderByWithAggregationInput[]
    by: QueriesScalarFieldEnum[] | QueriesScalarFieldEnum
    having?: queriesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QueriesCountAggregateInputType | true
    _avg?: QueriesAvgAggregateInputType
    _sum?: QueriesSumAggregateInputType
    _min?: QueriesMinAggregateInputType
    _max?: QueriesMaxAggregateInputType
  }

  export type QueriesGroupByOutputType = {
    id: number
    user_id: number
    question_text: string | null
    created_at: Date
    _count: QueriesCountAggregateOutputType | null
    _avg: QueriesAvgAggregateOutputType | null
    _sum: QueriesSumAggregateOutputType | null
    _min: QueriesMinAggregateOutputType | null
    _max: QueriesMaxAggregateOutputType | null
  }

  type GetQueriesGroupByPayload<T extends queriesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<QueriesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QueriesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QueriesGroupByOutputType[P]>
            : GetScalarType<T[P], QueriesGroupByOutputType[P]>
        }
      >
    >


  export type queriesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    question_text?: boolean
    created_at?: boolean
    user?: boolean | usersDefaultArgs<ExtArgs>
    results?: boolean | queries$resultsArgs<ExtArgs>
    history?: boolean | queries$historyArgs<ExtArgs>
    _count?: boolean | QueriesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["queries"]>

  export type queriesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    question_text?: boolean
    created_at?: boolean
    user?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["queries"]>

  export type queriesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    question_text?: boolean
    created_at?: boolean
    user?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["queries"]>

  export type queriesSelectScalar = {
    id?: boolean
    user_id?: boolean
    question_text?: boolean
    created_at?: boolean
  }

  export type queriesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "user_id" | "question_text" | "created_at", ExtArgs["result"]["queries"]>
  export type queriesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | usersDefaultArgs<ExtArgs>
    results?: boolean | queries$resultsArgs<ExtArgs>
    history?: boolean | queries$historyArgs<ExtArgs>
    _count?: boolean | QueriesCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type queriesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type queriesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | usersDefaultArgs<ExtArgs>
  }

  export type $queriesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "queries"
    objects: {
      user: Prisma.$usersPayload<ExtArgs>
      results: Prisma.$resultsPayload<ExtArgs>[]
      history: Prisma.$historyPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      user_id: number
      question_text: string | null
      created_at: Date
    }, ExtArgs["result"]["queries"]>
    composites: {}
  }

  type queriesGetPayload<S extends boolean | null | undefined | queriesDefaultArgs> = $Result.GetResult<Prisma.$queriesPayload, S>

  type queriesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<queriesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: QueriesCountAggregateInputType | true
    }

  export interface queriesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['queries'], meta: { name: 'queries' } }
    /**
     * Find zero or one Queries that matches the filter.
     * @param {queriesFindUniqueArgs} args - Arguments to find a Queries
     * @example
     * // Get one Queries
     * const queries = await prisma.queries.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends queriesFindUniqueArgs>(args: SelectSubset<T, queriesFindUniqueArgs<ExtArgs>>): Prisma__queriesClient<$Result.GetResult<Prisma.$queriesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Queries that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {queriesFindUniqueOrThrowArgs} args - Arguments to find a Queries
     * @example
     * // Get one Queries
     * const queries = await prisma.queries.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends queriesFindUniqueOrThrowArgs>(args: SelectSubset<T, queriesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__queriesClient<$Result.GetResult<Prisma.$queriesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Queries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {queriesFindFirstArgs} args - Arguments to find a Queries
     * @example
     * // Get one Queries
     * const queries = await prisma.queries.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends queriesFindFirstArgs>(args?: SelectSubset<T, queriesFindFirstArgs<ExtArgs>>): Prisma__queriesClient<$Result.GetResult<Prisma.$queriesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Queries that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {queriesFindFirstOrThrowArgs} args - Arguments to find a Queries
     * @example
     * // Get one Queries
     * const queries = await prisma.queries.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends queriesFindFirstOrThrowArgs>(args?: SelectSubset<T, queriesFindFirstOrThrowArgs<ExtArgs>>): Prisma__queriesClient<$Result.GetResult<Prisma.$queriesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Queries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {queriesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Queries
     * const queries = await prisma.queries.findMany()
     * 
     * // Get first 10 Queries
     * const queries = await prisma.queries.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const queriesWithIdOnly = await prisma.queries.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends queriesFindManyArgs>(args?: SelectSubset<T, queriesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$queriesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Queries.
     * @param {queriesCreateArgs} args - Arguments to create a Queries.
     * @example
     * // Create one Queries
     * const Queries = await prisma.queries.create({
     *   data: {
     *     // ... data to create a Queries
     *   }
     * })
     * 
     */
    create<T extends queriesCreateArgs>(args: SelectSubset<T, queriesCreateArgs<ExtArgs>>): Prisma__queriesClient<$Result.GetResult<Prisma.$queriesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Queries.
     * @param {queriesCreateManyArgs} args - Arguments to create many Queries.
     * @example
     * // Create many Queries
     * const queries = await prisma.queries.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends queriesCreateManyArgs>(args?: SelectSubset<T, queriesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Queries and returns the data saved in the database.
     * @param {queriesCreateManyAndReturnArgs} args - Arguments to create many Queries.
     * @example
     * // Create many Queries
     * const queries = await prisma.queries.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Queries and only return the `id`
     * const queriesWithIdOnly = await prisma.queries.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends queriesCreateManyAndReturnArgs>(args?: SelectSubset<T, queriesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$queriesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Queries.
     * @param {queriesDeleteArgs} args - Arguments to delete one Queries.
     * @example
     * // Delete one Queries
     * const Queries = await prisma.queries.delete({
     *   where: {
     *     // ... filter to delete one Queries
     *   }
     * })
     * 
     */
    delete<T extends queriesDeleteArgs>(args: SelectSubset<T, queriesDeleteArgs<ExtArgs>>): Prisma__queriesClient<$Result.GetResult<Prisma.$queriesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Queries.
     * @param {queriesUpdateArgs} args - Arguments to update one Queries.
     * @example
     * // Update one Queries
     * const queries = await prisma.queries.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends queriesUpdateArgs>(args: SelectSubset<T, queriesUpdateArgs<ExtArgs>>): Prisma__queriesClient<$Result.GetResult<Prisma.$queriesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Queries.
     * @param {queriesDeleteManyArgs} args - Arguments to filter Queries to delete.
     * @example
     * // Delete a few Queries
     * const { count } = await prisma.queries.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends queriesDeleteManyArgs>(args?: SelectSubset<T, queriesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Queries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {queriesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Queries
     * const queries = await prisma.queries.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends queriesUpdateManyArgs>(args: SelectSubset<T, queriesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Queries and returns the data updated in the database.
     * @param {queriesUpdateManyAndReturnArgs} args - Arguments to update many Queries.
     * @example
     * // Update many Queries
     * const queries = await prisma.queries.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Queries and only return the `id`
     * const queriesWithIdOnly = await prisma.queries.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends queriesUpdateManyAndReturnArgs>(args: SelectSubset<T, queriesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$queriesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Queries.
     * @param {queriesUpsertArgs} args - Arguments to update or create a Queries.
     * @example
     * // Update or create a Queries
     * const queries = await prisma.queries.upsert({
     *   create: {
     *     // ... data to create a Queries
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Queries we want to update
     *   }
     * })
     */
    upsert<T extends queriesUpsertArgs>(args: SelectSubset<T, queriesUpsertArgs<ExtArgs>>): Prisma__queriesClient<$Result.GetResult<Prisma.$queriesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Queries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {queriesCountArgs} args - Arguments to filter Queries to count.
     * @example
     * // Count the number of Queries
     * const count = await prisma.queries.count({
     *   where: {
     *     // ... the filter for the Queries we want to count
     *   }
     * })
    **/
    count<T extends queriesCountArgs>(
      args?: Subset<T, queriesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QueriesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Queries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QueriesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QueriesAggregateArgs>(args: Subset<T, QueriesAggregateArgs>): Prisma.PrismaPromise<GetQueriesAggregateType<T>>

    /**
     * Group by Queries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {queriesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends queriesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: queriesGroupByArgs['orderBy'] }
        : { orderBy?: queriesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, queriesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQueriesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the queries model
   */
  readonly fields: queriesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for queries.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__queriesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    results<T extends queries$resultsArgs<ExtArgs> = {}>(args?: Subset<T, queries$resultsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$resultsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    history<T extends queries$historyArgs<ExtArgs> = {}>(args?: Subset<T, queries$historyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$historyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the queries model
   */
  interface queriesFieldRefs {
    readonly id: FieldRef<"queries", 'Int'>
    readonly user_id: FieldRef<"queries", 'Int'>
    readonly question_text: FieldRef<"queries", 'String'>
    readonly created_at: FieldRef<"queries", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * queries findUnique
   */
  export type queriesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the queries
     */
    select?: queriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the queries
     */
    omit?: queriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: queriesInclude<ExtArgs> | null
    /**
     * Filter, which queries to fetch.
     */
    where: queriesWhereUniqueInput
  }

  /**
   * queries findUniqueOrThrow
   */
  export type queriesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the queries
     */
    select?: queriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the queries
     */
    omit?: queriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: queriesInclude<ExtArgs> | null
    /**
     * Filter, which queries to fetch.
     */
    where: queriesWhereUniqueInput
  }

  /**
   * queries findFirst
   */
  export type queriesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the queries
     */
    select?: queriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the queries
     */
    omit?: queriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: queriesInclude<ExtArgs> | null
    /**
     * Filter, which queries to fetch.
     */
    where?: queriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of queries to fetch.
     */
    orderBy?: queriesOrderByWithRelationInput | queriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for queries.
     */
    cursor?: queriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` queries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` queries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of queries.
     */
    distinct?: QueriesScalarFieldEnum | QueriesScalarFieldEnum[]
  }

  /**
   * queries findFirstOrThrow
   */
  export type queriesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the queries
     */
    select?: queriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the queries
     */
    omit?: queriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: queriesInclude<ExtArgs> | null
    /**
     * Filter, which queries to fetch.
     */
    where?: queriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of queries to fetch.
     */
    orderBy?: queriesOrderByWithRelationInput | queriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for queries.
     */
    cursor?: queriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` queries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` queries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of queries.
     */
    distinct?: QueriesScalarFieldEnum | QueriesScalarFieldEnum[]
  }

  /**
   * queries findMany
   */
  export type queriesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the queries
     */
    select?: queriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the queries
     */
    omit?: queriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: queriesInclude<ExtArgs> | null
    /**
     * Filter, which queries to fetch.
     */
    where?: queriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of queries to fetch.
     */
    orderBy?: queriesOrderByWithRelationInput | queriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing queries.
     */
    cursor?: queriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` queries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` queries.
     */
    skip?: number
    distinct?: QueriesScalarFieldEnum | QueriesScalarFieldEnum[]
  }

  /**
   * queries create
   */
  export type queriesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the queries
     */
    select?: queriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the queries
     */
    omit?: queriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: queriesInclude<ExtArgs> | null
    /**
     * The data needed to create a queries.
     */
    data: XOR<queriesCreateInput, queriesUncheckedCreateInput>
  }

  /**
   * queries createMany
   */
  export type queriesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many queries.
     */
    data: queriesCreateManyInput | queriesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * queries createManyAndReturn
   */
  export type queriesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the queries
     */
    select?: queriesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the queries
     */
    omit?: queriesOmit<ExtArgs> | null
    /**
     * The data used to create many queries.
     */
    data: queriesCreateManyInput | queriesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: queriesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * queries update
   */
  export type queriesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the queries
     */
    select?: queriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the queries
     */
    omit?: queriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: queriesInclude<ExtArgs> | null
    /**
     * The data needed to update a queries.
     */
    data: XOR<queriesUpdateInput, queriesUncheckedUpdateInput>
    /**
     * Choose, which queries to update.
     */
    where: queriesWhereUniqueInput
  }

  /**
   * queries updateMany
   */
  export type queriesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update queries.
     */
    data: XOR<queriesUpdateManyMutationInput, queriesUncheckedUpdateManyInput>
    /**
     * Filter which queries to update
     */
    where?: queriesWhereInput
    /**
     * Limit how many queries to update.
     */
    limit?: number
  }

  /**
   * queries updateManyAndReturn
   */
  export type queriesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the queries
     */
    select?: queriesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the queries
     */
    omit?: queriesOmit<ExtArgs> | null
    /**
     * The data used to update queries.
     */
    data: XOR<queriesUpdateManyMutationInput, queriesUncheckedUpdateManyInput>
    /**
     * Filter which queries to update
     */
    where?: queriesWhereInput
    /**
     * Limit how many queries to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: queriesIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * queries upsert
   */
  export type queriesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the queries
     */
    select?: queriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the queries
     */
    omit?: queriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: queriesInclude<ExtArgs> | null
    /**
     * The filter to search for the queries to update in case it exists.
     */
    where: queriesWhereUniqueInput
    /**
     * In case the queries found by the `where` argument doesn't exist, create a new queries with this data.
     */
    create: XOR<queriesCreateInput, queriesUncheckedCreateInput>
    /**
     * In case the queries was found with the provided `where` argument, update it with this data.
     */
    update: XOR<queriesUpdateInput, queriesUncheckedUpdateInput>
  }

  /**
   * queries delete
   */
  export type queriesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the queries
     */
    select?: queriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the queries
     */
    omit?: queriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: queriesInclude<ExtArgs> | null
    /**
     * Filter which queries to delete.
     */
    where: queriesWhereUniqueInput
  }

  /**
   * queries deleteMany
   */
  export type queriesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which queries to delete
     */
    where?: queriesWhereInput
    /**
     * Limit how many queries to delete.
     */
    limit?: number
  }

  /**
   * queries.results
   */
  export type queries$resultsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the results
     */
    select?: resultsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the results
     */
    omit?: resultsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: resultsInclude<ExtArgs> | null
    where?: resultsWhereInput
    orderBy?: resultsOrderByWithRelationInput | resultsOrderByWithRelationInput[]
    cursor?: resultsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ResultsScalarFieldEnum | ResultsScalarFieldEnum[]
  }

  /**
   * queries.history
   */
  export type queries$historyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the history
     */
    select?: historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the history
     */
    omit?: historyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: historyInclude<ExtArgs> | null
    where?: historyWhereInput
    orderBy?: historyOrderByWithRelationInput | historyOrderByWithRelationInput[]
    cursor?: historyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: HistoryScalarFieldEnum | HistoryScalarFieldEnum[]
  }

  /**
   * queries without action
   */
  export type queriesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the queries
     */
    select?: queriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the queries
     */
    omit?: queriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: queriesInclude<ExtArgs> | null
  }


  /**
   * Model results
   */

  export type AggregateResults = {
    _count: ResultsCountAggregateOutputType | null
    _avg: ResultsAvgAggregateOutputType | null
    _sum: ResultsSumAggregateOutputType | null
    _min: ResultsMinAggregateOutputType | null
    _max: ResultsMaxAggregateOutputType | null
  }

  export type ResultsAvgAggregateOutputType = {
    id: number | null
    query_id: number | null
  }

  export type ResultsSumAggregateOutputType = {
    id: number | null
    query_id: number | null
  }

  export type ResultsMinAggregateOutputType = {
    id: number | null
    query_id: number | null
    result_type: string | null
    created_at: Date | null
  }

  export type ResultsMaxAggregateOutputType = {
    id: number | null
    query_id: number | null
    result_type: string | null
    created_at: Date | null
  }

  export type ResultsCountAggregateOutputType = {
    id: number
    query_id: number
    result_type: number
    content: number
    created_at: number
    _all: number
  }


  export type ResultsAvgAggregateInputType = {
    id?: true
    query_id?: true
  }

  export type ResultsSumAggregateInputType = {
    id?: true
    query_id?: true
  }

  export type ResultsMinAggregateInputType = {
    id?: true
    query_id?: true
    result_type?: true
    created_at?: true
  }

  export type ResultsMaxAggregateInputType = {
    id?: true
    query_id?: true
    result_type?: true
    created_at?: true
  }

  export type ResultsCountAggregateInputType = {
    id?: true
    query_id?: true
    result_type?: true
    content?: true
    created_at?: true
    _all?: true
  }

  export type ResultsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which results to aggregate.
     */
    where?: resultsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of results to fetch.
     */
    orderBy?: resultsOrderByWithRelationInput | resultsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: resultsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` results from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` results.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned results
    **/
    _count?: true | ResultsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ResultsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ResultsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ResultsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ResultsMaxAggregateInputType
  }

  export type GetResultsAggregateType<T extends ResultsAggregateArgs> = {
        [P in keyof T & keyof AggregateResults]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateResults[P]>
      : GetScalarType<T[P], AggregateResults[P]>
  }




  export type resultsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: resultsWhereInput
    orderBy?: resultsOrderByWithAggregationInput | resultsOrderByWithAggregationInput[]
    by: ResultsScalarFieldEnum[] | ResultsScalarFieldEnum
    having?: resultsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ResultsCountAggregateInputType | true
    _avg?: ResultsAvgAggregateInputType
    _sum?: ResultsSumAggregateInputType
    _min?: ResultsMinAggregateInputType
    _max?: ResultsMaxAggregateInputType
  }

  export type ResultsGroupByOutputType = {
    id: number
    query_id: number
    result_type: string | null
    content: JsonValue | null
    created_at: Date
    _count: ResultsCountAggregateOutputType | null
    _avg: ResultsAvgAggregateOutputType | null
    _sum: ResultsSumAggregateOutputType | null
    _min: ResultsMinAggregateOutputType | null
    _max: ResultsMaxAggregateOutputType | null
  }

  type GetResultsGroupByPayload<T extends resultsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ResultsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ResultsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ResultsGroupByOutputType[P]>
            : GetScalarType<T[P], ResultsGroupByOutputType[P]>
        }
      >
    >


  export type resultsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    query_id?: boolean
    result_type?: boolean
    content?: boolean
    created_at?: boolean
    query?: boolean | queriesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["results"]>

  export type resultsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    query_id?: boolean
    result_type?: boolean
    content?: boolean
    created_at?: boolean
    query?: boolean | queriesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["results"]>

  export type resultsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    query_id?: boolean
    result_type?: boolean
    content?: boolean
    created_at?: boolean
    query?: boolean | queriesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["results"]>

  export type resultsSelectScalar = {
    id?: boolean
    query_id?: boolean
    result_type?: boolean
    content?: boolean
    created_at?: boolean
  }

  export type resultsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "query_id" | "result_type" | "content" | "created_at", ExtArgs["result"]["results"]>
  export type resultsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    query?: boolean | queriesDefaultArgs<ExtArgs>
  }
  export type resultsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    query?: boolean | queriesDefaultArgs<ExtArgs>
  }
  export type resultsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    query?: boolean | queriesDefaultArgs<ExtArgs>
  }

  export type $resultsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "results"
    objects: {
      query: Prisma.$queriesPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      query_id: number
      result_type: string | null
      content: Prisma.JsonValue | null
      created_at: Date
    }, ExtArgs["result"]["results"]>
    composites: {}
  }

  type resultsGetPayload<S extends boolean | null | undefined | resultsDefaultArgs> = $Result.GetResult<Prisma.$resultsPayload, S>

  type resultsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<resultsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ResultsCountAggregateInputType | true
    }

  export interface resultsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['results'], meta: { name: 'results' } }
    /**
     * Find zero or one Results that matches the filter.
     * @param {resultsFindUniqueArgs} args - Arguments to find a Results
     * @example
     * // Get one Results
     * const results = await prisma.results.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends resultsFindUniqueArgs>(args: SelectSubset<T, resultsFindUniqueArgs<ExtArgs>>): Prisma__resultsClient<$Result.GetResult<Prisma.$resultsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Results that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {resultsFindUniqueOrThrowArgs} args - Arguments to find a Results
     * @example
     * // Get one Results
     * const results = await prisma.results.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends resultsFindUniqueOrThrowArgs>(args: SelectSubset<T, resultsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__resultsClient<$Result.GetResult<Prisma.$resultsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Results that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {resultsFindFirstArgs} args - Arguments to find a Results
     * @example
     * // Get one Results
     * const results = await prisma.results.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends resultsFindFirstArgs>(args?: SelectSubset<T, resultsFindFirstArgs<ExtArgs>>): Prisma__resultsClient<$Result.GetResult<Prisma.$resultsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Results that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {resultsFindFirstOrThrowArgs} args - Arguments to find a Results
     * @example
     * // Get one Results
     * const results = await prisma.results.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends resultsFindFirstOrThrowArgs>(args?: SelectSubset<T, resultsFindFirstOrThrowArgs<ExtArgs>>): Prisma__resultsClient<$Result.GetResult<Prisma.$resultsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Results that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {resultsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Results
     * const results = await prisma.results.findMany()
     * 
     * // Get first 10 Results
     * const results = await prisma.results.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const resultsWithIdOnly = await prisma.results.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends resultsFindManyArgs>(args?: SelectSubset<T, resultsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$resultsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Results.
     * @param {resultsCreateArgs} args - Arguments to create a Results.
     * @example
     * // Create one Results
     * const Results = await prisma.results.create({
     *   data: {
     *     // ... data to create a Results
     *   }
     * })
     * 
     */
    create<T extends resultsCreateArgs>(args: SelectSubset<T, resultsCreateArgs<ExtArgs>>): Prisma__resultsClient<$Result.GetResult<Prisma.$resultsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Results.
     * @param {resultsCreateManyArgs} args - Arguments to create many Results.
     * @example
     * // Create many Results
     * const results = await prisma.results.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends resultsCreateManyArgs>(args?: SelectSubset<T, resultsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Results and returns the data saved in the database.
     * @param {resultsCreateManyAndReturnArgs} args - Arguments to create many Results.
     * @example
     * // Create many Results
     * const results = await prisma.results.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Results and only return the `id`
     * const resultsWithIdOnly = await prisma.results.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends resultsCreateManyAndReturnArgs>(args?: SelectSubset<T, resultsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$resultsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Results.
     * @param {resultsDeleteArgs} args - Arguments to delete one Results.
     * @example
     * // Delete one Results
     * const Results = await prisma.results.delete({
     *   where: {
     *     // ... filter to delete one Results
     *   }
     * })
     * 
     */
    delete<T extends resultsDeleteArgs>(args: SelectSubset<T, resultsDeleteArgs<ExtArgs>>): Prisma__resultsClient<$Result.GetResult<Prisma.$resultsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Results.
     * @param {resultsUpdateArgs} args - Arguments to update one Results.
     * @example
     * // Update one Results
     * const results = await prisma.results.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends resultsUpdateArgs>(args: SelectSubset<T, resultsUpdateArgs<ExtArgs>>): Prisma__resultsClient<$Result.GetResult<Prisma.$resultsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Results.
     * @param {resultsDeleteManyArgs} args - Arguments to filter Results to delete.
     * @example
     * // Delete a few Results
     * const { count } = await prisma.results.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends resultsDeleteManyArgs>(args?: SelectSubset<T, resultsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Results.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {resultsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Results
     * const results = await prisma.results.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends resultsUpdateManyArgs>(args: SelectSubset<T, resultsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Results and returns the data updated in the database.
     * @param {resultsUpdateManyAndReturnArgs} args - Arguments to update many Results.
     * @example
     * // Update many Results
     * const results = await prisma.results.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Results and only return the `id`
     * const resultsWithIdOnly = await prisma.results.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends resultsUpdateManyAndReturnArgs>(args: SelectSubset<T, resultsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$resultsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Results.
     * @param {resultsUpsertArgs} args - Arguments to update or create a Results.
     * @example
     * // Update or create a Results
     * const results = await prisma.results.upsert({
     *   create: {
     *     // ... data to create a Results
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Results we want to update
     *   }
     * })
     */
    upsert<T extends resultsUpsertArgs>(args: SelectSubset<T, resultsUpsertArgs<ExtArgs>>): Prisma__resultsClient<$Result.GetResult<Prisma.$resultsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Results.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {resultsCountArgs} args - Arguments to filter Results to count.
     * @example
     * // Count the number of Results
     * const count = await prisma.results.count({
     *   where: {
     *     // ... the filter for the Results we want to count
     *   }
     * })
    **/
    count<T extends resultsCountArgs>(
      args?: Subset<T, resultsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ResultsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Results.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResultsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ResultsAggregateArgs>(args: Subset<T, ResultsAggregateArgs>): Prisma.PrismaPromise<GetResultsAggregateType<T>>

    /**
     * Group by Results.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {resultsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends resultsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: resultsGroupByArgs['orderBy'] }
        : { orderBy?: resultsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, resultsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetResultsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the results model
   */
  readonly fields: resultsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for results.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__resultsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    query<T extends queriesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, queriesDefaultArgs<ExtArgs>>): Prisma__queriesClient<$Result.GetResult<Prisma.$queriesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the results model
   */
  interface resultsFieldRefs {
    readonly id: FieldRef<"results", 'Int'>
    readonly query_id: FieldRef<"results", 'Int'>
    readonly result_type: FieldRef<"results", 'String'>
    readonly content: FieldRef<"results", 'Json'>
    readonly created_at: FieldRef<"results", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * results findUnique
   */
  export type resultsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the results
     */
    select?: resultsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the results
     */
    omit?: resultsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: resultsInclude<ExtArgs> | null
    /**
     * Filter, which results to fetch.
     */
    where: resultsWhereUniqueInput
  }

  /**
   * results findUniqueOrThrow
   */
  export type resultsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the results
     */
    select?: resultsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the results
     */
    omit?: resultsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: resultsInclude<ExtArgs> | null
    /**
     * Filter, which results to fetch.
     */
    where: resultsWhereUniqueInput
  }

  /**
   * results findFirst
   */
  export type resultsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the results
     */
    select?: resultsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the results
     */
    omit?: resultsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: resultsInclude<ExtArgs> | null
    /**
     * Filter, which results to fetch.
     */
    where?: resultsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of results to fetch.
     */
    orderBy?: resultsOrderByWithRelationInput | resultsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for results.
     */
    cursor?: resultsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` results from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` results.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of results.
     */
    distinct?: ResultsScalarFieldEnum | ResultsScalarFieldEnum[]
  }

  /**
   * results findFirstOrThrow
   */
  export type resultsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the results
     */
    select?: resultsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the results
     */
    omit?: resultsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: resultsInclude<ExtArgs> | null
    /**
     * Filter, which results to fetch.
     */
    where?: resultsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of results to fetch.
     */
    orderBy?: resultsOrderByWithRelationInput | resultsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for results.
     */
    cursor?: resultsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` results from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` results.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of results.
     */
    distinct?: ResultsScalarFieldEnum | ResultsScalarFieldEnum[]
  }

  /**
   * results findMany
   */
  export type resultsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the results
     */
    select?: resultsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the results
     */
    omit?: resultsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: resultsInclude<ExtArgs> | null
    /**
     * Filter, which results to fetch.
     */
    where?: resultsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of results to fetch.
     */
    orderBy?: resultsOrderByWithRelationInput | resultsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing results.
     */
    cursor?: resultsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` results from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` results.
     */
    skip?: number
    distinct?: ResultsScalarFieldEnum | ResultsScalarFieldEnum[]
  }

  /**
   * results create
   */
  export type resultsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the results
     */
    select?: resultsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the results
     */
    omit?: resultsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: resultsInclude<ExtArgs> | null
    /**
     * The data needed to create a results.
     */
    data: XOR<resultsCreateInput, resultsUncheckedCreateInput>
  }

  /**
   * results createMany
   */
  export type resultsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many results.
     */
    data: resultsCreateManyInput | resultsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * results createManyAndReturn
   */
  export type resultsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the results
     */
    select?: resultsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the results
     */
    omit?: resultsOmit<ExtArgs> | null
    /**
     * The data used to create many results.
     */
    data: resultsCreateManyInput | resultsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: resultsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * results update
   */
  export type resultsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the results
     */
    select?: resultsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the results
     */
    omit?: resultsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: resultsInclude<ExtArgs> | null
    /**
     * The data needed to update a results.
     */
    data: XOR<resultsUpdateInput, resultsUncheckedUpdateInput>
    /**
     * Choose, which results to update.
     */
    where: resultsWhereUniqueInput
  }

  /**
   * results updateMany
   */
  export type resultsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update results.
     */
    data: XOR<resultsUpdateManyMutationInput, resultsUncheckedUpdateManyInput>
    /**
     * Filter which results to update
     */
    where?: resultsWhereInput
    /**
     * Limit how many results to update.
     */
    limit?: number
  }

  /**
   * results updateManyAndReturn
   */
  export type resultsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the results
     */
    select?: resultsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the results
     */
    omit?: resultsOmit<ExtArgs> | null
    /**
     * The data used to update results.
     */
    data: XOR<resultsUpdateManyMutationInput, resultsUncheckedUpdateManyInput>
    /**
     * Filter which results to update
     */
    where?: resultsWhereInput
    /**
     * Limit how many results to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: resultsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * results upsert
   */
  export type resultsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the results
     */
    select?: resultsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the results
     */
    omit?: resultsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: resultsInclude<ExtArgs> | null
    /**
     * The filter to search for the results to update in case it exists.
     */
    where: resultsWhereUniqueInput
    /**
     * In case the results found by the `where` argument doesn't exist, create a new results with this data.
     */
    create: XOR<resultsCreateInput, resultsUncheckedCreateInput>
    /**
     * In case the results was found with the provided `where` argument, update it with this data.
     */
    update: XOR<resultsUpdateInput, resultsUncheckedUpdateInput>
  }

  /**
   * results delete
   */
  export type resultsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the results
     */
    select?: resultsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the results
     */
    omit?: resultsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: resultsInclude<ExtArgs> | null
    /**
     * Filter which results to delete.
     */
    where: resultsWhereUniqueInput
  }

  /**
   * results deleteMany
   */
  export type resultsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which results to delete
     */
    where?: resultsWhereInput
    /**
     * Limit how many results to delete.
     */
    limit?: number
  }

  /**
   * results without action
   */
  export type resultsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the results
     */
    select?: resultsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the results
     */
    omit?: resultsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: resultsInclude<ExtArgs> | null
  }


  /**
   * Model history
   */

  export type AggregateHistory = {
    _count: HistoryCountAggregateOutputType | null
    _avg: HistoryAvgAggregateOutputType | null
    _sum: HistorySumAggregateOutputType | null
    _min: HistoryMinAggregateOutputType | null
    _max: HistoryMaxAggregateOutputType | null
  }

  export type HistoryAvgAggregateOutputType = {
    id: number | null
    user_id: number | null
    query_id: number | null
    execution_time: number | null
  }

  export type HistorySumAggregateOutputType = {
    id: number | null
    user_id: number | null
    query_id: number | null
    execution_time: number | null
  }

  export type HistoryMinAggregateOutputType = {
    id: number | null
    user_id: number | null
    query_id: number | null
    success: boolean | null
    execution_time: number | null
    created_at: Date | null
  }

  export type HistoryMaxAggregateOutputType = {
    id: number | null
    user_id: number | null
    query_id: number | null
    success: boolean | null
    execution_time: number | null
    created_at: Date | null
  }

  export type HistoryCountAggregateOutputType = {
    id: number
    user_id: number
    query_id: number
    success: number
    execution_time: number
    created_at: number
    _all: number
  }


  export type HistoryAvgAggregateInputType = {
    id?: true
    user_id?: true
    query_id?: true
    execution_time?: true
  }

  export type HistorySumAggregateInputType = {
    id?: true
    user_id?: true
    query_id?: true
    execution_time?: true
  }

  export type HistoryMinAggregateInputType = {
    id?: true
    user_id?: true
    query_id?: true
    success?: true
    execution_time?: true
    created_at?: true
  }

  export type HistoryMaxAggregateInputType = {
    id?: true
    user_id?: true
    query_id?: true
    success?: true
    execution_time?: true
    created_at?: true
  }

  export type HistoryCountAggregateInputType = {
    id?: true
    user_id?: true
    query_id?: true
    success?: true
    execution_time?: true
    created_at?: true
    _all?: true
  }

  export type HistoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which history to aggregate.
     */
    where?: historyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of histories to fetch.
     */
    orderBy?: historyOrderByWithRelationInput | historyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: historyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` histories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` histories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned histories
    **/
    _count?: true | HistoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: HistoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: HistorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HistoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HistoryMaxAggregateInputType
  }

  export type GetHistoryAggregateType<T extends HistoryAggregateArgs> = {
        [P in keyof T & keyof AggregateHistory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHistory[P]>
      : GetScalarType<T[P], AggregateHistory[P]>
  }




  export type historyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: historyWhereInput
    orderBy?: historyOrderByWithAggregationInput | historyOrderByWithAggregationInput[]
    by: HistoryScalarFieldEnum[] | HistoryScalarFieldEnum
    having?: historyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HistoryCountAggregateInputType | true
    _avg?: HistoryAvgAggregateInputType
    _sum?: HistorySumAggregateInputType
    _min?: HistoryMinAggregateInputType
    _max?: HistoryMaxAggregateInputType
  }

  export type HistoryGroupByOutputType = {
    id: number
    user_id: number
    query_id: number | null
    success: boolean | null
    execution_time: number | null
    created_at: Date
    _count: HistoryCountAggregateOutputType | null
    _avg: HistoryAvgAggregateOutputType | null
    _sum: HistorySumAggregateOutputType | null
    _min: HistoryMinAggregateOutputType | null
    _max: HistoryMaxAggregateOutputType | null
  }

  type GetHistoryGroupByPayload<T extends historyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<HistoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HistoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HistoryGroupByOutputType[P]>
            : GetScalarType<T[P], HistoryGroupByOutputType[P]>
        }
      >
    >


  export type historySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    query_id?: boolean
    success?: boolean
    execution_time?: boolean
    created_at?: boolean
    user?: boolean | usersDefaultArgs<ExtArgs>
    query?: boolean | history$queryArgs<ExtArgs>
  }, ExtArgs["result"]["history"]>

  export type historySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    query_id?: boolean
    success?: boolean
    execution_time?: boolean
    created_at?: boolean
    user?: boolean | usersDefaultArgs<ExtArgs>
    query?: boolean | history$queryArgs<ExtArgs>
  }, ExtArgs["result"]["history"]>

  export type historySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    query_id?: boolean
    success?: boolean
    execution_time?: boolean
    created_at?: boolean
    user?: boolean | usersDefaultArgs<ExtArgs>
    query?: boolean | history$queryArgs<ExtArgs>
  }, ExtArgs["result"]["history"]>

  export type historySelectScalar = {
    id?: boolean
    user_id?: boolean
    query_id?: boolean
    success?: boolean
    execution_time?: boolean
    created_at?: boolean
  }

  export type historyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "user_id" | "query_id" | "success" | "execution_time" | "created_at", ExtArgs["result"]["history"]>
  export type historyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | usersDefaultArgs<ExtArgs>
    query?: boolean | history$queryArgs<ExtArgs>
  }
  export type historyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | usersDefaultArgs<ExtArgs>
    query?: boolean | history$queryArgs<ExtArgs>
  }
  export type historyIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | usersDefaultArgs<ExtArgs>
    query?: boolean | history$queryArgs<ExtArgs>
  }

  export type $historyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "history"
    objects: {
      user: Prisma.$usersPayload<ExtArgs>
      query: Prisma.$queriesPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      user_id: number
      query_id: number | null
      success: boolean | null
      execution_time: number | null
      created_at: Date
    }, ExtArgs["result"]["history"]>
    composites: {}
  }

  type historyGetPayload<S extends boolean | null | undefined | historyDefaultArgs> = $Result.GetResult<Prisma.$historyPayload, S>

  type historyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<historyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: HistoryCountAggregateInputType | true
    }

  export interface historyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['history'], meta: { name: 'history' } }
    /**
     * Find zero or one History that matches the filter.
     * @param {historyFindUniqueArgs} args - Arguments to find a History
     * @example
     * // Get one History
     * const history = await prisma.history.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends historyFindUniqueArgs>(args: SelectSubset<T, historyFindUniqueArgs<ExtArgs>>): Prisma__historyClient<$Result.GetResult<Prisma.$historyPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one History that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {historyFindUniqueOrThrowArgs} args - Arguments to find a History
     * @example
     * // Get one History
     * const history = await prisma.history.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends historyFindUniqueOrThrowArgs>(args: SelectSubset<T, historyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__historyClient<$Result.GetResult<Prisma.$historyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first History that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {historyFindFirstArgs} args - Arguments to find a History
     * @example
     * // Get one History
     * const history = await prisma.history.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends historyFindFirstArgs>(args?: SelectSubset<T, historyFindFirstArgs<ExtArgs>>): Prisma__historyClient<$Result.GetResult<Prisma.$historyPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first History that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {historyFindFirstOrThrowArgs} args - Arguments to find a History
     * @example
     * // Get one History
     * const history = await prisma.history.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends historyFindFirstOrThrowArgs>(args?: SelectSubset<T, historyFindFirstOrThrowArgs<ExtArgs>>): Prisma__historyClient<$Result.GetResult<Prisma.$historyPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Histories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {historyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Histories
     * const histories = await prisma.history.findMany()
     * 
     * // Get first 10 Histories
     * const histories = await prisma.history.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const historyWithIdOnly = await prisma.history.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends historyFindManyArgs>(args?: SelectSubset<T, historyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$historyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a History.
     * @param {historyCreateArgs} args - Arguments to create a History.
     * @example
     * // Create one History
     * const History = await prisma.history.create({
     *   data: {
     *     // ... data to create a History
     *   }
     * })
     * 
     */
    create<T extends historyCreateArgs>(args: SelectSubset<T, historyCreateArgs<ExtArgs>>): Prisma__historyClient<$Result.GetResult<Prisma.$historyPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Histories.
     * @param {historyCreateManyArgs} args - Arguments to create many Histories.
     * @example
     * // Create many Histories
     * const history = await prisma.history.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends historyCreateManyArgs>(args?: SelectSubset<T, historyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Histories and returns the data saved in the database.
     * @param {historyCreateManyAndReturnArgs} args - Arguments to create many Histories.
     * @example
     * // Create many Histories
     * const history = await prisma.history.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Histories and only return the `id`
     * const historyWithIdOnly = await prisma.history.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends historyCreateManyAndReturnArgs>(args?: SelectSubset<T, historyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$historyPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a History.
     * @param {historyDeleteArgs} args - Arguments to delete one History.
     * @example
     * // Delete one History
     * const History = await prisma.history.delete({
     *   where: {
     *     // ... filter to delete one History
     *   }
     * })
     * 
     */
    delete<T extends historyDeleteArgs>(args: SelectSubset<T, historyDeleteArgs<ExtArgs>>): Prisma__historyClient<$Result.GetResult<Prisma.$historyPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one History.
     * @param {historyUpdateArgs} args - Arguments to update one History.
     * @example
     * // Update one History
     * const history = await prisma.history.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends historyUpdateArgs>(args: SelectSubset<T, historyUpdateArgs<ExtArgs>>): Prisma__historyClient<$Result.GetResult<Prisma.$historyPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Histories.
     * @param {historyDeleteManyArgs} args - Arguments to filter Histories to delete.
     * @example
     * // Delete a few Histories
     * const { count } = await prisma.history.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends historyDeleteManyArgs>(args?: SelectSubset<T, historyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Histories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {historyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Histories
     * const history = await prisma.history.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends historyUpdateManyArgs>(args: SelectSubset<T, historyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Histories and returns the data updated in the database.
     * @param {historyUpdateManyAndReturnArgs} args - Arguments to update many Histories.
     * @example
     * // Update many Histories
     * const history = await prisma.history.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Histories and only return the `id`
     * const historyWithIdOnly = await prisma.history.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends historyUpdateManyAndReturnArgs>(args: SelectSubset<T, historyUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$historyPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one History.
     * @param {historyUpsertArgs} args - Arguments to update or create a History.
     * @example
     * // Update or create a History
     * const history = await prisma.history.upsert({
     *   create: {
     *     // ... data to create a History
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the History we want to update
     *   }
     * })
     */
    upsert<T extends historyUpsertArgs>(args: SelectSubset<T, historyUpsertArgs<ExtArgs>>): Prisma__historyClient<$Result.GetResult<Prisma.$historyPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Histories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {historyCountArgs} args - Arguments to filter Histories to count.
     * @example
     * // Count the number of Histories
     * const count = await prisma.history.count({
     *   where: {
     *     // ... the filter for the Histories we want to count
     *   }
     * })
    **/
    count<T extends historyCountArgs>(
      args?: Subset<T, historyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HistoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a History.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HistoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HistoryAggregateArgs>(args: Subset<T, HistoryAggregateArgs>): Prisma.PrismaPromise<GetHistoryAggregateType<T>>

    /**
     * Group by History.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {historyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends historyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: historyGroupByArgs['orderBy'] }
        : { orderBy?: historyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, historyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHistoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the history model
   */
  readonly fields: historyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for history.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__historyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    query<T extends history$queryArgs<ExtArgs> = {}>(args?: Subset<T, history$queryArgs<ExtArgs>>): Prisma__queriesClient<$Result.GetResult<Prisma.$queriesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the history model
   */
  interface historyFieldRefs {
    readonly id: FieldRef<"history", 'Int'>
    readonly user_id: FieldRef<"history", 'Int'>
    readonly query_id: FieldRef<"history", 'Int'>
    readonly success: FieldRef<"history", 'Boolean'>
    readonly execution_time: FieldRef<"history", 'Float'>
    readonly created_at: FieldRef<"history", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * history findUnique
   */
  export type historyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the history
     */
    select?: historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the history
     */
    omit?: historyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: historyInclude<ExtArgs> | null
    /**
     * Filter, which history to fetch.
     */
    where: historyWhereUniqueInput
  }

  /**
   * history findUniqueOrThrow
   */
  export type historyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the history
     */
    select?: historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the history
     */
    omit?: historyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: historyInclude<ExtArgs> | null
    /**
     * Filter, which history to fetch.
     */
    where: historyWhereUniqueInput
  }

  /**
   * history findFirst
   */
  export type historyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the history
     */
    select?: historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the history
     */
    omit?: historyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: historyInclude<ExtArgs> | null
    /**
     * Filter, which history to fetch.
     */
    where?: historyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of histories to fetch.
     */
    orderBy?: historyOrderByWithRelationInput | historyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for histories.
     */
    cursor?: historyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` histories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` histories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of histories.
     */
    distinct?: HistoryScalarFieldEnum | HistoryScalarFieldEnum[]
  }

  /**
   * history findFirstOrThrow
   */
  export type historyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the history
     */
    select?: historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the history
     */
    omit?: historyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: historyInclude<ExtArgs> | null
    /**
     * Filter, which history to fetch.
     */
    where?: historyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of histories to fetch.
     */
    orderBy?: historyOrderByWithRelationInput | historyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for histories.
     */
    cursor?: historyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` histories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` histories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of histories.
     */
    distinct?: HistoryScalarFieldEnum | HistoryScalarFieldEnum[]
  }

  /**
   * history findMany
   */
  export type historyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the history
     */
    select?: historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the history
     */
    omit?: historyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: historyInclude<ExtArgs> | null
    /**
     * Filter, which histories to fetch.
     */
    where?: historyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of histories to fetch.
     */
    orderBy?: historyOrderByWithRelationInput | historyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing histories.
     */
    cursor?: historyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` histories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` histories.
     */
    skip?: number
    distinct?: HistoryScalarFieldEnum | HistoryScalarFieldEnum[]
  }

  /**
   * history create
   */
  export type historyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the history
     */
    select?: historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the history
     */
    omit?: historyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: historyInclude<ExtArgs> | null
    /**
     * The data needed to create a history.
     */
    data: XOR<historyCreateInput, historyUncheckedCreateInput>
  }

  /**
   * history createMany
   */
  export type historyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many histories.
     */
    data: historyCreateManyInput | historyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * history createManyAndReturn
   */
  export type historyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the history
     */
    select?: historySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the history
     */
    omit?: historyOmit<ExtArgs> | null
    /**
     * The data used to create many histories.
     */
    data: historyCreateManyInput | historyCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: historyIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * history update
   */
  export type historyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the history
     */
    select?: historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the history
     */
    omit?: historyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: historyInclude<ExtArgs> | null
    /**
     * The data needed to update a history.
     */
    data: XOR<historyUpdateInput, historyUncheckedUpdateInput>
    /**
     * Choose, which history to update.
     */
    where: historyWhereUniqueInput
  }

  /**
   * history updateMany
   */
  export type historyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update histories.
     */
    data: XOR<historyUpdateManyMutationInput, historyUncheckedUpdateManyInput>
    /**
     * Filter which histories to update
     */
    where?: historyWhereInput
    /**
     * Limit how many histories to update.
     */
    limit?: number
  }

  /**
   * history updateManyAndReturn
   */
  export type historyUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the history
     */
    select?: historySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the history
     */
    omit?: historyOmit<ExtArgs> | null
    /**
     * The data used to update histories.
     */
    data: XOR<historyUpdateManyMutationInput, historyUncheckedUpdateManyInput>
    /**
     * Filter which histories to update
     */
    where?: historyWhereInput
    /**
     * Limit how many histories to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: historyIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * history upsert
   */
  export type historyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the history
     */
    select?: historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the history
     */
    omit?: historyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: historyInclude<ExtArgs> | null
    /**
     * The filter to search for the history to update in case it exists.
     */
    where: historyWhereUniqueInput
    /**
     * In case the history found by the `where` argument doesn't exist, create a new history with this data.
     */
    create: XOR<historyCreateInput, historyUncheckedCreateInput>
    /**
     * In case the history was found with the provided `where` argument, update it with this data.
     */
    update: XOR<historyUpdateInput, historyUncheckedUpdateInput>
  }

  /**
   * history delete
   */
  export type historyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the history
     */
    select?: historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the history
     */
    omit?: historyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: historyInclude<ExtArgs> | null
    /**
     * Filter which history to delete.
     */
    where: historyWhereUniqueInput
  }

  /**
   * history deleteMany
   */
  export type historyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which histories to delete
     */
    where?: historyWhereInput
    /**
     * Limit how many histories to delete.
     */
    limit?: number
  }

  /**
   * history.query
   */
  export type history$queryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the queries
     */
    select?: queriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the queries
     */
    omit?: queriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: queriesInclude<ExtArgs> | null
    where?: queriesWhereInput
  }

  /**
   * history without action
   */
  export type historyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the history
     */
    select?: historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the history
     */
    omit?: historyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: historyInclude<ExtArgs> | null
  }


  /**
   * Model exports
   */

  export type AggregateExports = {
    _count: ExportsCountAggregateOutputType | null
    _avg: ExportsAvgAggregateOutputType | null
    _sum: ExportsSumAggregateOutputType | null
    _min: ExportsMinAggregateOutputType | null
    _max: ExportsMaxAggregateOutputType | null
  }

  export type ExportsAvgAggregateOutputType = {
    id: number | null
    user_id: number | null
  }

  export type ExportsSumAggregateOutputType = {
    id: number | null
    user_id: number | null
  }

  export type ExportsMinAggregateOutputType = {
    id: number | null
    user_id: number | null
    file_type: string | null
    file_path: string | null
    created_at: Date | null
  }

  export type ExportsMaxAggregateOutputType = {
    id: number | null
    user_id: number | null
    file_type: string | null
    file_path: string | null
    created_at: Date | null
  }

  export type ExportsCountAggregateOutputType = {
    id: number
    user_id: number
    file_type: number
    file_path: number
    created_at: number
    _all: number
  }


  export type ExportsAvgAggregateInputType = {
    id?: true
    user_id?: true
  }

  export type ExportsSumAggregateInputType = {
    id?: true
    user_id?: true
  }

  export type ExportsMinAggregateInputType = {
    id?: true
    user_id?: true
    file_type?: true
    file_path?: true
    created_at?: true
  }

  export type ExportsMaxAggregateInputType = {
    id?: true
    user_id?: true
    file_type?: true
    file_path?: true
    created_at?: true
  }

  export type ExportsCountAggregateInputType = {
    id?: true
    user_id?: true
    file_type?: true
    file_path?: true
    created_at?: true
    _all?: true
  }

  export type ExportsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which exports to aggregate.
     */
    where?: exportsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of exports to fetch.
     */
    orderBy?: exportsOrderByWithRelationInput | exportsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: exportsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` exports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` exports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned exports
    **/
    _count?: true | ExportsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ExportsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ExportsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ExportsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ExportsMaxAggregateInputType
  }

  export type GetExportsAggregateType<T extends ExportsAggregateArgs> = {
        [P in keyof T & keyof AggregateExports]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExports[P]>
      : GetScalarType<T[P], AggregateExports[P]>
  }




  export type exportsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: exportsWhereInput
    orderBy?: exportsOrderByWithAggregationInput | exportsOrderByWithAggregationInput[]
    by: ExportsScalarFieldEnum[] | ExportsScalarFieldEnum
    having?: exportsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ExportsCountAggregateInputType | true
    _avg?: ExportsAvgAggregateInputType
    _sum?: ExportsSumAggregateInputType
    _min?: ExportsMinAggregateInputType
    _max?: ExportsMaxAggregateInputType
  }

  export type ExportsGroupByOutputType = {
    id: number
    user_id: number
    file_type: string | null
    file_path: string | null
    created_at: Date
    _count: ExportsCountAggregateOutputType | null
    _avg: ExportsAvgAggregateOutputType | null
    _sum: ExportsSumAggregateOutputType | null
    _min: ExportsMinAggregateOutputType | null
    _max: ExportsMaxAggregateOutputType | null
  }

  type GetExportsGroupByPayload<T extends exportsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ExportsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ExportsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ExportsGroupByOutputType[P]>
            : GetScalarType<T[P], ExportsGroupByOutputType[P]>
        }
      >
    >


  export type exportsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    file_type?: boolean
    file_path?: boolean
    created_at?: boolean
    user?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["exports"]>

  export type exportsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    file_type?: boolean
    file_path?: boolean
    created_at?: boolean
    user?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["exports"]>

  export type exportsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    file_type?: boolean
    file_path?: boolean
    created_at?: boolean
    user?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["exports"]>

  export type exportsSelectScalar = {
    id?: boolean
    user_id?: boolean
    file_type?: boolean
    file_path?: boolean
    created_at?: boolean
  }

  export type exportsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "user_id" | "file_type" | "file_path" | "created_at", ExtArgs["result"]["exports"]>
  export type exportsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type exportsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type exportsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | usersDefaultArgs<ExtArgs>
  }

  export type $exportsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "exports"
    objects: {
      user: Prisma.$usersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      user_id: number
      file_type: string | null
      file_path: string | null
      created_at: Date
    }, ExtArgs["result"]["exports"]>
    composites: {}
  }

  type exportsGetPayload<S extends boolean | null | undefined | exportsDefaultArgs> = $Result.GetResult<Prisma.$exportsPayload, S>

  type exportsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<exportsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ExportsCountAggregateInputType | true
    }

  export interface exportsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['exports'], meta: { name: 'exports' } }
    /**
     * Find zero or one Exports that matches the filter.
     * @param {exportsFindUniqueArgs} args - Arguments to find a Exports
     * @example
     * // Get one Exports
     * const exports = await prisma.exports.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends exportsFindUniqueArgs>(args: SelectSubset<T, exportsFindUniqueArgs<ExtArgs>>): Prisma__exportsClient<$Result.GetResult<Prisma.$exportsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Exports that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {exportsFindUniqueOrThrowArgs} args - Arguments to find a Exports
     * @example
     * // Get one Exports
     * const exports = await prisma.exports.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends exportsFindUniqueOrThrowArgs>(args: SelectSubset<T, exportsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__exportsClient<$Result.GetResult<Prisma.$exportsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Exports that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {exportsFindFirstArgs} args - Arguments to find a Exports
     * @example
     * // Get one Exports
     * const exports = await prisma.exports.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends exportsFindFirstArgs>(args?: SelectSubset<T, exportsFindFirstArgs<ExtArgs>>): Prisma__exportsClient<$Result.GetResult<Prisma.$exportsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Exports that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {exportsFindFirstOrThrowArgs} args - Arguments to find a Exports
     * @example
     * // Get one Exports
     * const exports = await prisma.exports.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends exportsFindFirstOrThrowArgs>(args?: SelectSubset<T, exportsFindFirstOrThrowArgs<ExtArgs>>): Prisma__exportsClient<$Result.GetResult<Prisma.$exportsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Exports that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {exportsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Exports
     * const exports = await prisma.exports.findMany()
     * 
     * // Get first 10 Exports
     * const exports = await prisma.exports.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const exportsWithIdOnly = await prisma.exports.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends exportsFindManyArgs>(args?: SelectSubset<T, exportsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$exportsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Exports.
     * @param {exportsCreateArgs} args - Arguments to create a Exports.
     * @example
     * // Create one Exports
     * const Exports = await prisma.exports.create({
     *   data: {
     *     // ... data to create a Exports
     *   }
     * })
     * 
     */
    create<T extends exportsCreateArgs>(args: SelectSubset<T, exportsCreateArgs<ExtArgs>>): Prisma__exportsClient<$Result.GetResult<Prisma.$exportsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Exports.
     * @param {exportsCreateManyArgs} args - Arguments to create many Exports.
     * @example
     * // Create many Exports
     * const exports = await prisma.exports.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends exportsCreateManyArgs>(args?: SelectSubset<T, exportsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Exports and returns the data saved in the database.
     * @param {exportsCreateManyAndReturnArgs} args - Arguments to create many Exports.
     * @example
     * // Create many Exports
     * const exports = await prisma.exports.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Exports and only return the `id`
     * const exportsWithIdOnly = await prisma.exports.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends exportsCreateManyAndReturnArgs>(args?: SelectSubset<T, exportsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$exportsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Exports.
     * @param {exportsDeleteArgs} args - Arguments to delete one Exports.
     * @example
     * // Delete one Exports
     * const Exports = await prisma.exports.delete({
     *   where: {
     *     // ... filter to delete one Exports
     *   }
     * })
     * 
     */
    delete<T extends exportsDeleteArgs>(args: SelectSubset<T, exportsDeleteArgs<ExtArgs>>): Prisma__exportsClient<$Result.GetResult<Prisma.$exportsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Exports.
     * @param {exportsUpdateArgs} args - Arguments to update one Exports.
     * @example
     * // Update one Exports
     * const exports = await prisma.exports.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends exportsUpdateArgs>(args: SelectSubset<T, exportsUpdateArgs<ExtArgs>>): Prisma__exportsClient<$Result.GetResult<Prisma.$exportsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Exports.
     * @param {exportsDeleteManyArgs} args - Arguments to filter Exports to delete.
     * @example
     * // Delete a few Exports
     * const { count } = await prisma.exports.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends exportsDeleteManyArgs>(args?: SelectSubset<T, exportsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Exports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {exportsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Exports
     * const exports = await prisma.exports.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends exportsUpdateManyArgs>(args: SelectSubset<T, exportsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Exports and returns the data updated in the database.
     * @param {exportsUpdateManyAndReturnArgs} args - Arguments to update many Exports.
     * @example
     * // Update many Exports
     * const exports = await prisma.exports.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Exports and only return the `id`
     * const exportsWithIdOnly = await prisma.exports.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends exportsUpdateManyAndReturnArgs>(args: SelectSubset<T, exportsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$exportsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Exports.
     * @param {exportsUpsertArgs} args - Arguments to update or create a Exports.
     * @example
     * // Update or create a Exports
     * const exports = await prisma.exports.upsert({
     *   create: {
     *     // ... data to create a Exports
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Exports we want to update
     *   }
     * })
     */
    upsert<T extends exportsUpsertArgs>(args: SelectSubset<T, exportsUpsertArgs<ExtArgs>>): Prisma__exportsClient<$Result.GetResult<Prisma.$exportsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Exports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {exportsCountArgs} args - Arguments to filter Exports to count.
     * @example
     * // Count the number of Exports
     * const count = await prisma.exports.count({
     *   where: {
     *     // ... the filter for the Exports we want to count
     *   }
     * })
    **/
    count<T extends exportsCountArgs>(
      args?: Subset<T, exportsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ExportsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Exports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExportsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ExportsAggregateArgs>(args: Subset<T, ExportsAggregateArgs>): Prisma.PrismaPromise<GetExportsAggregateType<T>>

    /**
     * Group by Exports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {exportsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends exportsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: exportsGroupByArgs['orderBy'] }
        : { orderBy?: exportsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, exportsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetExportsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the exports model
   */
  readonly fields: exportsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for exports.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__exportsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the exports model
   */
  interface exportsFieldRefs {
    readonly id: FieldRef<"exports", 'Int'>
    readonly user_id: FieldRef<"exports", 'Int'>
    readonly file_type: FieldRef<"exports", 'String'>
    readonly file_path: FieldRef<"exports", 'String'>
    readonly created_at: FieldRef<"exports", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * exports findUnique
   */
  export type exportsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the exports
     */
    select?: exportsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the exports
     */
    omit?: exportsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: exportsInclude<ExtArgs> | null
    /**
     * Filter, which exports to fetch.
     */
    where: exportsWhereUniqueInput
  }

  /**
   * exports findUniqueOrThrow
   */
  export type exportsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the exports
     */
    select?: exportsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the exports
     */
    omit?: exportsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: exportsInclude<ExtArgs> | null
    /**
     * Filter, which exports to fetch.
     */
    where: exportsWhereUniqueInput
  }

  /**
   * exports findFirst
   */
  export type exportsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the exports
     */
    select?: exportsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the exports
     */
    omit?: exportsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: exportsInclude<ExtArgs> | null
    /**
     * Filter, which exports to fetch.
     */
    where?: exportsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of exports to fetch.
     */
    orderBy?: exportsOrderByWithRelationInput | exportsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for exports.
     */
    cursor?: exportsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` exports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` exports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of exports.
     */
    distinct?: ExportsScalarFieldEnum | ExportsScalarFieldEnum[]
  }

  /**
   * exports findFirstOrThrow
   */
  export type exportsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the exports
     */
    select?: exportsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the exports
     */
    omit?: exportsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: exportsInclude<ExtArgs> | null
    /**
     * Filter, which exports to fetch.
     */
    where?: exportsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of exports to fetch.
     */
    orderBy?: exportsOrderByWithRelationInput | exportsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for exports.
     */
    cursor?: exportsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` exports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` exports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of exports.
     */
    distinct?: ExportsScalarFieldEnum | ExportsScalarFieldEnum[]
  }

  /**
   * exports findMany
   */
  export type exportsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the exports
     */
    select?: exportsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the exports
     */
    omit?: exportsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: exportsInclude<ExtArgs> | null
    /**
     * Filter, which exports to fetch.
     */
    where?: exportsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of exports to fetch.
     */
    orderBy?: exportsOrderByWithRelationInput | exportsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing exports.
     */
    cursor?: exportsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` exports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` exports.
     */
    skip?: number
    distinct?: ExportsScalarFieldEnum | ExportsScalarFieldEnum[]
  }

  /**
   * exports create
   */
  export type exportsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the exports
     */
    select?: exportsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the exports
     */
    omit?: exportsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: exportsInclude<ExtArgs> | null
    /**
     * The data needed to create a exports.
     */
    data: XOR<exportsCreateInput, exportsUncheckedCreateInput>
  }

  /**
   * exports createMany
   */
  export type exportsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many exports.
     */
    data: exportsCreateManyInput | exportsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * exports createManyAndReturn
   */
  export type exportsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the exports
     */
    select?: exportsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the exports
     */
    omit?: exportsOmit<ExtArgs> | null
    /**
     * The data used to create many exports.
     */
    data: exportsCreateManyInput | exportsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: exportsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * exports update
   */
  export type exportsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the exports
     */
    select?: exportsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the exports
     */
    omit?: exportsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: exportsInclude<ExtArgs> | null
    /**
     * The data needed to update a exports.
     */
    data: XOR<exportsUpdateInput, exportsUncheckedUpdateInput>
    /**
     * Choose, which exports to update.
     */
    where: exportsWhereUniqueInput
  }

  /**
   * exports updateMany
   */
  export type exportsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update exports.
     */
    data: XOR<exportsUpdateManyMutationInput, exportsUncheckedUpdateManyInput>
    /**
     * Filter which exports to update
     */
    where?: exportsWhereInput
    /**
     * Limit how many exports to update.
     */
    limit?: number
  }

  /**
   * exports updateManyAndReturn
   */
  export type exportsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the exports
     */
    select?: exportsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the exports
     */
    omit?: exportsOmit<ExtArgs> | null
    /**
     * The data used to update exports.
     */
    data: XOR<exportsUpdateManyMutationInput, exportsUncheckedUpdateManyInput>
    /**
     * Filter which exports to update
     */
    where?: exportsWhereInput
    /**
     * Limit how many exports to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: exportsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * exports upsert
   */
  export type exportsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the exports
     */
    select?: exportsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the exports
     */
    omit?: exportsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: exportsInclude<ExtArgs> | null
    /**
     * The filter to search for the exports to update in case it exists.
     */
    where: exportsWhereUniqueInput
    /**
     * In case the exports found by the `where` argument doesn't exist, create a new exports with this data.
     */
    create: XOR<exportsCreateInput, exportsUncheckedCreateInput>
    /**
     * In case the exports was found with the provided `where` argument, update it with this data.
     */
    update: XOR<exportsUpdateInput, exportsUncheckedUpdateInput>
  }

  /**
   * exports delete
   */
  export type exportsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the exports
     */
    select?: exportsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the exports
     */
    omit?: exportsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: exportsInclude<ExtArgs> | null
    /**
     * Filter which exports to delete.
     */
    where: exportsWhereUniqueInput
  }

  /**
   * exports deleteMany
   */
  export type exportsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which exports to delete
     */
    where?: exportsWhereInput
    /**
     * Limit how many exports to delete.
     */
    limit?: number
  }

  /**
   * exports without action
   */
  export type exportsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the exports
     */
    select?: exportsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the exports
     */
    omit?: exportsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: exportsInclude<ExtArgs> | null
  }


  /**
   * Model suggestions
   */

  export type AggregateSuggestions = {
    _count: SuggestionsCountAggregateOutputType | null
    _avg: SuggestionsAvgAggregateOutputType | null
    _sum: SuggestionsSumAggregateOutputType | null
    _min: SuggestionsMinAggregateOutputType | null
    _max: SuggestionsMaxAggregateOutputType | null
  }

  export type SuggestionsAvgAggregateOutputType = {
    id: number | null
    user_id: number | null
  }

  export type SuggestionsSumAggregateOutputType = {
    id: number | null
    user_id: number | null
  }

  export type SuggestionsMinAggregateOutputType = {
    id: number | null
    user_id: number | null
    content: string | null
    source: string | null
    created_at: Date | null
  }

  export type SuggestionsMaxAggregateOutputType = {
    id: number | null
    user_id: number | null
    content: string | null
    source: string | null
    created_at: Date | null
  }

  export type SuggestionsCountAggregateOutputType = {
    id: number
    user_id: number
    content: number
    source: number
    created_at: number
    _all: number
  }


  export type SuggestionsAvgAggregateInputType = {
    id?: true
    user_id?: true
  }

  export type SuggestionsSumAggregateInputType = {
    id?: true
    user_id?: true
  }

  export type SuggestionsMinAggregateInputType = {
    id?: true
    user_id?: true
    content?: true
    source?: true
    created_at?: true
  }

  export type SuggestionsMaxAggregateInputType = {
    id?: true
    user_id?: true
    content?: true
    source?: true
    created_at?: true
  }

  export type SuggestionsCountAggregateInputType = {
    id?: true
    user_id?: true
    content?: true
    source?: true
    created_at?: true
    _all?: true
  }

  export type SuggestionsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which suggestions to aggregate.
     */
    where?: suggestionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of suggestions to fetch.
     */
    orderBy?: suggestionsOrderByWithRelationInput | suggestionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: suggestionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` suggestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` suggestions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned suggestions
    **/
    _count?: true | SuggestionsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SuggestionsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SuggestionsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SuggestionsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SuggestionsMaxAggregateInputType
  }

  export type GetSuggestionsAggregateType<T extends SuggestionsAggregateArgs> = {
        [P in keyof T & keyof AggregateSuggestions]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSuggestions[P]>
      : GetScalarType<T[P], AggregateSuggestions[P]>
  }




  export type suggestionsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: suggestionsWhereInput
    orderBy?: suggestionsOrderByWithAggregationInput | suggestionsOrderByWithAggregationInput[]
    by: SuggestionsScalarFieldEnum[] | SuggestionsScalarFieldEnum
    having?: suggestionsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SuggestionsCountAggregateInputType | true
    _avg?: SuggestionsAvgAggregateInputType
    _sum?: SuggestionsSumAggregateInputType
    _min?: SuggestionsMinAggregateInputType
    _max?: SuggestionsMaxAggregateInputType
  }

  export type SuggestionsGroupByOutputType = {
    id: number
    user_id: number
    content: string | null
    source: string | null
    created_at: Date
    _count: SuggestionsCountAggregateOutputType | null
    _avg: SuggestionsAvgAggregateOutputType | null
    _sum: SuggestionsSumAggregateOutputType | null
    _min: SuggestionsMinAggregateOutputType | null
    _max: SuggestionsMaxAggregateOutputType | null
  }

  type GetSuggestionsGroupByPayload<T extends suggestionsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SuggestionsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SuggestionsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SuggestionsGroupByOutputType[P]>
            : GetScalarType<T[P], SuggestionsGroupByOutputType[P]>
        }
      >
    >


  export type suggestionsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    content?: boolean
    source?: boolean
    created_at?: boolean
    user?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["suggestions"]>

  export type suggestionsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    content?: boolean
    source?: boolean
    created_at?: boolean
    user?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["suggestions"]>

  export type suggestionsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    content?: boolean
    source?: boolean
    created_at?: boolean
    user?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["suggestions"]>

  export type suggestionsSelectScalar = {
    id?: boolean
    user_id?: boolean
    content?: boolean
    source?: boolean
    created_at?: boolean
  }

  export type suggestionsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "user_id" | "content" | "source" | "created_at", ExtArgs["result"]["suggestions"]>
  export type suggestionsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type suggestionsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type suggestionsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | usersDefaultArgs<ExtArgs>
  }

  export type $suggestionsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "suggestions"
    objects: {
      user: Prisma.$usersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      user_id: number
      content: string | null
      source: string | null
      created_at: Date
    }, ExtArgs["result"]["suggestions"]>
    composites: {}
  }

  type suggestionsGetPayload<S extends boolean | null | undefined | suggestionsDefaultArgs> = $Result.GetResult<Prisma.$suggestionsPayload, S>

  type suggestionsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<suggestionsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SuggestionsCountAggregateInputType | true
    }

  export interface suggestionsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['suggestions'], meta: { name: 'suggestions' } }
    /**
     * Find zero or one Suggestions that matches the filter.
     * @param {suggestionsFindUniqueArgs} args - Arguments to find a Suggestions
     * @example
     * // Get one Suggestions
     * const suggestions = await prisma.suggestions.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends suggestionsFindUniqueArgs>(args: SelectSubset<T, suggestionsFindUniqueArgs<ExtArgs>>): Prisma__suggestionsClient<$Result.GetResult<Prisma.$suggestionsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Suggestions that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {suggestionsFindUniqueOrThrowArgs} args - Arguments to find a Suggestions
     * @example
     * // Get one Suggestions
     * const suggestions = await prisma.suggestions.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends suggestionsFindUniqueOrThrowArgs>(args: SelectSubset<T, suggestionsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__suggestionsClient<$Result.GetResult<Prisma.$suggestionsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Suggestions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {suggestionsFindFirstArgs} args - Arguments to find a Suggestions
     * @example
     * // Get one Suggestions
     * const suggestions = await prisma.suggestions.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends suggestionsFindFirstArgs>(args?: SelectSubset<T, suggestionsFindFirstArgs<ExtArgs>>): Prisma__suggestionsClient<$Result.GetResult<Prisma.$suggestionsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Suggestions that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {suggestionsFindFirstOrThrowArgs} args - Arguments to find a Suggestions
     * @example
     * // Get one Suggestions
     * const suggestions = await prisma.suggestions.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends suggestionsFindFirstOrThrowArgs>(args?: SelectSubset<T, suggestionsFindFirstOrThrowArgs<ExtArgs>>): Prisma__suggestionsClient<$Result.GetResult<Prisma.$suggestionsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Suggestions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {suggestionsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Suggestions
     * const suggestions = await prisma.suggestions.findMany()
     * 
     * // Get first 10 Suggestions
     * const suggestions = await prisma.suggestions.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const suggestionsWithIdOnly = await prisma.suggestions.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends suggestionsFindManyArgs>(args?: SelectSubset<T, suggestionsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$suggestionsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Suggestions.
     * @param {suggestionsCreateArgs} args - Arguments to create a Suggestions.
     * @example
     * // Create one Suggestions
     * const Suggestions = await prisma.suggestions.create({
     *   data: {
     *     // ... data to create a Suggestions
     *   }
     * })
     * 
     */
    create<T extends suggestionsCreateArgs>(args: SelectSubset<T, suggestionsCreateArgs<ExtArgs>>): Prisma__suggestionsClient<$Result.GetResult<Prisma.$suggestionsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Suggestions.
     * @param {suggestionsCreateManyArgs} args - Arguments to create many Suggestions.
     * @example
     * // Create many Suggestions
     * const suggestions = await prisma.suggestions.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends suggestionsCreateManyArgs>(args?: SelectSubset<T, suggestionsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Suggestions and returns the data saved in the database.
     * @param {suggestionsCreateManyAndReturnArgs} args - Arguments to create many Suggestions.
     * @example
     * // Create many Suggestions
     * const suggestions = await prisma.suggestions.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Suggestions and only return the `id`
     * const suggestionsWithIdOnly = await prisma.suggestions.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends suggestionsCreateManyAndReturnArgs>(args?: SelectSubset<T, suggestionsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$suggestionsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Suggestions.
     * @param {suggestionsDeleteArgs} args - Arguments to delete one Suggestions.
     * @example
     * // Delete one Suggestions
     * const Suggestions = await prisma.suggestions.delete({
     *   where: {
     *     // ... filter to delete one Suggestions
     *   }
     * })
     * 
     */
    delete<T extends suggestionsDeleteArgs>(args: SelectSubset<T, suggestionsDeleteArgs<ExtArgs>>): Prisma__suggestionsClient<$Result.GetResult<Prisma.$suggestionsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Suggestions.
     * @param {suggestionsUpdateArgs} args - Arguments to update one Suggestions.
     * @example
     * // Update one Suggestions
     * const suggestions = await prisma.suggestions.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends suggestionsUpdateArgs>(args: SelectSubset<T, suggestionsUpdateArgs<ExtArgs>>): Prisma__suggestionsClient<$Result.GetResult<Prisma.$suggestionsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Suggestions.
     * @param {suggestionsDeleteManyArgs} args - Arguments to filter Suggestions to delete.
     * @example
     * // Delete a few Suggestions
     * const { count } = await prisma.suggestions.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends suggestionsDeleteManyArgs>(args?: SelectSubset<T, suggestionsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Suggestions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {suggestionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Suggestions
     * const suggestions = await prisma.suggestions.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends suggestionsUpdateManyArgs>(args: SelectSubset<T, suggestionsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Suggestions and returns the data updated in the database.
     * @param {suggestionsUpdateManyAndReturnArgs} args - Arguments to update many Suggestions.
     * @example
     * // Update many Suggestions
     * const suggestions = await prisma.suggestions.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Suggestions and only return the `id`
     * const suggestionsWithIdOnly = await prisma.suggestions.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends suggestionsUpdateManyAndReturnArgs>(args: SelectSubset<T, suggestionsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$suggestionsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Suggestions.
     * @param {suggestionsUpsertArgs} args - Arguments to update or create a Suggestions.
     * @example
     * // Update or create a Suggestions
     * const suggestions = await prisma.suggestions.upsert({
     *   create: {
     *     // ... data to create a Suggestions
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Suggestions we want to update
     *   }
     * })
     */
    upsert<T extends suggestionsUpsertArgs>(args: SelectSubset<T, suggestionsUpsertArgs<ExtArgs>>): Prisma__suggestionsClient<$Result.GetResult<Prisma.$suggestionsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Suggestions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {suggestionsCountArgs} args - Arguments to filter Suggestions to count.
     * @example
     * // Count the number of Suggestions
     * const count = await prisma.suggestions.count({
     *   where: {
     *     // ... the filter for the Suggestions we want to count
     *   }
     * })
    **/
    count<T extends suggestionsCountArgs>(
      args?: Subset<T, suggestionsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SuggestionsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Suggestions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SuggestionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SuggestionsAggregateArgs>(args: Subset<T, SuggestionsAggregateArgs>): Prisma.PrismaPromise<GetSuggestionsAggregateType<T>>

    /**
     * Group by Suggestions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {suggestionsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends suggestionsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: suggestionsGroupByArgs['orderBy'] }
        : { orderBy?: suggestionsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, suggestionsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSuggestionsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the suggestions model
   */
  readonly fields: suggestionsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for suggestions.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__suggestionsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the suggestions model
   */
  interface suggestionsFieldRefs {
    readonly id: FieldRef<"suggestions", 'Int'>
    readonly user_id: FieldRef<"suggestions", 'Int'>
    readonly content: FieldRef<"suggestions", 'String'>
    readonly source: FieldRef<"suggestions", 'String'>
    readonly created_at: FieldRef<"suggestions", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * suggestions findUnique
   */
  export type suggestionsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the suggestions
     */
    select?: suggestionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the suggestions
     */
    omit?: suggestionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: suggestionsInclude<ExtArgs> | null
    /**
     * Filter, which suggestions to fetch.
     */
    where: suggestionsWhereUniqueInput
  }

  /**
   * suggestions findUniqueOrThrow
   */
  export type suggestionsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the suggestions
     */
    select?: suggestionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the suggestions
     */
    omit?: suggestionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: suggestionsInclude<ExtArgs> | null
    /**
     * Filter, which suggestions to fetch.
     */
    where: suggestionsWhereUniqueInput
  }

  /**
   * suggestions findFirst
   */
  export type suggestionsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the suggestions
     */
    select?: suggestionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the suggestions
     */
    omit?: suggestionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: suggestionsInclude<ExtArgs> | null
    /**
     * Filter, which suggestions to fetch.
     */
    where?: suggestionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of suggestions to fetch.
     */
    orderBy?: suggestionsOrderByWithRelationInput | suggestionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for suggestions.
     */
    cursor?: suggestionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` suggestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` suggestions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of suggestions.
     */
    distinct?: SuggestionsScalarFieldEnum | SuggestionsScalarFieldEnum[]
  }

  /**
   * suggestions findFirstOrThrow
   */
  export type suggestionsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the suggestions
     */
    select?: suggestionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the suggestions
     */
    omit?: suggestionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: suggestionsInclude<ExtArgs> | null
    /**
     * Filter, which suggestions to fetch.
     */
    where?: suggestionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of suggestions to fetch.
     */
    orderBy?: suggestionsOrderByWithRelationInput | suggestionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for suggestions.
     */
    cursor?: suggestionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` suggestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` suggestions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of suggestions.
     */
    distinct?: SuggestionsScalarFieldEnum | SuggestionsScalarFieldEnum[]
  }

  /**
   * suggestions findMany
   */
  export type suggestionsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the suggestions
     */
    select?: suggestionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the suggestions
     */
    omit?: suggestionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: suggestionsInclude<ExtArgs> | null
    /**
     * Filter, which suggestions to fetch.
     */
    where?: suggestionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of suggestions to fetch.
     */
    orderBy?: suggestionsOrderByWithRelationInput | suggestionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing suggestions.
     */
    cursor?: suggestionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` suggestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` suggestions.
     */
    skip?: number
    distinct?: SuggestionsScalarFieldEnum | SuggestionsScalarFieldEnum[]
  }

  /**
   * suggestions create
   */
  export type suggestionsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the suggestions
     */
    select?: suggestionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the suggestions
     */
    omit?: suggestionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: suggestionsInclude<ExtArgs> | null
    /**
     * The data needed to create a suggestions.
     */
    data: XOR<suggestionsCreateInput, suggestionsUncheckedCreateInput>
  }

  /**
   * suggestions createMany
   */
  export type suggestionsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many suggestions.
     */
    data: suggestionsCreateManyInput | suggestionsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * suggestions createManyAndReturn
   */
  export type suggestionsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the suggestions
     */
    select?: suggestionsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the suggestions
     */
    omit?: suggestionsOmit<ExtArgs> | null
    /**
     * The data used to create many suggestions.
     */
    data: suggestionsCreateManyInput | suggestionsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: suggestionsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * suggestions update
   */
  export type suggestionsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the suggestions
     */
    select?: suggestionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the suggestions
     */
    omit?: suggestionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: suggestionsInclude<ExtArgs> | null
    /**
     * The data needed to update a suggestions.
     */
    data: XOR<suggestionsUpdateInput, suggestionsUncheckedUpdateInput>
    /**
     * Choose, which suggestions to update.
     */
    where: suggestionsWhereUniqueInput
  }

  /**
   * suggestions updateMany
   */
  export type suggestionsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update suggestions.
     */
    data: XOR<suggestionsUpdateManyMutationInput, suggestionsUncheckedUpdateManyInput>
    /**
     * Filter which suggestions to update
     */
    where?: suggestionsWhereInput
    /**
     * Limit how many suggestions to update.
     */
    limit?: number
  }

  /**
   * suggestions updateManyAndReturn
   */
  export type suggestionsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the suggestions
     */
    select?: suggestionsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the suggestions
     */
    omit?: suggestionsOmit<ExtArgs> | null
    /**
     * The data used to update suggestions.
     */
    data: XOR<suggestionsUpdateManyMutationInput, suggestionsUncheckedUpdateManyInput>
    /**
     * Filter which suggestions to update
     */
    where?: suggestionsWhereInput
    /**
     * Limit how many suggestions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: suggestionsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * suggestions upsert
   */
  export type suggestionsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the suggestions
     */
    select?: suggestionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the suggestions
     */
    omit?: suggestionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: suggestionsInclude<ExtArgs> | null
    /**
     * The filter to search for the suggestions to update in case it exists.
     */
    where: suggestionsWhereUniqueInput
    /**
     * In case the suggestions found by the `where` argument doesn't exist, create a new suggestions with this data.
     */
    create: XOR<suggestionsCreateInput, suggestionsUncheckedCreateInput>
    /**
     * In case the suggestions was found with the provided `where` argument, update it with this data.
     */
    update: XOR<suggestionsUpdateInput, suggestionsUncheckedUpdateInput>
  }

  /**
   * suggestions delete
   */
  export type suggestionsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the suggestions
     */
    select?: suggestionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the suggestions
     */
    omit?: suggestionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: suggestionsInclude<ExtArgs> | null
    /**
     * Filter which suggestions to delete.
     */
    where: suggestionsWhereUniqueInput
  }

  /**
   * suggestions deleteMany
   */
  export type suggestionsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which suggestions to delete
     */
    where?: suggestionsWhereInput
    /**
     * Limit how many suggestions to delete.
     */
    limit?: number
  }

  /**
   * suggestions without action
   */
  export type suggestionsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the suggestions
     */
    select?: suggestionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the suggestions
     */
    omit?: suggestionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: suggestionsInclude<ExtArgs> | null
  }


  /**
   * Model access_logs
   */

  export type AggregateAccess_logs = {
    _count: Access_logsCountAggregateOutputType | null
    _avg: Access_logsAvgAggregateOutputType | null
    _sum: Access_logsSumAggregateOutputType | null
    _min: Access_logsMinAggregateOutputType | null
    _max: Access_logsMaxAggregateOutputType | null
  }

  export type Access_logsAvgAggregateOutputType = {
    id: number | null
    user_id: number | null
  }

  export type Access_logsSumAggregateOutputType = {
    id: number | null
    user_id: number | null
  }

  export type Access_logsMinAggregateOutputType = {
    id: number | null
    user_id: number | null
    action: string | null
    ip_address: string | null
    created_at: Date | null
  }

  export type Access_logsMaxAggregateOutputType = {
    id: number | null
    user_id: number | null
    action: string | null
    ip_address: string | null
    created_at: Date | null
  }

  export type Access_logsCountAggregateOutputType = {
    id: number
    user_id: number
    action: number
    ip_address: number
    created_at: number
    _all: number
  }


  export type Access_logsAvgAggregateInputType = {
    id?: true
    user_id?: true
  }

  export type Access_logsSumAggregateInputType = {
    id?: true
    user_id?: true
  }

  export type Access_logsMinAggregateInputType = {
    id?: true
    user_id?: true
    action?: true
    ip_address?: true
    created_at?: true
  }

  export type Access_logsMaxAggregateInputType = {
    id?: true
    user_id?: true
    action?: true
    ip_address?: true
    created_at?: true
  }

  export type Access_logsCountAggregateInputType = {
    id?: true
    user_id?: true
    action?: true
    ip_address?: true
    created_at?: true
    _all?: true
  }

  export type Access_logsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which access_logs to aggregate.
     */
    where?: access_logsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of access_logs to fetch.
     */
    orderBy?: access_logsOrderByWithRelationInput | access_logsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: access_logsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` access_logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` access_logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned access_logs
    **/
    _count?: true | Access_logsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Access_logsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Access_logsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Access_logsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Access_logsMaxAggregateInputType
  }

  export type GetAccess_logsAggregateType<T extends Access_logsAggregateArgs> = {
        [P in keyof T & keyof AggregateAccess_logs]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAccess_logs[P]>
      : GetScalarType<T[P], AggregateAccess_logs[P]>
  }




  export type access_logsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: access_logsWhereInput
    orderBy?: access_logsOrderByWithAggregationInput | access_logsOrderByWithAggregationInput[]
    by: Access_logsScalarFieldEnum[] | Access_logsScalarFieldEnum
    having?: access_logsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Access_logsCountAggregateInputType | true
    _avg?: Access_logsAvgAggregateInputType
    _sum?: Access_logsSumAggregateInputType
    _min?: Access_logsMinAggregateInputType
    _max?: Access_logsMaxAggregateInputType
  }

  export type Access_logsGroupByOutputType = {
    id: number
    user_id: number | null
    action: string | null
    ip_address: string | null
    created_at: Date
    _count: Access_logsCountAggregateOutputType | null
    _avg: Access_logsAvgAggregateOutputType | null
    _sum: Access_logsSumAggregateOutputType | null
    _min: Access_logsMinAggregateOutputType | null
    _max: Access_logsMaxAggregateOutputType | null
  }

  type GetAccess_logsGroupByPayload<T extends access_logsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Access_logsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Access_logsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Access_logsGroupByOutputType[P]>
            : GetScalarType<T[P], Access_logsGroupByOutputType[P]>
        }
      >
    >


  export type access_logsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    action?: boolean
    ip_address?: boolean
    created_at?: boolean
    user?: boolean | access_logs$userArgs<ExtArgs>
  }, ExtArgs["result"]["access_logs"]>

  export type access_logsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    action?: boolean
    ip_address?: boolean
    created_at?: boolean
    user?: boolean | access_logs$userArgs<ExtArgs>
  }, ExtArgs["result"]["access_logs"]>

  export type access_logsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    action?: boolean
    ip_address?: boolean
    created_at?: boolean
    user?: boolean | access_logs$userArgs<ExtArgs>
  }, ExtArgs["result"]["access_logs"]>

  export type access_logsSelectScalar = {
    id?: boolean
    user_id?: boolean
    action?: boolean
    ip_address?: boolean
    created_at?: boolean
  }

  export type access_logsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "user_id" | "action" | "ip_address" | "created_at", ExtArgs["result"]["access_logs"]>
  export type access_logsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | access_logs$userArgs<ExtArgs>
  }
  export type access_logsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | access_logs$userArgs<ExtArgs>
  }
  export type access_logsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | access_logs$userArgs<ExtArgs>
  }

  export type $access_logsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "access_logs"
    objects: {
      user: Prisma.$usersPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      user_id: number | null
      action: string | null
      ip_address: string | null
      created_at: Date
    }, ExtArgs["result"]["access_logs"]>
    composites: {}
  }

  type access_logsGetPayload<S extends boolean | null | undefined | access_logsDefaultArgs> = $Result.GetResult<Prisma.$access_logsPayload, S>

  type access_logsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<access_logsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Access_logsCountAggregateInputType | true
    }

  export interface access_logsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['access_logs'], meta: { name: 'access_logs' } }
    /**
     * Find zero or one Access_logs that matches the filter.
     * @param {access_logsFindUniqueArgs} args - Arguments to find a Access_logs
     * @example
     * // Get one Access_logs
     * const access_logs = await prisma.access_logs.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends access_logsFindUniqueArgs>(args: SelectSubset<T, access_logsFindUniqueArgs<ExtArgs>>): Prisma__access_logsClient<$Result.GetResult<Prisma.$access_logsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Access_logs that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {access_logsFindUniqueOrThrowArgs} args - Arguments to find a Access_logs
     * @example
     * // Get one Access_logs
     * const access_logs = await prisma.access_logs.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends access_logsFindUniqueOrThrowArgs>(args: SelectSubset<T, access_logsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__access_logsClient<$Result.GetResult<Prisma.$access_logsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Access_logs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {access_logsFindFirstArgs} args - Arguments to find a Access_logs
     * @example
     * // Get one Access_logs
     * const access_logs = await prisma.access_logs.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends access_logsFindFirstArgs>(args?: SelectSubset<T, access_logsFindFirstArgs<ExtArgs>>): Prisma__access_logsClient<$Result.GetResult<Prisma.$access_logsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Access_logs that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {access_logsFindFirstOrThrowArgs} args - Arguments to find a Access_logs
     * @example
     * // Get one Access_logs
     * const access_logs = await prisma.access_logs.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends access_logsFindFirstOrThrowArgs>(args?: SelectSubset<T, access_logsFindFirstOrThrowArgs<ExtArgs>>): Prisma__access_logsClient<$Result.GetResult<Prisma.$access_logsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Access_logs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {access_logsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Access_logs
     * const access_logs = await prisma.access_logs.findMany()
     * 
     * // Get first 10 Access_logs
     * const access_logs = await prisma.access_logs.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const access_logsWithIdOnly = await prisma.access_logs.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends access_logsFindManyArgs>(args?: SelectSubset<T, access_logsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$access_logsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Access_logs.
     * @param {access_logsCreateArgs} args - Arguments to create a Access_logs.
     * @example
     * // Create one Access_logs
     * const Access_logs = await prisma.access_logs.create({
     *   data: {
     *     // ... data to create a Access_logs
     *   }
     * })
     * 
     */
    create<T extends access_logsCreateArgs>(args: SelectSubset<T, access_logsCreateArgs<ExtArgs>>): Prisma__access_logsClient<$Result.GetResult<Prisma.$access_logsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Access_logs.
     * @param {access_logsCreateManyArgs} args - Arguments to create many Access_logs.
     * @example
     * // Create many Access_logs
     * const access_logs = await prisma.access_logs.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends access_logsCreateManyArgs>(args?: SelectSubset<T, access_logsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Access_logs and returns the data saved in the database.
     * @param {access_logsCreateManyAndReturnArgs} args - Arguments to create many Access_logs.
     * @example
     * // Create many Access_logs
     * const access_logs = await prisma.access_logs.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Access_logs and only return the `id`
     * const access_logsWithIdOnly = await prisma.access_logs.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends access_logsCreateManyAndReturnArgs>(args?: SelectSubset<T, access_logsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$access_logsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Access_logs.
     * @param {access_logsDeleteArgs} args - Arguments to delete one Access_logs.
     * @example
     * // Delete one Access_logs
     * const Access_logs = await prisma.access_logs.delete({
     *   where: {
     *     // ... filter to delete one Access_logs
     *   }
     * })
     * 
     */
    delete<T extends access_logsDeleteArgs>(args: SelectSubset<T, access_logsDeleteArgs<ExtArgs>>): Prisma__access_logsClient<$Result.GetResult<Prisma.$access_logsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Access_logs.
     * @param {access_logsUpdateArgs} args - Arguments to update one Access_logs.
     * @example
     * // Update one Access_logs
     * const access_logs = await prisma.access_logs.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends access_logsUpdateArgs>(args: SelectSubset<T, access_logsUpdateArgs<ExtArgs>>): Prisma__access_logsClient<$Result.GetResult<Prisma.$access_logsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Access_logs.
     * @param {access_logsDeleteManyArgs} args - Arguments to filter Access_logs to delete.
     * @example
     * // Delete a few Access_logs
     * const { count } = await prisma.access_logs.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends access_logsDeleteManyArgs>(args?: SelectSubset<T, access_logsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Access_logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {access_logsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Access_logs
     * const access_logs = await prisma.access_logs.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends access_logsUpdateManyArgs>(args: SelectSubset<T, access_logsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Access_logs and returns the data updated in the database.
     * @param {access_logsUpdateManyAndReturnArgs} args - Arguments to update many Access_logs.
     * @example
     * // Update many Access_logs
     * const access_logs = await prisma.access_logs.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Access_logs and only return the `id`
     * const access_logsWithIdOnly = await prisma.access_logs.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends access_logsUpdateManyAndReturnArgs>(args: SelectSubset<T, access_logsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$access_logsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Access_logs.
     * @param {access_logsUpsertArgs} args - Arguments to update or create a Access_logs.
     * @example
     * // Update or create a Access_logs
     * const access_logs = await prisma.access_logs.upsert({
     *   create: {
     *     // ... data to create a Access_logs
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Access_logs we want to update
     *   }
     * })
     */
    upsert<T extends access_logsUpsertArgs>(args: SelectSubset<T, access_logsUpsertArgs<ExtArgs>>): Prisma__access_logsClient<$Result.GetResult<Prisma.$access_logsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Access_logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {access_logsCountArgs} args - Arguments to filter Access_logs to count.
     * @example
     * // Count the number of Access_logs
     * const count = await prisma.access_logs.count({
     *   where: {
     *     // ... the filter for the Access_logs we want to count
     *   }
     * })
    **/
    count<T extends access_logsCountArgs>(
      args?: Subset<T, access_logsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Access_logsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Access_logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Access_logsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Access_logsAggregateArgs>(args: Subset<T, Access_logsAggregateArgs>): Prisma.PrismaPromise<GetAccess_logsAggregateType<T>>

    /**
     * Group by Access_logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {access_logsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends access_logsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: access_logsGroupByArgs['orderBy'] }
        : { orderBy?: access_logsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, access_logsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAccess_logsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the access_logs model
   */
  readonly fields: access_logsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for access_logs.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__access_logsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends access_logs$userArgs<ExtArgs> = {}>(args?: Subset<T, access_logs$userArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the access_logs model
   */
  interface access_logsFieldRefs {
    readonly id: FieldRef<"access_logs", 'Int'>
    readonly user_id: FieldRef<"access_logs", 'Int'>
    readonly action: FieldRef<"access_logs", 'String'>
    readonly ip_address: FieldRef<"access_logs", 'String'>
    readonly created_at: FieldRef<"access_logs", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * access_logs findUnique
   */
  export type access_logsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the access_logs
     */
    select?: access_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the access_logs
     */
    omit?: access_logsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: access_logsInclude<ExtArgs> | null
    /**
     * Filter, which access_logs to fetch.
     */
    where: access_logsWhereUniqueInput
  }

  /**
   * access_logs findUniqueOrThrow
   */
  export type access_logsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the access_logs
     */
    select?: access_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the access_logs
     */
    omit?: access_logsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: access_logsInclude<ExtArgs> | null
    /**
     * Filter, which access_logs to fetch.
     */
    where: access_logsWhereUniqueInput
  }

  /**
   * access_logs findFirst
   */
  export type access_logsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the access_logs
     */
    select?: access_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the access_logs
     */
    omit?: access_logsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: access_logsInclude<ExtArgs> | null
    /**
     * Filter, which access_logs to fetch.
     */
    where?: access_logsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of access_logs to fetch.
     */
    orderBy?: access_logsOrderByWithRelationInput | access_logsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for access_logs.
     */
    cursor?: access_logsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` access_logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` access_logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of access_logs.
     */
    distinct?: Access_logsScalarFieldEnum | Access_logsScalarFieldEnum[]
  }

  /**
   * access_logs findFirstOrThrow
   */
  export type access_logsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the access_logs
     */
    select?: access_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the access_logs
     */
    omit?: access_logsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: access_logsInclude<ExtArgs> | null
    /**
     * Filter, which access_logs to fetch.
     */
    where?: access_logsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of access_logs to fetch.
     */
    orderBy?: access_logsOrderByWithRelationInput | access_logsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for access_logs.
     */
    cursor?: access_logsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` access_logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` access_logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of access_logs.
     */
    distinct?: Access_logsScalarFieldEnum | Access_logsScalarFieldEnum[]
  }

  /**
   * access_logs findMany
   */
  export type access_logsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the access_logs
     */
    select?: access_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the access_logs
     */
    omit?: access_logsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: access_logsInclude<ExtArgs> | null
    /**
     * Filter, which access_logs to fetch.
     */
    where?: access_logsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of access_logs to fetch.
     */
    orderBy?: access_logsOrderByWithRelationInput | access_logsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing access_logs.
     */
    cursor?: access_logsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` access_logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` access_logs.
     */
    skip?: number
    distinct?: Access_logsScalarFieldEnum | Access_logsScalarFieldEnum[]
  }

  /**
   * access_logs create
   */
  export type access_logsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the access_logs
     */
    select?: access_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the access_logs
     */
    omit?: access_logsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: access_logsInclude<ExtArgs> | null
    /**
     * The data needed to create a access_logs.
     */
    data?: XOR<access_logsCreateInput, access_logsUncheckedCreateInput>
  }

  /**
   * access_logs createMany
   */
  export type access_logsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many access_logs.
     */
    data: access_logsCreateManyInput | access_logsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * access_logs createManyAndReturn
   */
  export type access_logsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the access_logs
     */
    select?: access_logsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the access_logs
     */
    omit?: access_logsOmit<ExtArgs> | null
    /**
     * The data used to create many access_logs.
     */
    data: access_logsCreateManyInput | access_logsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: access_logsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * access_logs update
   */
  export type access_logsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the access_logs
     */
    select?: access_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the access_logs
     */
    omit?: access_logsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: access_logsInclude<ExtArgs> | null
    /**
     * The data needed to update a access_logs.
     */
    data: XOR<access_logsUpdateInput, access_logsUncheckedUpdateInput>
    /**
     * Choose, which access_logs to update.
     */
    where: access_logsWhereUniqueInput
  }

  /**
   * access_logs updateMany
   */
  export type access_logsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update access_logs.
     */
    data: XOR<access_logsUpdateManyMutationInput, access_logsUncheckedUpdateManyInput>
    /**
     * Filter which access_logs to update
     */
    where?: access_logsWhereInput
    /**
     * Limit how many access_logs to update.
     */
    limit?: number
  }

  /**
   * access_logs updateManyAndReturn
   */
  export type access_logsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the access_logs
     */
    select?: access_logsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the access_logs
     */
    omit?: access_logsOmit<ExtArgs> | null
    /**
     * The data used to update access_logs.
     */
    data: XOR<access_logsUpdateManyMutationInput, access_logsUncheckedUpdateManyInput>
    /**
     * Filter which access_logs to update
     */
    where?: access_logsWhereInput
    /**
     * Limit how many access_logs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: access_logsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * access_logs upsert
   */
  export type access_logsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the access_logs
     */
    select?: access_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the access_logs
     */
    omit?: access_logsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: access_logsInclude<ExtArgs> | null
    /**
     * The filter to search for the access_logs to update in case it exists.
     */
    where: access_logsWhereUniqueInput
    /**
     * In case the access_logs found by the `where` argument doesn't exist, create a new access_logs with this data.
     */
    create: XOR<access_logsCreateInput, access_logsUncheckedCreateInput>
    /**
     * In case the access_logs was found with the provided `where` argument, update it with this data.
     */
    update: XOR<access_logsUpdateInput, access_logsUncheckedUpdateInput>
  }

  /**
   * access_logs delete
   */
  export type access_logsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the access_logs
     */
    select?: access_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the access_logs
     */
    omit?: access_logsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: access_logsInclude<ExtArgs> | null
    /**
     * Filter which access_logs to delete.
     */
    where: access_logsWhereUniqueInput
  }

  /**
   * access_logs deleteMany
   */
  export type access_logsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which access_logs to delete
     */
    where?: access_logsWhereInput
    /**
     * Limit how many access_logs to delete.
     */
    limit?: number
  }

  /**
   * access_logs.user
   */
  export type access_logs$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    where?: usersWhereInput
  }

  /**
   * access_logs without action
   */
  export type access_logsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the access_logs
     */
    select?: access_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the access_logs
     */
    omit?: access_logsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: access_logsInclude<ExtArgs> | null
  }


  /**
   * Model ai_chat_sessions
   */

  export type AggregateAi_chat_sessions = {
    _count: Ai_chat_sessionsCountAggregateOutputType | null
    _avg: Ai_chat_sessionsAvgAggregateOutputType | null
    _sum: Ai_chat_sessionsSumAggregateOutputType | null
    _min: Ai_chat_sessionsMinAggregateOutputType | null
    _max: Ai_chat_sessionsMaxAggregateOutputType | null
  }

  export type Ai_chat_sessionsAvgAggregateOutputType = {
    id: number | null
    user_id: number | null
  }

  export type Ai_chat_sessionsSumAggregateOutputType = {
    id: number | null
    user_id: number | null
  }

  export type Ai_chat_sessionsMinAggregateOutputType = {
    id: number | null
    user_id: number | null
    session_token: string | null
    status: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Ai_chat_sessionsMaxAggregateOutputType = {
    id: number | null
    user_id: number | null
    session_token: string | null
    status: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Ai_chat_sessionsCountAggregateOutputType = {
    id: number
    user_id: number
    session_token: number
    status: number
    context_data: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type Ai_chat_sessionsAvgAggregateInputType = {
    id?: true
    user_id?: true
  }

  export type Ai_chat_sessionsSumAggregateInputType = {
    id?: true
    user_id?: true
  }

  export type Ai_chat_sessionsMinAggregateInputType = {
    id?: true
    user_id?: true
    session_token?: true
    status?: true
    created_at?: true
    updated_at?: true
  }

  export type Ai_chat_sessionsMaxAggregateInputType = {
    id?: true
    user_id?: true
    session_token?: true
    status?: true
    created_at?: true
    updated_at?: true
  }

  export type Ai_chat_sessionsCountAggregateInputType = {
    id?: true
    user_id?: true
    session_token?: true
    status?: true
    context_data?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type Ai_chat_sessionsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ai_chat_sessions to aggregate.
     */
    where?: ai_chat_sessionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ai_chat_sessions to fetch.
     */
    orderBy?: ai_chat_sessionsOrderByWithRelationInput | ai_chat_sessionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ai_chat_sessionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ai_chat_sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ai_chat_sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ai_chat_sessions
    **/
    _count?: true | Ai_chat_sessionsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Ai_chat_sessionsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Ai_chat_sessionsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Ai_chat_sessionsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Ai_chat_sessionsMaxAggregateInputType
  }

  export type GetAi_chat_sessionsAggregateType<T extends Ai_chat_sessionsAggregateArgs> = {
        [P in keyof T & keyof AggregateAi_chat_sessions]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAi_chat_sessions[P]>
      : GetScalarType<T[P], AggregateAi_chat_sessions[P]>
  }




  export type ai_chat_sessionsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ai_chat_sessionsWhereInput
    orderBy?: ai_chat_sessionsOrderByWithAggregationInput | ai_chat_sessionsOrderByWithAggregationInput[]
    by: Ai_chat_sessionsScalarFieldEnum[] | Ai_chat_sessionsScalarFieldEnum
    having?: ai_chat_sessionsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Ai_chat_sessionsCountAggregateInputType | true
    _avg?: Ai_chat_sessionsAvgAggregateInputType
    _sum?: Ai_chat_sessionsSumAggregateInputType
    _min?: Ai_chat_sessionsMinAggregateInputType
    _max?: Ai_chat_sessionsMaxAggregateInputType
  }

  export type Ai_chat_sessionsGroupByOutputType = {
    id: number
    user_id: number
    session_token: string
    status: string
    context_data: JsonValue | null
    created_at: Date
    updated_at: Date
    _count: Ai_chat_sessionsCountAggregateOutputType | null
    _avg: Ai_chat_sessionsAvgAggregateOutputType | null
    _sum: Ai_chat_sessionsSumAggregateOutputType | null
    _min: Ai_chat_sessionsMinAggregateOutputType | null
    _max: Ai_chat_sessionsMaxAggregateOutputType | null
  }

  type GetAi_chat_sessionsGroupByPayload<T extends ai_chat_sessionsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Ai_chat_sessionsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Ai_chat_sessionsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Ai_chat_sessionsGroupByOutputType[P]>
            : GetScalarType<T[P], Ai_chat_sessionsGroupByOutputType[P]>
        }
      >
    >


  export type ai_chat_sessionsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    session_token?: boolean
    status?: boolean
    context_data?: boolean
    created_at?: boolean
    updated_at?: boolean
    user?: boolean | usersDefaultArgs<ExtArgs>
    interactions?: boolean | ai_chat_sessions$interactionsArgs<ExtArgs>
    _count?: boolean | Ai_chat_sessionsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ai_chat_sessions"]>

  export type ai_chat_sessionsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    session_token?: boolean
    status?: boolean
    context_data?: boolean
    created_at?: boolean
    updated_at?: boolean
    user?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ai_chat_sessions"]>

  export type ai_chat_sessionsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    session_token?: boolean
    status?: boolean
    context_data?: boolean
    created_at?: boolean
    updated_at?: boolean
    user?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ai_chat_sessions"]>

  export type ai_chat_sessionsSelectScalar = {
    id?: boolean
    user_id?: boolean
    session_token?: boolean
    status?: boolean
    context_data?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type ai_chat_sessionsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "user_id" | "session_token" | "status" | "context_data" | "created_at" | "updated_at", ExtArgs["result"]["ai_chat_sessions"]>
  export type ai_chat_sessionsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | usersDefaultArgs<ExtArgs>
    interactions?: boolean | ai_chat_sessions$interactionsArgs<ExtArgs>
    _count?: boolean | Ai_chat_sessionsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ai_chat_sessionsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type ai_chat_sessionsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | usersDefaultArgs<ExtArgs>
  }

  export type $ai_chat_sessionsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ai_chat_sessions"
    objects: {
      user: Prisma.$usersPayload<ExtArgs>
      interactions: Prisma.$ai_interactionsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      user_id: number
      session_token: string
      status: string
      context_data: Prisma.JsonValue | null
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["ai_chat_sessions"]>
    composites: {}
  }

  type ai_chat_sessionsGetPayload<S extends boolean | null | undefined | ai_chat_sessionsDefaultArgs> = $Result.GetResult<Prisma.$ai_chat_sessionsPayload, S>

  type ai_chat_sessionsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ai_chat_sessionsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Ai_chat_sessionsCountAggregateInputType | true
    }

  export interface ai_chat_sessionsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ai_chat_sessions'], meta: { name: 'ai_chat_sessions' } }
    /**
     * Find zero or one Ai_chat_sessions that matches the filter.
     * @param {ai_chat_sessionsFindUniqueArgs} args - Arguments to find a Ai_chat_sessions
     * @example
     * // Get one Ai_chat_sessions
     * const ai_chat_sessions = await prisma.ai_chat_sessions.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ai_chat_sessionsFindUniqueArgs>(args: SelectSubset<T, ai_chat_sessionsFindUniqueArgs<ExtArgs>>): Prisma__ai_chat_sessionsClient<$Result.GetResult<Prisma.$ai_chat_sessionsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Ai_chat_sessions that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ai_chat_sessionsFindUniqueOrThrowArgs} args - Arguments to find a Ai_chat_sessions
     * @example
     * // Get one Ai_chat_sessions
     * const ai_chat_sessions = await prisma.ai_chat_sessions.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ai_chat_sessionsFindUniqueOrThrowArgs>(args: SelectSubset<T, ai_chat_sessionsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ai_chat_sessionsClient<$Result.GetResult<Prisma.$ai_chat_sessionsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Ai_chat_sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ai_chat_sessionsFindFirstArgs} args - Arguments to find a Ai_chat_sessions
     * @example
     * // Get one Ai_chat_sessions
     * const ai_chat_sessions = await prisma.ai_chat_sessions.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ai_chat_sessionsFindFirstArgs>(args?: SelectSubset<T, ai_chat_sessionsFindFirstArgs<ExtArgs>>): Prisma__ai_chat_sessionsClient<$Result.GetResult<Prisma.$ai_chat_sessionsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Ai_chat_sessions that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ai_chat_sessionsFindFirstOrThrowArgs} args - Arguments to find a Ai_chat_sessions
     * @example
     * // Get one Ai_chat_sessions
     * const ai_chat_sessions = await prisma.ai_chat_sessions.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ai_chat_sessionsFindFirstOrThrowArgs>(args?: SelectSubset<T, ai_chat_sessionsFindFirstOrThrowArgs<ExtArgs>>): Prisma__ai_chat_sessionsClient<$Result.GetResult<Prisma.$ai_chat_sessionsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Ai_chat_sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ai_chat_sessionsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Ai_chat_sessions
     * const ai_chat_sessions = await prisma.ai_chat_sessions.findMany()
     * 
     * // Get first 10 Ai_chat_sessions
     * const ai_chat_sessions = await prisma.ai_chat_sessions.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ai_chat_sessionsWithIdOnly = await prisma.ai_chat_sessions.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ai_chat_sessionsFindManyArgs>(args?: SelectSubset<T, ai_chat_sessionsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ai_chat_sessionsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Ai_chat_sessions.
     * @param {ai_chat_sessionsCreateArgs} args - Arguments to create a Ai_chat_sessions.
     * @example
     * // Create one Ai_chat_sessions
     * const Ai_chat_sessions = await prisma.ai_chat_sessions.create({
     *   data: {
     *     // ... data to create a Ai_chat_sessions
     *   }
     * })
     * 
     */
    create<T extends ai_chat_sessionsCreateArgs>(args: SelectSubset<T, ai_chat_sessionsCreateArgs<ExtArgs>>): Prisma__ai_chat_sessionsClient<$Result.GetResult<Prisma.$ai_chat_sessionsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Ai_chat_sessions.
     * @param {ai_chat_sessionsCreateManyArgs} args - Arguments to create many Ai_chat_sessions.
     * @example
     * // Create many Ai_chat_sessions
     * const ai_chat_sessions = await prisma.ai_chat_sessions.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ai_chat_sessionsCreateManyArgs>(args?: SelectSubset<T, ai_chat_sessionsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Ai_chat_sessions and returns the data saved in the database.
     * @param {ai_chat_sessionsCreateManyAndReturnArgs} args - Arguments to create many Ai_chat_sessions.
     * @example
     * // Create many Ai_chat_sessions
     * const ai_chat_sessions = await prisma.ai_chat_sessions.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Ai_chat_sessions and only return the `id`
     * const ai_chat_sessionsWithIdOnly = await prisma.ai_chat_sessions.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ai_chat_sessionsCreateManyAndReturnArgs>(args?: SelectSubset<T, ai_chat_sessionsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ai_chat_sessionsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Ai_chat_sessions.
     * @param {ai_chat_sessionsDeleteArgs} args - Arguments to delete one Ai_chat_sessions.
     * @example
     * // Delete one Ai_chat_sessions
     * const Ai_chat_sessions = await prisma.ai_chat_sessions.delete({
     *   where: {
     *     // ... filter to delete one Ai_chat_sessions
     *   }
     * })
     * 
     */
    delete<T extends ai_chat_sessionsDeleteArgs>(args: SelectSubset<T, ai_chat_sessionsDeleteArgs<ExtArgs>>): Prisma__ai_chat_sessionsClient<$Result.GetResult<Prisma.$ai_chat_sessionsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Ai_chat_sessions.
     * @param {ai_chat_sessionsUpdateArgs} args - Arguments to update one Ai_chat_sessions.
     * @example
     * // Update one Ai_chat_sessions
     * const ai_chat_sessions = await prisma.ai_chat_sessions.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ai_chat_sessionsUpdateArgs>(args: SelectSubset<T, ai_chat_sessionsUpdateArgs<ExtArgs>>): Prisma__ai_chat_sessionsClient<$Result.GetResult<Prisma.$ai_chat_sessionsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Ai_chat_sessions.
     * @param {ai_chat_sessionsDeleteManyArgs} args - Arguments to filter Ai_chat_sessions to delete.
     * @example
     * // Delete a few Ai_chat_sessions
     * const { count } = await prisma.ai_chat_sessions.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ai_chat_sessionsDeleteManyArgs>(args?: SelectSubset<T, ai_chat_sessionsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ai_chat_sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ai_chat_sessionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Ai_chat_sessions
     * const ai_chat_sessions = await prisma.ai_chat_sessions.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ai_chat_sessionsUpdateManyArgs>(args: SelectSubset<T, ai_chat_sessionsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ai_chat_sessions and returns the data updated in the database.
     * @param {ai_chat_sessionsUpdateManyAndReturnArgs} args - Arguments to update many Ai_chat_sessions.
     * @example
     * // Update many Ai_chat_sessions
     * const ai_chat_sessions = await prisma.ai_chat_sessions.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Ai_chat_sessions and only return the `id`
     * const ai_chat_sessionsWithIdOnly = await prisma.ai_chat_sessions.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ai_chat_sessionsUpdateManyAndReturnArgs>(args: SelectSubset<T, ai_chat_sessionsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ai_chat_sessionsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Ai_chat_sessions.
     * @param {ai_chat_sessionsUpsertArgs} args - Arguments to update or create a Ai_chat_sessions.
     * @example
     * // Update or create a Ai_chat_sessions
     * const ai_chat_sessions = await prisma.ai_chat_sessions.upsert({
     *   create: {
     *     // ... data to create a Ai_chat_sessions
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Ai_chat_sessions we want to update
     *   }
     * })
     */
    upsert<T extends ai_chat_sessionsUpsertArgs>(args: SelectSubset<T, ai_chat_sessionsUpsertArgs<ExtArgs>>): Prisma__ai_chat_sessionsClient<$Result.GetResult<Prisma.$ai_chat_sessionsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Ai_chat_sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ai_chat_sessionsCountArgs} args - Arguments to filter Ai_chat_sessions to count.
     * @example
     * // Count the number of Ai_chat_sessions
     * const count = await prisma.ai_chat_sessions.count({
     *   where: {
     *     // ... the filter for the Ai_chat_sessions we want to count
     *   }
     * })
    **/
    count<T extends ai_chat_sessionsCountArgs>(
      args?: Subset<T, ai_chat_sessionsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Ai_chat_sessionsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Ai_chat_sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Ai_chat_sessionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Ai_chat_sessionsAggregateArgs>(args: Subset<T, Ai_chat_sessionsAggregateArgs>): Prisma.PrismaPromise<GetAi_chat_sessionsAggregateType<T>>

    /**
     * Group by Ai_chat_sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ai_chat_sessionsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ai_chat_sessionsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ai_chat_sessionsGroupByArgs['orderBy'] }
        : { orderBy?: ai_chat_sessionsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ai_chat_sessionsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAi_chat_sessionsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ai_chat_sessions model
   */
  readonly fields: ai_chat_sessionsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ai_chat_sessions.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ai_chat_sessionsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    interactions<T extends ai_chat_sessions$interactionsArgs<ExtArgs> = {}>(args?: Subset<T, ai_chat_sessions$interactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ai_interactionsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ai_chat_sessions model
   */
  interface ai_chat_sessionsFieldRefs {
    readonly id: FieldRef<"ai_chat_sessions", 'Int'>
    readonly user_id: FieldRef<"ai_chat_sessions", 'Int'>
    readonly session_token: FieldRef<"ai_chat_sessions", 'String'>
    readonly status: FieldRef<"ai_chat_sessions", 'String'>
    readonly context_data: FieldRef<"ai_chat_sessions", 'Json'>
    readonly created_at: FieldRef<"ai_chat_sessions", 'DateTime'>
    readonly updated_at: FieldRef<"ai_chat_sessions", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ai_chat_sessions findUnique
   */
  export type ai_chat_sessionsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ai_chat_sessions
     */
    select?: ai_chat_sessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ai_chat_sessions
     */
    omit?: ai_chat_sessionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ai_chat_sessionsInclude<ExtArgs> | null
    /**
     * Filter, which ai_chat_sessions to fetch.
     */
    where: ai_chat_sessionsWhereUniqueInput
  }

  /**
   * ai_chat_sessions findUniqueOrThrow
   */
  export type ai_chat_sessionsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ai_chat_sessions
     */
    select?: ai_chat_sessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ai_chat_sessions
     */
    omit?: ai_chat_sessionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ai_chat_sessionsInclude<ExtArgs> | null
    /**
     * Filter, which ai_chat_sessions to fetch.
     */
    where: ai_chat_sessionsWhereUniqueInput
  }

  /**
   * ai_chat_sessions findFirst
   */
  export type ai_chat_sessionsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ai_chat_sessions
     */
    select?: ai_chat_sessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ai_chat_sessions
     */
    omit?: ai_chat_sessionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ai_chat_sessionsInclude<ExtArgs> | null
    /**
     * Filter, which ai_chat_sessions to fetch.
     */
    where?: ai_chat_sessionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ai_chat_sessions to fetch.
     */
    orderBy?: ai_chat_sessionsOrderByWithRelationInput | ai_chat_sessionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ai_chat_sessions.
     */
    cursor?: ai_chat_sessionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ai_chat_sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ai_chat_sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ai_chat_sessions.
     */
    distinct?: Ai_chat_sessionsScalarFieldEnum | Ai_chat_sessionsScalarFieldEnum[]
  }

  /**
   * ai_chat_sessions findFirstOrThrow
   */
  export type ai_chat_sessionsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ai_chat_sessions
     */
    select?: ai_chat_sessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ai_chat_sessions
     */
    omit?: ai_chat_sessionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ai_chat_sessionsInclude<ExtArgs> | null
    /**
     * Filter, which ai_chat_sessions to fetch.
     */
    where?: ai_chat_sessionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ai_chat_sessions to fetch.
     */
    orderBy?: ai_chat_sessionsOrderByWithRelationInput | ai_chat_sessionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ai_chat_sessions.
     */
    cursor?: ai_chat_sessionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ai_chat_sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ai_chat_sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ai_chat_sessions.
     */
    distinct?: Ai_chat_sessionsScalarFieldEnum | Ai_chat_sessionsScalarFieldEnum[]
  }

  /**
   * ai_chat_sessions findMany
   */
  export type ai_chat_sessionsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ai_chat_sessions
     */
    select?: ai_chat_sessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ai_chat_sessions
     */
    omit?: ai_chat_sessionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ai_chat_sessionsInclude<ExtArgs> | null
    /**
     * Filter, which ai_chat_sessions to fetch.
     */
    where?: ai_chat_sessionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ai_chat_sessions to fetch.
     */
    orderBy?: ai_chat_sessionsOrderByWithRelationInput | ai_chat_sessionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ai_chat_sessions.
     */
    cursor?: ai_chat_sessionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ai_chat_sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ai_chat_sessions.
     */
    skip?: number
    distinct?: Ai_chat_sessionsScalarFieldEnum | Ai_chat_sessionsScalarFieldEnum[]
  }

  /**
   * ai_chat_sessions create
   */
  export type ai_chat_sessionsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ai_chat_sessions
     */
    select?: ai_chat_sessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ai_chat_sessions
     */
    omit?: ai_chat_sessionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ai_chat_sessionsInclude<ExtArgs> | null
    /**
     * The data needed to create a ai_chat_sessions.
     */
    data: XOR<ai_chat_sessionsCreateInput, ai_chat_sessionsUncheckedCreateInput>
  }

  /**
   * ai_chat_sessions createMany
   */
  export type ai_chat_sessionsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ai_chat_sessions.
     */
    data: ai_chat_sessionsCreateManyInput | ai_chat_sessionsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ai_chat_sessions createManyAndReturn
   */
  export type ai_chat_sessionsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ai_chat_sessions
     */
    select?: ai_chat_sessionsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ai_chat_sessions
     */
    omit?: ai_chat_sessionsOmit<ExtArgs> | null
    /**
     * The data used to create many ai_chat_sessions.
     */
    data: ai_chat_sessionsCreateManyInput | ai_chat_sessionsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ai_chat_sessionsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ai_chat_sessions update
   */
  export type ai_chat_sessionsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ai_chat_sessions
     */
    select?: ai_chat_sessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ai_chat_sessions
     */
    omit?: ai_chat_sessionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ai_chat_sessionsInclude<ExtArgs> | null
    /**
     * The data needed to update a ai_chat_sessions.
     */
    data: XOR<ai_chat_sessionsUpdateInput, ai_chat_sessionsUncheckedUpdateInput>
    /**
     * Choose, which ai_chat_sessions to update.
     */
    where: ai_chat_sessionsWhereUniqueInput
  }

  /**
   * ai_chat_sessions updateMany
   */
  export type ai_chat_sessionsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ai_chat_sessions.
     */
    data: XOR<ai_chat_sessionsUpdateManyMutationInput, ai_chat_sessionsUncheckedUpdateManyInput>
    /**
     * Filter which ai_chat_sessions to update
     */
    where?: ai_chat_sessionsWhereInput
    /**
     * Limit how many ai_chat_sessions to update.
     */
    limit?: number
  }

  /**
   * ai_chat_sessions updateManyAndReturn
   */
  export type ai_chat_sessionsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ai_chat_sessions
     */
    select?: ai_chat_sessionsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ai_chat_sessions
     */
    omit?: ai_chat_sessionsOmit<ExtArgs> | null
    /**
     * The data used to update ai_chat_sessions.
     */
    data: XOR<ai_chat_sessionsUpdateManyMutationInput, ai_chat_sessionsUncheckedUpdateManyInput>
    /**
     * Filter which ai_chat_sessions to update
     */
    where?: ai_chat_sessionsWhereInput
    /**
     * Limit how many ai_chat_sessions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ai_chat_sessionsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ai_chat_sessions upsert
   */
  export type ai_chat_sessionsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ai_chat_sessions
     */
    select?: ai_chat_sessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ai_chat_sessions
     */
    omit?: ai_chat_sessionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ai_chat_sessionsInclude<ExtArgs> | null
    /**
     * The filter to search for the ai_chat_sessions to update in case it exists.
     */
    where: ai_chat_sessionsWhereUniqueInput
    /**
     * In case the ai_chat_sessions found by the `where` argument doesn't exist, create a new ai_chat_sessions with this data.
     */
    create: XOR<ai_chat_sessionsCreateInput, ai_chat_sessionsUncheckedCreateInput>
    /**
     * In case the ai_chat_sessions was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ai_chat_sessionsUpdateInput, ai_chat_sessionsUncheckedUpdateInput>
  }

  /**
   * ai_chat_sessions delete
   */
  export type ai_chat_sessionsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ai_chat_sessions
     */
    select?: ai_chat_sessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ai_chat_sessions
     */
    omit?: ai_chat_sessionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ai_chat_sessionsInclude<ExtArgs> | null
    /**
     * Filter which ai_chat_sessions to delete.
     */
    where: ai_chat_sessionsWhereUniqueInput
  }

  /**
   * ai_chat_sessions deleteMany
   */
  export type ai_chat_sessionsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ai_chat_sessions to delete
     */
    where?: ai_chat_sessionsWhereInput
    /**
     * Limit how many ai_chat_sessions to delete.
     */
    limit?: number
  }

  /**
   * ai_chat_sessions.interactions
   */
  export type ai_chat_sessions$interactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ai_interactions
     */
    select?: ai_interactionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ai_interactions
     */
    omit?: ai_interactionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ai_interactionsInclude<ExtArgs> | null
    where?: ai_interactionsWhereInput
    orderBy?: ai_interactionsOrderByWithRelationInput | ai_interactionsOrderByWithRelationInput[]
    cursor?: ai_interactionsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Ai_interactionsScalarFieldEnum | Ai_interactionsScalarFieldEnum[]
  }

  /**
   * ai_chat_sessions without action
   */
  export type ai_chat_sessionsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ai_chat_sessions
     */
    select?: ai_chat_sessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ai_chat_sessions
     */
    omit?: ai_chat_sessionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ai_chat_sessionsInclude<ExtArgs> | null
  }


  /**
   * Model ai_interactions
   */

  export type AggregateAi_interactions = {
    _count: Ai_interactionsCountAggregateOutputType | null
    _avg: Ai_interactionsAvgAggregateOutputType | null
    _sum: Ai_interactionsSumAggregateOutputType | null
    _min: Ai_interactionsMinAggregateOutputType | null
    _max: Ai_interactionsMaxAggregateOutputType | null
  }

  export type Ai_interactionsAvgAggregateOutputType = {
    id: number | null
    session_id: number | null
    user_id: number | null
    execution_time_ms: number | null
    confidence_score: number | null
  }

  export type Ai_interactionsSumAggregateOutputType = {
    id: number | null
    session_id: number | null
    user_id: number | null
    execution_time_ms: number | null
    confidence_score: number | null
  }

  export type Ai_interactionsMinAggregateOutputType = {
    id: number | null
    session_id: number | null
    user_id: number | null
    interaction_type: string | null
    input_text: string | null
    input_language: string | null
    processed_query: string | null
    execution_status: string | null
    execution_time_ms: number | null
    confidence_score: number | null
    error_message: string | null
    fallback_used: boolean | null
    version: string | null
    created_at: Date | null
  }

  export type Ai_interactionsMaxAggregateOutputType = {
    id: number | null
    session_id: number | null
    user_id: number | null
    interaction_type: string | null
    input_text: string | null
    input_language: string | null
    processed_query: string | null
    execution_status: string | null
    execution_time_ms: number | null
    confidence_score: number | null
    error_message: string | null
    fallback_used: boolean | null
    version: string | null
    created_at: Date | null
  }

  export type Ai_interactionsCountAggregateOutputType = {
    id: number
    session_id: number
    user_id: number
    interaction_type: number
    input_text: number
    input_language: number
    processed_query: number
    ai_response: number
    execution_status: number
    execution_time_ms: number
    confidence_score: number
    error_message: number
    fallback_used: number
    version: number
    metadata: number
    created_at: number
    _all: number
  }


  export type Ai_interactionsAvgAggregateInputType = {
    id?: true
    session_id?: true
    user_id?: true
    execution_time_ms?: true
    confidence_score?: true
  }

  export type Ai_interactionsSumAggregateInputType = {
    id?: true
    session_id?: true
    user_id?: true
    execution_time_ms?: true
    confidence_score?: true
  }

  export type Ai_interactionsMinAggregateInputType = {
    id?: true
    session_id?: true
    user_id?: true
    interaction_type?: true
    input_text?: true
    input_language?: true
    processed_query?: true
    execution_status?: true
    execution_time_ms?: true
    confidence_score?: true
    error_message?: true
    fallback_used?: true
    version?: true
    created_at?: true
  }

  export type Ai_interactionsMaxAggregateInputType = {
    id?: true
    session_id?: true
    user_id?: true
    interaction_type?: true
    input_text?: true
    input_language?: true
    processed_query?: true
    execution_status?: true
    execution_time_ms?: true
    confidence_score?: true
    error_message?: true
    fallback_used?: true
    version?: true
    created_at?: true
  }

  export type Ai_interactionsCountAggregateInputType = {
    id?: true
    session_id?: true
    user_id?: true
    interaction_type?: true
    input_text?: true
    input_language?: true
    processed_query?: true
    ai_response?: true
    execution_status?: true
    execution_time_ms?: true
    confidence_score?: true
    error_message?: true
    fallback_used?: true
    version?: true
    metadata?: true
    created_at?: true
    _all?: true
  }

  export type Ai_interactionsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ai_interactions to aggregate.
     */
    where?: ai_interactionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ai_interactions to fetch.
     */
    orderBy?: ai_interactionsOrderByWithRelationInput | ai_interactionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ai_interactionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ai_interactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ai_interactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ai_interactions
    **/
    _count?: true | Ai_interactionsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Ai_interactionsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Ai_interactionsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Ai_interactionsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Ai_interactionsMaxAggregateInputType
  }

  export type GetAi_interactionsAggregateType<T extends Ai_interactionsAggregateArgs> = {
        [P in keyof T & keyof AggregateAi_interactions]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAi_interactions[P]>
      : GetScalarType<T[P], AggregateAi_interactions[P]>
  }




  export type ai_interactionsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ai_interactionsWhereInput
    orderBy?: ai_interactionsOrderByWithAggregationInput | ai_interactionsOrderByWithAggregationInput[]
    by: Ai_interactionsScalarFieldEnum[] | Ai_interactionsScalarFieldEnum
    having?: ai_interactionsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Ai_interactionsCountAggregateInputType | true
    _avg?: Ai_interactionsAvgAggregateInputType
    _sum?: Ai_interactionsSumAggregateInputType
    _min?: Ai_interactionsMinAggregateInputType
    _max?: Ai_interactionsMaxAggregateInputType
  }

  export type Ai_interactionsGroupByOutputType = {
    id: number
    session_id: number
    user_id: number
    interaction_type: string
    input_text: string
    input_language: string
    processed_query: string | null
    ai_response: JsonValue | null
    execution_status: string
    execution_time_ms: number | null
    confidence_score: number | null
    error_message: string | null
    fallback_used: boolean
    version: string
    metadata: JsonValue | null
    created_at: Date
    _count: Ai_interactionsCountAggregateOutputType | null
    _avg: Ai_interactionsAvgAggregateOutputType | null
    _sum: Ai_interactionsSumAggregateOutputType | null
    _min: Ai_interactionsMinAggregateOutputType | null
    _max: Ai_interactionsMaxAggregateOutputType | null
  }

  type GetAi_interactionsGroupByPayload<T extends ai_interactionsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Ai_interactionsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Ai_interactionsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Ai_interactionsGroupByOutputType[P]>
            : GetScalarType<T[P], Ai_interactionsGroupByOutputType[P]>
        }
      >
    >


  export type ai_interactionsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    session_id?: boolean
    user_id?: boolean
    interaction_type?: boolean
    input_text?: boolean
    input_language?: boolean
    processed_query?: boolean
    ai_response?: boolean
    execution_status?: boolean
    execution_time_ms?: boolean
    confidence_score?: boolean
    error_message?: boolean
    fallback_used?: boolean
    version?: boolean
    metadata?: boolean
    created_at?: boolean
    session?: boolean | ai_chat_sessionsDefaultArgs<ExtArgs>
    user?: boolean | usersDefaultArgs<ExtArgs>
    insights?: boolean | ai_interactions$insightsArgs<ExtArgs>
    _count?: boolean | Ai_interactionsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ai_interactions"]>

  export type ai_interactionsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    session_id?: boolean
    user_id?: boolean
    interaction_type?: boolean
    input_text?: boolean
    input_language?: boolean
    processed_query?: boolean
    ai_response?: boolean
    execution_status?: boolean
    execution_time_ms?: boolean
    confidence_score?: boolean
    error_message?: boolean
    fallback_used?: boolean
    version?: boolean
    metadata?: boolean
    created_at?: boolean
    session?: boolean | ai_chat_sessionsDefaultArgs<ExtArgs>
    user?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ai_interactions"]>

  export type ai_interactionsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    session_id?: boolean
    user_id?: boolean
    interaction_type?: boolean
    input_text?: boolean
    input_language?: boolean
    processed_query?: boolean
    ai_response?: boolean
    execution_status?: boolean
    execution_time_ms?: boolean
    confidence_score?: boolean
    error_message?: boolean
    fallback_used?: boolean
    version?: boolean
    metadata?: boolean
    created_at?: boolean
    session?: boolean | ai_chat_sessionsDefaultArgs<ExtArgs>
    user?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ai_interactions"]>

  export type ai_interactionsSelectScalar = {
    id?: boolean
    session_id?: boolean
    user_id?: boolean
    interaction_type?: boolean
    input_text?: boolean
    input_language?: boolean
    processed_query?: boolean
    ai_response?: boolean
    execution_status?: boolean
    execution_time_ms?: boolean
    confidence_score?: boolean
    error_message?: boolean
    fallback_used?: boolean
    version?: boolean
    metadata?: boolean
    created_at?: boolean
  }

  export type ai_interactionsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "session_id" | "user_id" | "interaction_type" | "input_text" | "input_language" | "processed_query" | "ai_response" | "execution_status" | "execution_time_ms" | "confidence_score" | "error_message" | "fallback_used" | "version" | "metadata" | "created_at", ExtArgs["result"]["ai_interactions"]>
  export type ai_interactionsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | ai_chat_sessionsDefaultArgs<ExtArgs>
    user?: boolean | usersDefaultArgs<ExtArgs>
    insights?: boolean | ai_interactions$insightsArgs<ExtArgs>
    _count?: boolean | Ai_interactionsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ai_interactionsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | ai_chat_sessionsDefaultArgs<ExtArgs>
    user?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type ai_interactionsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | ai_chat_sessionsDefaultArgs<ExtArgs>
    user?: boolean | usersDefaultArgs<ExtArgs>
  }

  export type $ai_interactionsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ai_interactions"
    objects: {
      session: Prisma.$ai_chat_sessionsPayload<ExtArgs>
      user: Prisma.$usersPayload<ExtArgs>
      insights: Prisma.$ai_insightsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      session_id: number
      user_id: number
      interaction_type: string
      input_text: string
      input_language: string
      processed_query: string | null
      ai_response: Prisma.JsonValue | null
      execution_status: string
      execution_time_ms: number | null
      confidence_score: number | null
      error_message: string | null
      fallback_used: boolean
      version: string
      metadata: Prisma.JsonValue | null
      created_at: Date
    }, ExtArgs["result"]["ai_interactions"]>
    composites: {}
  }

  type ai_interactionsGetPayload<S extends boolean | null | undefined | ai_interactionsDefaultArgs> = $Result.GetResult<Prisma.$ai_interactionsPayload, S>

  type ai_interactionsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ai_interactionsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Ai_interactionsCountAggregateInputType | true
    }

  export interface ai_interactionsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ai_interactions'], meta: { name: 'ai_interactions' } }
    /**
     * Find zero or one Ai_interactions that matches the filter.
     * @param {ai_interactionsFindUniqueArgs} args - Arguments to find a Ai_interactions
     * @example
     * // Get one Ai_interactions
     * const ai_interactions = await prisma.ai_interactions.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ai_interactionsFindUniqueArgs>(args: SelectSubset<T, ai_interactionsFindUniqueArgs<ExtArgs>>): Prisma__ai_interactionsClient<$Result.GetResult<Prisma.$ai_interactionsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Ai_interactions that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ai_interactionsFindUniqueOrThrowArgs} args - Arguments to find a Ai_interactions
     * @example
     * // Get one Ai_interactions
     * const ai_interactions = await prisma.ai_interactions.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ai_interactionsFindUniqueOrThrowArgs>(args: SelectSubset<T, ai_interactionsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ai_interactionsClient<$Result.GetResult<Prisma.$ai_interactionsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Ai_interactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ai_interactionsFindFirstArgs} args - Arguments to find a Ai_interactions
     * @example
     * // Get one Ai_interactions
     * const ai_interactions = await prisma.ai_interactions.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ai_interactionsFindFirstArgs>(args?: SelectSubset<T, ai_interactionsFindFirstArgs<ExtArgs>>): Prisma__ai_interactionsClient<$Result.GetResult<Prisma.$ai_interactionsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Ai_interactions that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ai_interactionsFindFirstOrThrowArgs} args - Arguments to find a Ai_interactions
     * @example
     * // Get one Ai_interactions
     * const ai_interactions = await prisma.ai_interactions.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ai_interactionsFindFirstOrThrowArgs>(args?: SelectSubset<T, ai_interactionsFindFirstOrThrowArgs<ExtArgs>>): Prisma__ai_interactionsClient<$Result.GetResult<Prisma.$ai_interactionsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Ai_interactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ai_interactionsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Ai_interactions
     * const ai_interactions = await prisma.ai_interactions.findMany()
     * 
     * // Get first 10 Ai_interactions
     * const ai_interactions = await prisma.ai_interactions.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ai_interactionsWithIdOnly = await prisma.ai_interactions.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ai_interactionsFindManyArgs>(args?: SelectSubset<T, ai_interactionsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ai_interactionsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Ai_interactions.
     * @param {ai_interactionsCreateArgs} args - Arguments to create a Ai_interactions.
     * @example
     * // Create one Ai_interactions
     * const Ai_interactions = await prisma.ai_interactions.create({
     *   data: {
     *     // ... data to create a Ai_interactions
     *   }
     * })
     * 
     */
    create<T extends ai_interactionsCreateArgs>(args: SelectSubset<T, ai_interactionsCreateArgs<ExtArgs>>): Prisma__ai_interactionsClient<$Result.GetResult<Prisma.$ai_interactionsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Ai_interactions.
     * @param {ai_interactionsCreateManyArgs} args - Arguments to create many Ai_interactions.
     * @example
     * // Create many Ai_interactions
     * const ai_interactions = await prisma.ai_interactions.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ai_interactionsCreateManyArgs>(args?: SelectSubset<T, ai_interactionsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Ai_interactions and returns the data saved in the database.
     * @param {ai_interactionsCreateManyAndReturnArgs} args - Arguments to create many Ai_interactions.
     * @example
     * // Create many Ai_interactions
     * const ai_interactions = await prisma.ai_interactions.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Ai_interactions and only return the `id`
     * const ai_interactionsWithIdOnly = await prisma.ai_interactions.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ai_interactionsCreateManyAndReturnArgs>(args?: SelectSubset<T, ai_interactionsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ai_interactionsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Ai_interactions.
     * @param {ai_interactionsDeleteArgs} args - Arguments to delete one Ai_interactions.
     * @example
     * // Delete one Ai_interactions
     * const Ai_interactions = await prisma.ai_interactions.delete({
     *   where: {
     *     // ... filter to delete one Ai_interactions
     *   }
     * })
     * 
     */
    delete<T extends ai_interactionsDeleteArgs>(args: SelectSubset<T, ai_interactionsDeleteArgs<ExtArgs>>): Prisma__ai_interactionsClient<$Result.GetResult<Prisma.$ai_interactionsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Ai_interactions.
     * @param {ai_interactionsUpdateArgs} args - Arguments to update one Ai_interactions.
     * @example
     * // Update one Ai_interactions
     * const ai_interactions = await prisma.ai_interactions.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ai_interactionsUpdateArgs>(args: SelectSubset<T, ai_interactionsUpdateArgs<ExtArgs>>): Prisma__ai_interactionsClient<$Result.GetResult<Prisma.$ai_interactionsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Ai_interactions.
     * @param {ai_interactionsDeleteManyArgs} args - Arguments to filter Ai_interactions to delete.
     * @example
     * // Delete a few Ai_interactions
     * const { count } = await prisma.ai_interactions.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ai_interactionsDeleteManyArgs>(args?: SelectSubset<T, ai_interactionsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ai_interactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ai_interactionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Ai_interactions
     * const ai_interactions = await prisma.ai_interactions.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ai_interactionsUpdateManyArgs>(args: SelectSubset<T, ai_interactionsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ai_interactions and returns the data updated in the database.
     * @param {ai_interactionsUpdateManyAndReturnArgs} args - Arguments to update many Ai_interactions.
     * @example
     * // Update many Ai_interactions
     * const ai_interactions = await prisma.ai_interactions.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Ai_interactions and only return the `id`
     * const ai_interactionsWithIdOnly = await prisma.ai_interactions.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ai_interactionsUpdateManyAndReturnArgs>(args: SelectSubset<T, ai_interactionsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ai_interactionsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Ai_interactions.
     * @param {ai_interactionsUpsertArgs} args - Arguments to update or create a Ai_interactions.
     * @example
     * // Update or create a Ai_interactions
     * const ai_interactions = await prisma.ai_interactions.upsert({
     *   create: {
     *     // ... data to create a Ai_interactions
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Ai_interactions we want to update
     *   }
     * })
     */
    upsert<T extends ai_interactionsUpsertArgs>(args: SelectSubset<T, ai_interactionsUpsertArgs<ExtArgs>>): Prisma__ai_interactionsClient<$Result.GetResult<Prisma.$ai_interactionsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Ai_interactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ai_interactionsCountArgs} args - Arguments to filter Ai_interactions to count.
     * @example
     * // Count the number of Ai_interactions
     * const count = await prisma.ai_interactions.count({
     *   where: {
     *     // ... the filter for the Ai_interactions we want to count
     *   }
     * })
    **/
    count<T extends ai_interactionsCountArgs>(
      args?: Subset<T, ai_interactionsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Ai_interactionsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Ai_interactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Ai_interactionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Ai_interactionsAggregateArgs>(args: Subset<T, Ai_interactionsAggregateArgs>): Prisma.PrismaPromise<GetAi_interactionsAggregateType<T>>

    /**
     * Group by Ai_interactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ai_interactionsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ai_interactionsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ai_interactionsGroupByArgs['orderBy'] }
        : { orderBy?: ai_interactionsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ai_interactionsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAi_interactionsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ai_interactions model
   */
  readonly fields: ai_interactionsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ai_interactions.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ai_interactionsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    session<T extends ai_chat_sessionsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ai_chat_sessionsDefaultArgs<ExtArgs>>): Prisma__ai_chat_sessionsClient<$Result.GetResult<Prisma.$ai_chat_sessionsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    insights<T extends ai_interactions$insightsArgs<ExtArgs> = {}>(args?: Subset<T, ai_interactions$insightsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ai_insightsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ai_interactions model
   */
  interface ai_interactionsFieldRefs {
    readonly id: FieldRef<"ai_interactions", 'Int'>
    readonly session_id: FieldRef<"ai_interactions", 'Int'>
    readonly user_id: FieldRef<"ai_interactions", 'Int'>
    readonly interaction_type: FieldRef<"ai_interactions", 'String'>
    readonly input_text: FieldRef<"ai_interactions", 'String'>
    readonly input_language: FieldRef<"ai_interactions", 'String'>
    readonly processed_query: FieldRef<"ai_interactions", 'String'>
    readonly ai_response: FieldRef<"ai_interactions", 'Json'>
    readonly execution_status: FieldRef<"ai_interactions", 'String'>
    readonly execution_time_ms: FieldRef<"ai_interactions", 'Int'>
    readonly confidence_score: FieldRef<"ai_interactions", 'Float'>
    readonly error_message: FieldRef<"ai_interactions", 'String'>
    readonly fallback_used: FieldRef<"ai_interactions", 'Boolean'>
    readonly version: FieldRef<"ai_interactions", 'String'>
    readonly metadata: FieldRef<"ai_interactions", 'Json'>
    readonly created_at: FieldRef<"ai_interactions", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ai_interactions findUnique
   */
  export type ai_interactionsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ai_interactions
     */
    select?: ai_interactionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ai_interactions
     */
    omit?: ai_interactionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ai_interactionsInclude<ExtArgs> | null
    /**
     * Filter, which ai_interactions to fetch.
     */
    where: ai_interactionsWhereUniqueInput
  }

  /**
   * ai_interactions findUniqueOrThrow
   */
  export type ai_interactionsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ai_interactions
     */
    select?: ai_interactionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ai_interactions
     */
    omit?: ai_interactionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ai_interactionsInclude<ExtArgs> | null
    /**
     * Filter, which ai_interactions to fetch.
     */
    where: ai_interactionsWhereUniqueInput
  }

  /**
   * ai_interactions findFirst
   */
  export type ai_interactionsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ai_interactions
     */
    select?: ai_interactionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ai_interactions
     */
    omit?: ai_interactionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ai_interactionsInclude<ExtArgs> | null
    /**
     * Filter, which ai_interactions to fetch.
     */
    where?: ai_interactionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ai_interactions to fetch.
     */
    orderBy?: ai_interactionsOrderByWithRelationInput | ai_interactionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ai_interactions.
     */
    cursor?: ai_interactionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ai_interactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ai_interactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ai_interactions.
     */
    distinct?: Ai_interactionsScalarFieldEnum | Ai_interactionsScalarFieldEnum[]
  }

  /**
   * ai_interactions findFirstOrThrow
   */
  export type ai_interactionsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ai_interactions
     */
    select?: ai_interactionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ai_interactions
     */
    omit?: ai_interactionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ai_interactionsInclude<ExtArgs> | null
    /**
     * Filter, which ai_interactions to fetch.
     */
    where?: ai_interactionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ai_interactions to fetch.
     */
    orderBy?: ai_interactionsOrderByWithRelationInput | ai_interactionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ai_interactions.
     */
    cursor?: ai_interactionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ai_interactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ai_interactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ai_interactions.
     */
    distinct?: Ai_interactionsScalarFieldEnum | Ai_interactionsScalarFieldEnum[]
  }

  /**
   * ai_interactions findMany
   */
  export type ai_interactionsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ai_interactions
     */
    select?: ai_interactionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ai_interactions
     */
    omit?: ai_interactionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ai_interactionsInclude<ExtArgs> | null
    /**
     * Filter, which ai_interactions to fetch.
     */
    where?: ai_interactionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ai_interactions to fetch.
     */
    orderBy?: ai_interactionsOrderByWithRelationInput | ai_interactionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ai_interactions.
     */
    cursor?: ai_interactionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ai_interactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ai_interactions.
     */
    skip?: number
    distinct?: Ai_interactionsScalarFieldEnum | Ai_interactionsScalarFieldEnum[]
  }

  /**
   * ai_interactions create
   */
  export type ai_interactionsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ai_interactions
     */
    select?: ai_interactionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ai_interactions
     */
    omit?: ai_interactionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ai_interactionsInclude<ExtArgs> | null
    /**
     * The data needed to create a ai_interactions.
     */
    data: XOR<ai_interactionsCreateInput, ai_interactionsUncheckedCreateInput>
  }

  /**
   * ai_interactions createMany
   */
  export type ai_interactionsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ai_interactions.
     */
    data: ai_interactionsCreateManyInput | ai_interactionsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ai_interactions createManyAndReturn
   */
  export type ai_interactionsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ai_interactions
     */
    select?: ai_interactionsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ai_interactions
     */
    omit?: ai_interactionsOmit<ExtArgs> | null
    /**
     * The data used to create many ai_interactions.
     */
    data: ai_interactionsCreateManyInput | ai_interactionsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ai_interactionsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ai_interactions update
   */
  export type ai_interactionsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ai_interactions
     */
    select?: ai_interactionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ai_interactions
     */
    omit?: ai_interactionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ai_interactionsInclude<ExtArgs> | null
    /**
     * The data needed to update a ai_interactions.
     */
    data: XOR<ai_interactionsUpdateInput, ai_interactionsUncheckedUpdateInput>
    /**
     * Choose, which ai_interactions to update.
     */
    where: ai_interactionsWhereUniqueInput
  }

  /**
   * ai_interactions updateMany
   */
  export type ai_interactionsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ai_interactions.
     */
    data: XOR<ai_interactionsUpdateManyMutationInput, ai_interactionsUncheckedUpdateManyInput>
    /**
     * Filter which ai_interactions to update
     */
    where?: ai_interactionsWhereInput
    /**
     * Limit how many ai_interactions to update.
     */
    limit?: number
  }

  /**
   * ai_interactions updateManyAndReturn
   */
  export type ai_interactionsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ai_interactions
     */
    select?: ai_interactionsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ai_interactions
     */
    omit?: ai_interactionsOmit<ExtArgs> | null
    /**
     * The data used to update ai_interactions.
     */
    data: XOR<ai_interactionsUpdateManyMutationInput, ai_interactionsUncheckedUpdateManyInput>
    /**
     * Filter which ai_interactions to update
     */
    where?: ai_interactionsWhereInput
    /**
     * Limit how many ai_interactions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ai_interactionsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ai_interactions upsert
   */
  export type ai_interactionsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ai_interactions
     */
    select?: ai_interactionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ai_interactions
     */
    omit?: ai_interactionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ai_interactionsInclude<ExtArgs> | null
    /**
     * The filter to search for the ai_interactions to update in case it exists.
     */
    where: ai_interactionsWhereUniqueInput
    /**
     * In case the ai_interactions found by the `where` argument doesn't exist, create a new ai_interactions with this data.
     */
    create: XOR<ai_interactionsCreateInput, ai_interactionsUncheckedCreateInput>
    /**
     * In case the ai_interactions was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ai_interactionsUpdateInput, ai_interactionsUncheckedUpdateInput>
  }

  /**
   * ai_interactions delete
   */
  export type ai_interactionsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ai_interactions
     */
    select?: ai_interactionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ai_interactions
     */
    omit?: ai_interactionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ai_interactionsInclude<ExtArgs> | null
    /**
     * Filter which ai_interactions to delete.
     */
    where: ai_interactionsWhereUniqueInput
  }

  /**
   * ai_interactions deleteMany
   */
  export type ai_interactionsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ai_interactions to delete
     */
    where?: ai_interactionsWhereInput
    /**
     * Limit how many ai_interactions to delete.
     */
    limit?: number
  }

  /**
   * ai_interactions.insights
   */
  export type ai_interactions$insightsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ai_insights
     */
    select?: ai_insightsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ai_insights
     */
    omit?: ai_insightsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ai_insightsInclude<ExtArgs> | null
    where?: ai_insightsWhereInput
    orderBy?: ai_insightsOrderByWithRelationInput | ai_insightsOrderByWithRelationInput[]
    cursor?: ai_insightsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Ai_insightsScalarFieldEnum | Ai_insightsScalarFieldEnum[]
  }

  /**
   * ai_interactions without action
   */
  export type ai_interactionsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ai_interactions
     */
    select?: ai_interactionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ai_interactions
     */
    omit?: ai_interactionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ai_interactionsInclude<ExtArgs> | null
  }


  /**
   * Model ai_insights
   */

  export type AggregateAi_insights = {
    _count: Ai_insightsCountAggregateOutputType | null
    _avg: Ai_insightsAvgAggregateOutputType | null
    _sum: Ai_insightsSumAggregateOutputType | null
    _min: Ai_insightsMinAggregateOutputType | null
    _max: Ai_insightsMaxAggregateOutputType | null
  }

  export type Ai_insightsAvgAggregateOutputType = {
    id: number | null
    interaction_id: number | null
    user_id: number | null
    impact_score: number | null
  }

  export type Ai_insightsSumAggregateOutputType = {
    id: number | null
    interaction_id: number | null
    user_id: number | null
    impact_score: number | null
  }

  export type Ai_insightsMinAggregateOutputType = {
    id: number | null
    interaction_id: number | null
    user_id: number | null
    insight_type: string | null
    title: string | null
    description: string | null
    confidence_level: string | null
    impact_score: number | null
    status: string | null
    expires_at: Date | null
    created_at: Date | null
  }

  export type Ai_insightsMaxAggregateOutputType = {
    id: number | null
    interaction_id: number | null
    user_id: number | null
    insight_type: string | null
    title: string | null
    description: string | null
    confidence_level: string | null
    impact_score: number | null
    status: string | null
    expires_at: Date | null
    created_at: Date | null
  }

  export type Ai_insightsCountAggregateOutputType = {
    id: number
    interaction_id: number
    user_id: number
    insight_type: number
    title: number
    description: number
    data_analysis: number
    confidence_level: number
    impact_score: number
    status: number
    expires_at: number
    created_at: number
    _all: number
  }


  export type Ai_insightsAvgAggregateInputType = {
    id?: true
    interaction_id?: true
    user_id?: true
    impact_score?: true
  }

  export type Ai_insightsSumAggregateInputType = {
    id?: true
    interaction_id?: true
    user_id?: true
    impact_score?: true
  }

  export type Ai_insightsMinAggregateInputType = {
    id?: true
    interaction_id?: true
    user_id?: true
    insight_type?: true
    title?: true
    description?: true
    confidence_level?: true
    impact_score?: true
    status?: true
    expires_at?: true
    created_at?: true
  }

  export type Ai_insightsMaxAggregateInputType = {
    id?: true
    interaction_id?: true
    user_id?: true
    insight_type?: true
    title?: true
    description?: true
    confidence_level?: true
    impact_score?: true
    status?: true
    expires_at?: true
    created_at?: true
  }

  export type Ai_insightsCountAggregateInputType = {
    id?: true
    interaction_id?: true
    user_id?: true
    insight_type?: true
    title?: true
    description?: true
    data_analysis?: true
    confidence_level?: true
    impact_score?: true
    status?: true
    expires_at?: true
    created_at?: true
    _all?: true
  }

  export type Ai_insightsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ai_insights to aggregate.
     */
    where?: ai_insightsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ai_insights to fetch.
     */
    orderBy?: ai_insightsOrderByWithRelationInput | ai_insightsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ai_insightsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ai_insights from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ai_insights.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ai_insights
    **/
    _count?: true | Ai_insightsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Ai_insightsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Ai_insightsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Ai_insightsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Ai_insightsMaxAggregateInputType
  }

  export type GetAi_insightsAggregateType<T extends Ai_insightsAggregateArgs> = {
        [P in keyof T & keyof AggregateAi_insights]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAi_insights[P]>
      : GetScalarType<T[P], AggregateAi_insights[P]>
  }




  export type ai_insightsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ai_insightsWhereInput
    orderBy?: ai_insightsOrderByWithAggregationInput | ai_insightsOrderByWithAggregationInput[]
    by: Ai_insightsScalarFieldEnum[] | Ai_insightsScalarFieldEnum
    having?: ai_insightsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Ai_insightsCountAggregateInputType | true
    _avg?: Ai_insightsAvgAggregateInputType
    _sum?: Ai_insightsSumAggregateInputType
    _min?: Ai_insightsMinAggregateInputType
    _max?: Ai_insightsMaxAggregateInputType
  }

  export type Ai_insightsGroupByOutputType = {
    id: number
    interaction_id: number | null
    user_id: number
    insight_type: string
    title: string
    description: string
    data_analysis: JsonValue
    confidence_level: string
    impact_score: number | null
    status: string
    expires_at: Date | null
    created_at: Date
    _count: Ai_insightsCountAggregateOutputType | null
    _avg: Ai_insightsAvgAggregateOutputType | null
    _sum: Ai_insightsSumAggregateOutputType | null
    _min: Ai_insightsMinAggregateOutputType | null
    _max: Ai_insightsMaxAggregateOutputType | null
  }

  type GetAi_insightsGroupByPayload<T extends ai_insightsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Ai_insightsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Ai_insightsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Ai_insightsGroupByOutputType[P]>
            : GetScalarType<T[P], Ai_insightsGroupByOutputType[P]>
        }
      >
    >


  export type ai_insightsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    interaction_id?: boolean
    user_id?: boolean
    insight_type?: boolean
    title?: boolean
    description?: boolean
    data_analysis?: boolean
    confidence_level?: boolean
    impact_score?: boolean
    status?: boolean
    expires_at?: boolean
    created_at?: boolean
    interaction?: boolean | ai_insights$interactionArgs<ExtArgs>
    user?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ai_insights"]>

  export type ai_insightsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    interaction_id?: boolean
    user_id?: boolean
    insight_type?: boolean
    title?: boolean
    description?: boolean
    data_analysis?: boolean
    confidence_level?: boolean
    impact_score?: boolean
    status?: boolean
    expires_at?: boolean
    created_at?: boolean
    interaction?: boolean | ai_insights$interactionArgs<ExtArgs>
    user?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ai_insights"]>

  export type ai_insightsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    interaction_id?: boolean
    user_id?: boolean
    insight_type?: boolean
    title?: boolean
    description?: boolean
    data_analysis?: boolean
    confidence_level?: boolean
    impact_score?: boolean
    status?: boolean
    expires_at?: boolean
    created_at?: boolean
    interaction?: boolean | ai_insights$interactionArgs<ExtArgs>
    user?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ai_insights"]>

  export type ai_insightsSelectScalar = {
    id?: boolean
    interaction_id?: boolean
    user_id?: boolean
    insight_type?: boolean
    title?: boolean
    description?: boolean
    data_analysis?: boolean
    confidence_level?: boolean
    impact_score?: boolean
    status?: boolean
    expires_at?: boolean
    created_at?: boolean
  }

  export type ai_insightsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "interaction_id" | "user_id" | "insight_type" | "title" | "description" | "data_analysis" | "confidence_level" | "impact_score" | "status" | "expires_at" | "created_at", ExtArgs["result"]["ai_insights"]>
  export type ai_insightsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    interaction?: boolean | ai_insights$interactionArgs<ExtArgs>
    user?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type ai_insightsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    interaction?: boolean | ai_insights$interactionArgs<ExtArgs>
    user?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type ai_insightsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    interaction?: boolean | ai_insights$interactionArgs<ExtArgs>
    user?: boolean | usersDefaultArgs<ExtArgs>
  }

  export type $ai_insightsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ai_insights"
    objects: {
      interaction: Prisma.$ai_interactionsPayload<ExtArgs> | null
      user: Prisma.$usersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      interaction_id: number | null
      user_id: number
      insight_type: string
      title: string
      description: string
      data_analysis: Prisma.JsonValue
      confidence_level: string
      impact_score: number | null
      status: string
      expires_at: Date | null
      created_at: Date
    }, ExtArgs["result"]["ai_insights"]>
    composites: {}
  }

  type ai_insightsGetPayload<S extends boolean | null | undefined | ai_insightsDefaultArgs> = $Result.GetResult<Prisma.$ai_insightsPayload, S>

  type ai_insightsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ai_insightsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Ai_insightsCountAggregateInputType | true
    }

  export interface ai_insightsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ai_insights'], meta: { name: 'ai_insights' } }
    /**
     * Find zero or one Ai_insights that matches the filter.
     * @param {ai_insightsFindUniqueArgs} args - Arguments to find a Ai_insights
     * @example
     * // Get one Ai_insights
     * const ai_insights = await prisma.ai_insights.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ai_insightsFindUniqueArgs>(args: SelectSubset<T, ai_insightsFindUniqueArgs<ExtArgs>>): Prisma__ai_insightsClient<$Result.GetResult<Prisma.$ai_insightsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Ai_insights that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ai_insightsFindUniqueOrThrowArgs} args - Arguments to find a Ai_insights
     * @example
     * // Get one Ai_insights
     * const ai_insights = await prisma.ai_insights.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ai_insightsFindUniqueOrThrowArgs>(args: SelectSubset<T, ai_insightsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ai_insightsClient<$Result.GetResult<Prisma.$ai_insightsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Ai_insights that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ai_insightsFindFirstArgs} args - Arguments to find a Ai_insights
     * @example
     * // Get one Ai_insights
     * const ai_insights = await prisma.ai_insights.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ai_insightsFindFirstArgs>(args?: SelectSubset<T, ai_insightsFindFirstArgs<ExtArgs>>): Prisma__ai_insightsClient<$Result.GetResult<Prisma.$ai_insightsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Ai_insights that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ai_insightsFindFirstOrThrowArgs} args - Arguments to find a Ai_insights
     * @example
     * // Get one Ai_insights
     * const ai_insights = await prisma.ai_insights.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ai_insightsFindFirstOrThrowArgs>(args?: SelectSubset<T, ai_insightsFindFirstOrThrowArgs<ExtArgs>>): Prisma__ai_insightsClient<$Result.GetResult<Prisma.$ai_insightsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Ai_insights that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ai_insightsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Ai_insights
     * const ai_insights = await prisma.ai_insights.findMany()
     * 
     * // Get first 10 Ai_insights
     * const ai_insights = await prisma.ai_insights.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ai_insightsWithIdOnly = await prisma.ai_insights.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ai_insightsFindManyArgs>(args?: SelectSubset<T, ai_insightsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ai_insightsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Ai_insights.
     * @param {ai_insightsCreateArgs} args - Arguments to create a Ai_insights.
     * @example
     * // Create one Ai_insights
     * const Ai_insights = await prisma.ai_insights.create({
     *   data: {
     *     // ... data to create a Ai_insights
     *   }
     * })
     * 
     */
    create<T extends ai_insightsCreateArgs>(args: SelectSubset<T, ai_insightsCreateArgs<ExtArgs>>): Prisma__ai_insightsClient<$Result.GetResult<Prisma.$ai_insightsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Ai_insights.
     * @param {ai_insightsCreateManyArgs} args - Arguments to create many Ai_insights.
     * @example
     * // Create many Ai_insights
     * const ai_insights = await prisma.ai_insights.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ai_insightsCreateManyArgs>(args?: SelectSubset<T, ai_insightsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Ai_insights and returns the data saved in the database.
     * @param {ai_insightsCreateManyAndReturnArgs} args - Arguments to create many Ai_insights.
     * @example
     * // Create many Ai_insights
     * const ai_insights = await prisma.ai_insights.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Ai_insights and only return the `id`
     * const ai_insightsWithIdOnly = await prisma.ai_insights.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ai_insightsCreateManyAndReturnArgs>(args?: SelectSubset<T, ai_insightsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ai_insightsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Ai_insights.
     * @param {ai_insightsDeleteArgs} args - Arguments to delete one Ai_insights.
     * @example
     * // Delete one Ai_insights
     * const Ai_insights = await prisma.ai_insights.delete({
     *   where: {
     *     // ... filter to delete one Ai_insights
     *   }
     * })
     * 
     */
    delete<T extends ai_insightsDeleteArgs>(args: SelectSubset<T, ai_insightsDeleteArgs<ExtArgs>>): Prisma__ai_insightsClient<$Result.GetResult<Prisma.$ai_insightsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Ai_insights.
     * @param {ai_insightsUpdateArgs} args - Arguments to update one Ai_insights.
     * @example
     * // Update one Ai_insights
     * const ai_insights = await prisma.ai_insights.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ai_insightsUpdateArgs>(args: SelectSubset<T, ai_insightsUpdateArgs<ExtArgs>>): Prisma__ai_insightsClient<$Result.GetResult<Prisma.$ai_insightsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Ai_insights.
     * @param {ai_insightsDeleteManyArgs} args - Arguments to filter Ai_insights to delete.
     * @example
     * // Delete a few Ai_insights
     * const { count } = await prisma.ai_insights.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ai_insightsDeleteManyArgs>(args?: SelectSubset<T, ai_insightsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ai_insights.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ai_insightsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Ai_insights
     * const ai_insights = await prisma.ai_insights.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ai_insightsUpdateManyArgs>(args: SelectSubset<T, ai_insightsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ai_insights and returns the data updated in the database.
     * @param {ai_insightsUpdateManyAndReturnArgs} args - Arguments to update many Ai_insights.
     * @example
     * // Update many Ai_insights
     * const ai_insights = await prisma.ai_insights.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Ai_insights and only return the `id`
     * const ai_insightsWithIdOnly = await prisma.ai_insights.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ai_insightsUpdateManyAndReturnArgs>(args: SelectSubset<T, ai_insightsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ai_insightsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Ai_insights.
     * @param {ai_insightsUpsertArgs} args - Arguments to update or create a Ai_insights.
     * @example
     * // Update or create a Ai_insights
     * const ai_insights = await prisma.ai_insights.upsert({
     *   create: {
     *     // ... data to create a Ai_insights
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Ai_insights we want to update
     *   }
     * })
     */
    upsert<T extends ai_insightsUpsertArgs>(args: SelectSubset<T, ai_insightsUpsertArgs<ExtArgs>>): Prisma__ai_insightsClient<$Result.GetResult<Prisma.$ai_insightsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Ai_insights.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ai_insightsCountArgs} args - Arguments to filter Ai_insights to count.
     * @example
     * // Count the number of Ai_insights
     * const count = await prisma.ai_insights.count({
     *   where: {
     *     // ... the filter for the Ai_insights we want to count
     *   }
     * })
    **/
    count<T extends ai_insightsCountArgs>(
      args?: Subset<T, ai_insightsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Ai_insightsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Ai_insights.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Ai_insightsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Ai_insightsAggregateArgs>(args: Subset<T, Ai_insightsAggregateArgs>): Prisma.PrismaPromise<GetAi_insightsAggregateType<T>>

    /**
     * Group by Ai_insights.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ai_insightsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ai_insightsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ai_insightsGroupByArgs['orderBy'] }
        : { orderBy?: ai_insightsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ai_insightsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAi_insightsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ai_insights model
   */
  readonly fields: ai_insightsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ai_insights.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ai_insightsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    interaction<T extends ai_insights$interactionArgs<ExtArgs> = {}>(args?: Subset<T, ai_insights$interactionArgs<ExtArgs>>): Prisma__ai_interactionsClient<$Result.GetResult<Prisma.$ai_interactionsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    user<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ai_insights model
   */
  interface ai_insightsFieldRefs {
    readonly id: FieldRef<"ai_insights", 'Int'>
    readonly interaction_id: FieldRef<"ai_insights", 'Int'>
    readonly user_id: FieldRef<"ai_insights", 'Int'>
    readonly insight_type: FieldRef<"ai_insights", 'String'>
    readonly title: FieldRef<"ai_insights", 'String'>
    readonly description: FieldRef<"ai_insights", 'String'>
    readonly data_analysis: FieldRef<"ai_insights", 'Json'>
    readonly confidence_level: FieldRef<"ai_insights", 'String'>
    readonly impact_score: FieldRef<"ai_insights", 'Float'>
    readonly status: FieldRef<"ai_insights", 'String'>
    readonly expires_at: FieldRef<"ai_insights", 'DateTime'>
    readonly created_at: FieldRef<"ai_insights", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ai_insights findUnique
   */
  export type ai_insightsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ai_insights
     */
    select?: ai_insightsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ai_insights
     */
    omit?: ai_insightsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ai_insightsInclude<ExtArgs> | null
    /**
     * Filter, which ai_insights to fetch.
     */
    where: ai_insightsWhereUniqueInput
  }

  /**
   * ai_insights findUniqueOrThrow
   */
  export type ai_insightsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ai_insights
     */
    select?: ai_insightsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ai_insights
     */
    omit?: ai_insightsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ai_insightsInclude<ExtArgs> | null
    /**
     * Filter, which ai_insights to fetch.
     */
    where: ai_insightsWhereUniqueInput
  }

  /**
   * ai_insights findFirst
   */
  export type ai_insightsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ai_insights
     */
    select?: ai_insightsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ai_insights
     */
    omit?: ai_insightsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ai_insightsInclude<ExtArgs> | null
    /**
     * Filter, which ai_insights to fetch.
     */
    where?: ai_insightsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ai_insights to fetch.
     */
    orderBy?: ai_insightsOrderByWithRelationInput | ai_insightsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ai_insights.
     */
    cursor?: ai_insightsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ai_insights from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ai_insights.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ai_insights.
     */
    distinct?: Ai_insightsScalarFieldEnum | Ai_insightsScalarFieldEnum[]
  }

  /**
   * ai_insights findFirstOrThrow
   */
  export type ai_insightsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ai_insights
     */
    select?: ai_insightsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ai_insights
     */
    omit?: ai_insightsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ai_insightsInclude<ExtArgs> | null
    /**
     * Filter, which ai_insights to fetch.
     */
    where?: ai_insightsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ai_insights to fetch.
     */
    orderBy?: ai_insightsOrderByWithRelationInput | ai_insightsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ai_insights.
     */
    cursor?: ai_insightsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ai_insights from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ai_insights.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ai_insights.
     */
    distinct?: Ai_insightsScalarFieldEnum | Ai_insightsScalarFieldEnum[]
  }

  /**
   * ai_insights findMany
   */
  export type ai_insightsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ai_insights
     */
    select?: ai_insightsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ai_insights
     */
    omit?: ai_insightsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ai_insightsInclude<ExtArgs> | null
    /**
     * Filter, which ai_insights to fetch.
     */
    where?: ai_insightsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ai_insights to fetch.
     */
    orderBy?: ai_insightsOrderByWithRelationInput | ai_insightsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ai_insights.
     */
    cursor?: ai_insightsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ai_insights from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ai_insights.
     */
    skip?: number
    distinct?: Ai_insightsScalarFieldEnum | Ai_insightsScalarFieldEnum[]
  }

  /**
   * ai_insights create
   */
  export type ai_insightsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ai_insights
     */
    select?: ai_insightsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ai_insights
     */
    omit?: ai_insightsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ai_insightsInclude<ExtArgs> | null
    /**
     * The data needed to create a ai_insights.
     */
    data: XOR<ai_insightsCreateInput, ai_insightsUncheckedCreateInput>
  }

  /**
   * ai_insights createMany
   */
  export type ai_insightsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ai_insights.
     */
    data: ai_insightsCreateManyInput | ai_insightsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ai_insights createManyAndReturn
   */
  export type ai_insightsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ai_insights
     */
    select?: ai_insightsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ai_insights
     */
    omit?: ai_insightsOmit<ExtArgs> | null
    /**
     * The data used to create many ai_insights.
     */
    data: ai_insightsCreateManyInput | ai_insightsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ai_insightsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ai_insights update
   */
  export type ai_insightsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ai_insights
     */
    select?: ai_insightsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ai_insights
     */
    omit?: ai_insightsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ai_insightsInclude<ExtArgs> | null
    /**
     * The data needed to update a ai_insights.
     */
    data: XOR<ai_insightsUpdateInput, ai_insightsUncheckedUpdateInput>
    /**
     * Choose, which ai_insights to update.
     */
    where: ai_insightsWhereUniqueInput
  }

  /**
   * ai_insights updateMany
   */
  export type ai_insightsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ai_insights.
     */
    data: XOR<ai_insightsUpdateManyMutationInput, ai_insightsUncheckedUpdateManyInput>
    /**
     * Filter which ai_insights to update
     */
    where?: ai_insightsWhereInput
    /**
     * Limit how many ai_insights to update.
     */
    limit?: number
  }

  /**
   * ai_insights updateManyAndReturn
   */
  export type ai_insightsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ai_insights
     */
    select?: ai_insightsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ai_insights
     */
    omit?: ai_insightsOmit<ExtArgs> | null
    /**
     * The data used to update ai_insights.
     */
    data: XOR<ai_insightsUpdateManyMutationInput, ai_insightsUncheckedUpdateManyInput>
    /**
     * Filter which ai_insights to update
     */
    where?: ai_insightsWhereInput
    /**
     * Limit how many ai_insights to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ai_insightsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ai_insights upsert
   */
  export type ai_insightsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ai_insights
     */
    select?: ai_insightsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ai_insights
     */
    omit?: ai_insightsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ai_insightsInclude<ExtArgs> | null
    /**
     * The filter to search for the ai_insights to update in case it exists.
     */
    where: ai_insightsWhereUniqueInput
    /**
     * In case the ai_insights found by the `where` argument doesn't exist, create a new ai_insights with this data.
     */
    create: XOR<ai_insightsCreateInput, ai_insightsUncheckedCreateInput>
    /**
     * In case the ai_insights was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ai_insightsUpdateInput, ai_insightsUncheckedUpdateInput>
  }

  /**
   * ai_insights delete
   */
  export type ai_insightsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ai_insights
     */
    select?: ai_insightsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ai_insights
     */
    omit?: ai_insightsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ai_insightsInclude<ExtArgs> | null
    /**
     * Filter which ai_insights to delete.
     */
    where: ai_insightsWhereUniqueInput
  }

  /**
   * ai_insights deleteMany
   */
  export type ai_insightsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ai_insights to delete
     */
    where?: ai_insightsWhereInput
    /**
     * Limit how many ai_insights to delete.
     */
    limit?: number
  }

  /**
   * ai_insights.interaction
   */
  export type ai_insights$interactionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ai_interactions
     */
    select?: ai_interactionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ai_interactions
     */
    omit?: ai_interactionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ai_interactionsInclude<ExtArgs> | null
    where?: ai_interactionsWhereInput
  }

  /**
   * ai_insights without action
   */
  export type ai_insightsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ai_insights
     */
    select?: ai_insightsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ai_insights
     */
    omit?: ai_insightsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ai_insightsInclude<ExtArgs> | null
  }


  /**
   * Model ai_fallbacks
   */

  export type AggregateAi_fallbacks = {
    _count: Ai_fallbacksCountAggregateOutputType | null
    _avg: Ai_fallbacksAvgAggregateOutputType | null
    _sum: Ai_fallbacksSumAggregateOutputType | null
    _min: Ai_fallbacksMinAggregateOutputType | null
    _max: Ai_fallbacksMaxAggregateOutputType | null
  }

  export type Ai_fallbacksAvgAggregateOutputType = {
    id: number | null
    escalation_level: number | null
    usage_count: number | null
  }

  export type Ai_fallbacksSumAggregateOutputType = {
    id: number | null
    escalation_level: number | null
    usage_count: number | null
  }

  export type Ai_fallbacksMinAggregateOutputType = {
    id: number | null
    trigger_pattern: string | null
    fallback_type: string | null
    response_template: string | null
    escalation_level: number | null
    is_active: boolean | null
    usage_count: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Ai_fallbacksMaxAggregateOutputType = {
    id: number | null
    trigger_pattern: string | null
    fallback_type: string | null
    response_template: string | null
    escalation_level: number | null
    is_active: boolean | null
    usage_count: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Ai_fallbacksCountAggregateOutputType = {
    id: number
    trigger_pattern: number
    fallback_type: number
    response_template: number
    escalation_level: number
    is_active: number
    usage_count: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type Ai_fallbacksAvgAggregateInputType = {
    id?: true
    escalation_level?: true
    usage_count?: true
  }

  export type Ai_fallbacksSumAggregateInputType = {
    id?: true
    escalation_level?: true
    usage_count?: true
  }

  export type Ai_fallbacksMinAggregateInputType = {
    id?: true
    trigger_pattern?: true
    fallback_type?: true
    response_template?: true
    escalation_level?: true
    is_active?: true
    usage_count?: true
    created_at?: true
    updated_at?: true
  }

  export type Ai_fallbacksMaxAggregateInputType = {
    id?: true
    trigger_pattern?: true
    fallback_type?: true
    response_template?: true
    escalation_level?: true
    is_active?: true
    usage_count?: true
    created_at?: true
    updated_at?: true
  }

  export type Ai_fallbacksCountAggregateInputType = {
    id?: true
    trigger_pattern?: true
    fallback_type?: true
    response_template?: true
    escalation_level?: true
    is_active?: true
    usage_count?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type Ai_fallbacksAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ai_fallbacks to aggregate.
     */
    where?: ai_fallbacksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ai_fallbacks to fetch.
     */
    orderBy?: ai_fallbacksOrderByWithRelationInput | ai_fallbacksOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ai_fallbacksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ai_fallbacks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ai_fallbacks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ai_fallbacks
    **/
    _count?: true | Ai_fallbacksCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Ai_fallbacksAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Ai_fallbacksSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Ai_fallbacksMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Ai_fallbacksMaxAggregateInputType
  }

  export type GetAi_fallbacksAggregateType<T extends Ai_fallbacksAggregateArgs> = {
        [P in keyof T & keyof AggregateAi_fallbacks]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAi_fallbacks[P]>
      : GetScalarType<T[P], AggregateAi_fallbacks[P]>
  }




  export type ai_fallbacksGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ai_fallbacksWhereInput
    orderBy?: ai_fallbacksOrderByWithAggregationInput | ai_fallbacksOrderByWithAggregationInput[]
    by: Ai_fallbacksScalarFieldEnum[] | Ai_fallbacksScalarFieldEnum
    having?: ai_fallbacksScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Ai_fallbacksCountAggregateInputType | true
    _avg?: Ai_fallbacksAvgAggregateInputType
    _sum?: Ai_fallbacksSumAggregateInputType
    _min?: Ai_fallbacksMinAggregateInputType
    _max?: Ai_fallbacksMaxAggregateInputType
  }

  export type Ai_fallbacksGroupByOutputType = {
    id: number
    trigger_pattern: string
    fallback_type: string
    response_template: string
    escalation_level: number
    is_active: boolean
    usage_count: number
    created_at: Date
    updated_at: Date
    _count: Ai_fallbacksCountAggregateOutputType | null
    _avg: Ai_fallbacksAvgAggregateOutputType | null
    _sum: Ai_fallbacksSumAggregateOutputType | null
    _min: Ai_fallbacksMinAggregateOutputType | null
    _max: Ai_fallbacksMaxAggregateOutputType | null
  }

  type GetAi_fallbacksGroupByPayload<T extends ai_fallbacksGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Ai_fallbacksGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Ai_fallbacksGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Ai_fallbacksGroupByOutputType[P]>
            : GetScalarType<T[P], Ai_fallbacksGroupByOutputType[P]>
        }
      >
    >


  export type ai_fallbacksSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    trigger_pattern?: boolean
    fallback_type?: boolean
    response_template?: boolean
    escalation_level?: boolean
    is_active?: boolean
    usage_count?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["ai_fallbacks"]>

  export type ai_fallbacksSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    trigger_pattern?: boolean
    fallback_type?: boolean
    response_template?: boolean
    escalation_level?: boolean
    is_active?: boolean
    usage_count?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["ai_fallbacks"]>

  export type ai_fallbacksSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    trigger_pattern?: boolean
    fallback_type?: boolean
    response_template?: boolean
    escalation_level?: boolean
    is_active?: boolean
    usage_count?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["ai_fallbacks"]>

  export type ai_fallbacksSelectScalar = {
    id?: boolean
    trigger_pattern?: boolean
    fallback_type?: boolean
    response_template?: boolean
    escalation_level?: boolean
    is_active?: boolean
    usage_count?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type ai_fallbacksOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "trigger_pattern" | "fallback_type" | "response_template" | "escalation_level" | "is_active" | "usage_count" | "created_at" | "updated_at", ExtArgs["result"]["ai_fallbacks"]>

  export type $ai_fallbacksPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ai_fallbacks"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      trigger_pattern: string
      fallback_type: string
      response_template: string
      escalation_level: number
      is_active: boolean
      usage_count: number
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["ai_fallbacks"]>
    composites: {}
  }

  type ai_fallbacksGetPayload<S extends boolean | null | undefined | ai_fallbacksDefaultArgs> = $Result.GetResult<Prisma.$ai_fallbacksPayload, S>

  type ai_fallbacksCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ai_fallbacksFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Ai_fallbacksCountAggregateInputType | true
    }

  export interface ai_fallbacksDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ai_fallbacks'], meta: { name: 'ai_fallbacks' } }
    /**
     * Find zero or one Ai_fallbacks that matches the filter.
     * @param {ai_fallbacksFindUniqueArgs} args - Arguments to find a Ai_fallbacks
     * @example
     * // Get one Ai_fallbacks
     * const ai_fallbacks = await prisma.ai_fallbacks.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ai_fallbacksFindUniqueArgs>(args: SelectSubset<T, ai_fallbacksFindUniqueArgs<ExtArgs>>): Prisma__ai_fallbacksClient<$Result.GetResult<Prisma.$ai_fallbacksPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Ai_fallbacks that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ai_fallbacksFindUniqueOrThrowArgs} args - Arguments to find a Ai_fallbacks
     * @example
     * // Get one Ai_fallbacks
     * const ai_fallbacks = await prisma.ai_fallbacks.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ai_fallbacksFindUniqueOrThrowArgs>(args: SelectSubset<T, ai_fallbacksFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ai_fallbacksClient<$Result.GetResult<Prisma.$ai_fallbacksPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Ai_fallbacks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ai_fallbacksFindFirstArgs} args - Arguments to find a Ai_fallbacks
     * @example
     * // Get one Ai_fallbacks
     * const ai_fallbacks = await prisma.ai_fallbacks.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ai_fallbacksFindFirstArgs>(args?: SelectSubset<T, ai_fallbacksFindFirstArgs<ExtArgs>>): Prisma__ai_fallbacksClient<$Result.GetResult<Prisma.$ai_fallbacksPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Ai_fallbacks that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ai_fallbacksFindFirstOrThrowArgs} args - Arguments to find a Ai_fallbacks
     * @example
     * // Get one Ai_fallbacks
     * const ai_fallbacks = await prisma.ai_fallbacks.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ai_fallbacksFindFirstOrThrowArgs>(args?: SelectSubset<T, ai_fallbacksFindFirstOrThrowArgs<ExtArgs>>): Prisma__ai_fallbacksClient<$Result.GetResult<Prisma.$ai_fallbacksPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Ai_fallbacks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ai_fallbacksFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Ai_fallbacks
     * const ai_fallbacks = await prisma.ai_fallbacks.findMany()
     * 
     * // Get first 10 Ai_fallbacks
     * const ai_fallbacks = await prisma.ai_fallbacks.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ai_fallbacksWithIdOnly = await prisma.ai_fallbacks.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ai_fallbacksFindManyArgs>(args?: SelectSubset<T, ai_fallbacksFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ai_fallbacksPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Ai_fallbacks.
     * @param {ai_fallbacksCreateArgs} args - Arguments to create a Ai_fallbacks.
     * @example
     * // Create one Ai_fallbacks
     * const Ai_fallbacks = await prisma.ai_fallbacks.create({
     *   data: {
     *     // ... data to create a Ai_fallbacks
     *   }
     * })
     * 
     */
    create<T extends ai_fallbacksCreateArgs>(args: SelectSubset<T, ai_fallbacksCreateArgs<ExtArgs>>): Prisma__ai_fallbacksClient<$Result.GetResult<Prisma.$ai_fallbacksPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Ai_fallbacks.
     * @param {ai_fallbacksCreateManyArgs} args - Arguments to create many Ai_fallbacks.
     * @example
     * // Create many Ai_fallbacks
     * const ai_fallbacks = await prisma.ai_fallbacks.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ai_fallbacksCreateManyArgs>(args?: SelectSubset<T, ai_fallbacksCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Ai_fallbacks and returns the data saved in the database.
     * @param {ai_fallbacksCreateManyAndReturnArgs} args - Arguments to create many Ai_fallbacks.
     * @example
     * // Create many Ai_fallbacks
     * const ai_fallbacks = await prisma.ai_fallbacks.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Ai_fallbacks and only return the `id`
     * const ai_fallbacksWithIdOnly = await prisma.ai_fallbacks.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ai_fallbacksCreateManyAndReturnArgs>(args?: SelectSubset<T, ai_fallbacksCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ai_fallbacksPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Ai_fallbacks.
     * @param {ai_fallbacksDeleteArgs} args - Arguments to delete one Ai_fallbacks.
     * @example
     * // Delete one Ai_fallbacks
     * const Ai_fallbacks = await prisma.ai_fallbacks.delete({
     *   where: {
     *     // ... filter to delete one Ai_fallbacks
     *   }
     * })
     * 
     */
    delete<T extends ai_fallbacksDeleteArgs>(args: SelectSubset<T, ai_fallbacksDeleteArgs<ExtArgs>>): Prisma__ai_fallbacksClient<$Result.GetResult<Prisma.$ai_fallbacksPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Ai_fallbacks.
     * @param {ai_fallbacksUpdateArgs} args - Arguments to update one Ai_fallbacks.
     * @example
     * // Update one Ai_fallbacks
     * const ai_fallbacks = await prisma.ai_fallbacks.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ai_fallbacksUpdateArgs>(args: SelectSubset<T, ai_fallbacksUpdateArgs<ExtArgs>>): Prisma__ai_fallbacksClient<$Result.GetResult<Prisma.$ai_fallbacksPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Ai_fallbacks.
     * @param {ai_fallbacksDeleteManyArgs} args - Arguments to filter Ai_fallbacks to delete.
     * @example
     * // Delete a few Ai_fallbacks
     * const { count } = await prisma.ai_fallbacks.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ai_fallbacksDeleteManyArgs>(args?: SelectSubset<T, ai_fallbacksDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ai_fallbacks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ai_fallbacksUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Ai_fallbacks
     * const ai_fallbacks = await prisma.ai_fallbacks.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ai_fallbacksUpdateManyArgs>(args: SelectSubset<T, ai_fallbacksUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ai_fallbacks and returns the data updated in the database.
     * @param {ai_fallbacksUpdateManyAndReturnArgs} args - Arguments to update many Ai_fallbacks.
     * @example
     * // Update many Ai_fallbacks
     * const ai_fallbacks = await prisma.ai_fallbacks.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Ai_fallbacks and only return the `id`
     * const ai_fallbacksWithIdOnly = await prisma.ai_fallbacks.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ai_fallbacksUpdateManyAndReturnArgs>(args: SelectSubset<T, ai_fallbacksUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ai_fallbacksPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Ai_fallbacks.
     * @param {ai_fallbacksUpsertArgs} args - Arguments to update or create a Ai_fallbacks.
     * @example
     * // Update or create a Ai_fallbacks
     * const ai_fallbacks = await prisma.ai_fallbacks.upsert({
     *   create: {
     *     // ... data to create a Ai_fallbacks
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Ai_fallbacks we want to update
     *   }
     * })
     */
    upsert<T extends ai_fallbacksUpsertArgs>(args: SelectSubset<T, ai_fallbacksUpsertArgs<ExtArgs>>): Prisma__ai_fallbacksClient<$Result.GetResult<Prisma.$ai_fallbacksPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Ai_fallbacks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ai_fallbacksCountArgs} args - Arguments to filter Ai_fallbacks to count.
     * @example
     * // Count the number of Ai_fallbacks
     * const count = await prisma.ai_fallbacks.count({
     *   where: {
     *     // ... the filter for the Ai_fallbacks we want to count
     *   }
     * })
    **/
    count<T extends ai_fallbacksCountArgs>(
      args?: Subset<T, ai_fallbacksCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Ai_fallbacksCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Ai_fallbacks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Ai_fallbacksAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Ai_fallbacksAggregateArgs>(args: Subset<T, Ai_fallbacksAggregateArgs>): Prisma.PrismaPromise<GetAi_fallbacksAggregateType<T>>

    /**
     * Group by Ai_fallbacks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ai_fallbacksGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ai_fallbacksGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ai_fallbacksGroupByArgs['orderBy'] }
        : { orderBy?: ai_fallbacksGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ai_fallbacksGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAi_fallbacksGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ai_fallbacks model
   */
  readonly fields: ai_fallbacksFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ai_fallbacks.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ai_fallbacksClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ai_fallbacks model
   */
  interface ai_fallbacksFieldRefs {
    readonly id: FieldRef<"ai_fallbacks", 'Int'>
    readonly trigger_pattern: FieldRef<"ai_fallbacks", 'String'>
    readonly fallback_type: FieldRef<"ai_fallbacks", 'String'>
    readonly response_template: FieldRef<"ai_fallbacks", 'String'>
    readonly escalation_level: FieldRef<"ai_fallbacks", 'Int'>
    readonly is_active: FieldRef<"ai_fallbacks", 'Boolean'>
    readonly usage_count: FieldRef<"ai_fallbacks", 'Int'>
    readonly created_at: FieldRef<"ai_fallbacks", 'DateTime'>
    readonly updated_at: FieldRef<"ai_fallbacks", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ai_fallbacks findUnique
   */
  export type ai_fallbacksFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ai_fallbacks
     */
    select?: ai_fallbacksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ai_fallbacks
     */
    omit?: ai_fallbacksOmit<ExtArgs> | null
    /**
     * Filter, which ai_fallbacks to fetch.
     */
    where: ai_fallbacksWhereUniqueInput
  }

  /**
   * ai_fallbacks findUniqueOrThrow
   */
  export type ai_fallbacksFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ai_fallbacks
     */
    select?: ai_fallbacksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ai_fallbacks
     */
    omit?: ai_fallbacksOmit<ExtArgs> | null
    /**
     * Filter, which ai_fallbacks to fetch.
     */
    where: ai_fallbacksWhereUniqueInput
  }

  /**
   * ai_fallbacks findFirst
   */
  export type ai_fallbacksFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ai_fallbacks
     */
    select?: ai_fallbacksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ai_fallbacks
     */
    omit?: ai_fallbacksOmit<ExtArgs> | null
    /**
     * Filter, which ai_fallbacks to fetch.
     */
    where?: ai_fallbacksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ai_fallbacks to fetch.
     */
    orderBy?: ai_fallbacksOrderByWithRelationInput | ai_fallbacksOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ai_fallbacks.
     */
    cursor?: ai_fallbacksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ai_fallbacks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ai_fallbacks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ai_fallbacks.
     */
    distinct?: Ai_fallbacksScalarFieldEnum | Ai_fallbacksScalarFieldEnum[]
  }

  /**
   * ai_fallbacks findFirstOrThrow
   */
  export type ai_fallbacksFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ai_fallbacks
     */
    select?: ai_fallbacksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ai_fallbacks
     */
    omit?: ai_fallbacksOmit<ExtArgs> | null
    /**
     * Filter, which ai_fallbacks to fetch.
     */
    where?: ai_fallbacksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ai_fallbacks to fetch.
     */
    orderBy?: ai_fallbacksOrderByWithRelationInput | ai_fallbacksOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ai_fallbacks.
     */
    cursor?: ai_fallbacksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ai_fallbacks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ai_fallbacks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ai_fallbacks.
     */
    distinct?: Ai_fallbacksScalarFieldEnum | Ai_fallbacksScalarFieldEnum[]
  }

  /**
   * ai_fallbacks findMany
   */
  export type ai_fallbacksFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ai_fallbacks
     */
    select?: ai_fallbacksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ai_fallbacks
     */
    omit?: ai_fallbacksOmit<ExtArgs> | null
    /**
     * Filter, which ai_fallbacks to fetch.
     */
    where?: ai_fallbacksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ai_fallbacks to fetch.
     */
    orderBy?: ai_fallbacksOrderByWithRelationInput | ai_fallbacksOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ai_fallbacks.
     */
    cursor?: ai_fallbacksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ai_fallbacks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ai_fallbacks.
     */
    skip?: number
    distinct?: Ai_fallbacksScalarFieldEnum | Ai_fallbacksScalarFieldEnum[]
  }

  /**
   * ai_fallbacks create
   */
  export type ai_fallbacksCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ai_fallbacks
     */
    select?: ai_fallbacksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ai_fallbacks
     */
    omit?: ai_fallbacksOmit<ExtArgs> | null
    /**
     * The data needed to create a ai_fallbacks.
     */
    data: XOR<ai_fallbacksCreateInput, ai_fallbacksUncheckedCreateInput>
  }

  /**
   * ai_fallbacks createMany
   */
  export type ai_fallbacksCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ai_fallbacks.
     */
    data: ai_fallbacksCreateManyInput | ai_fallbacksCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ai_fallbacks createManyAndReturn
   */
  export type ai_fallbacksCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ai_fallbacks
     */
    select?: ai_fallbacksSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ai_fallbacks
     */
    omit?: ai_fallbacksOmit<ExtArgs> | null
    /**
     * The data used to create many ai_fallbacks.
     */
    data: ai_fallbacksCreateManyInput | ai_fallbacksCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ai_fallbacks update
   */
  export type ai_fallbacksUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ai_fallbacks
     */
    select?: ai_fallbacksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ai_fallbacks
     */
    omit?: ai_fallbacksOmit<ExtArgs> | null
    /**
     * The data needed to update a ai_fallbacks.
     */
    data: XOR<ai_fallbacksUpdateInput, ai_fallbacksUncheckedUpdateInput>
    /**
     * Choose, which ai_fallbacks to update.
     */
    where: ai_fallbacksWhereUniqueInput
  }

  /**
   * ai_fallbacks updateMany
   */
  export type ai_fallbacksUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ai_fallbacks.
     */
    data: XOR<ai_fallbacksUpdateManyMutationInput, ai_fallbacksUncheckedUpdateManyInput>
    /**
     * Filter which ai_fallbacks to update
     */
    where?: ai_fallbacksWhereInput
    /**
     * Limit how many ai_fallbacks to update.
     */
    limit?: number
  }

  /**
   * ai_fallbacks updateManyAndReturn
   */
  export type ai_fallbacksUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ai_fallbacks
     */
    select?: ai_fallbacksSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ai_fallbacks
     */
    omit?: ai_fallbacksOmit<ExtArgs> | null
    /**
     * The data used to update ai_fallbacks.
     */
    data: XOR<ai_fallbacksUpdateManyMutationInput, ai_fallbacksUncheckedUpdateManyInput>
    /**
     * Filter which ai_fallbacks to update
     */
    where?: ai_fallbacksWhereInput
    /**
     * Limit how many ai_fallbacks to update.
     */
    limit?: number
  }

  /**
   * ai_fallbacks upsert
   */
  export type ai_fallbacksUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ai_fallbacks
     */
    select?: ai_fallbacksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ai_fallbacks
     */
    omit?: ai_fallbacksOmit<ExtArgs> | null
    /**
     * The filter to search for the ai_fallbacks to update in case it exists.
     */
    where: ai_fallbacksWhereUniqueInput
    /**
     * In case the ai_fallbacks found by the `where` argument doesn't exist, create a new ai_fallbacks with this data.
     */
    create: XOR<ai_fallbacksCreateInput, ai_fallbacksUncheckedCreateInput>
    /**
     * In case the ai_fallbacks was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ai_fallbacksUpdateInput, ai_fallbacksUncheckedUpdateInput>
  }

  /**
   * ai_fallbacks delete
   */
  export type ai_fallbacksDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ai_fallbacks
     */
    select?: ai_fallbacksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ai_fallbacks
     */
    omit?: ai_fallbacksOmit<ExtArgs> | null
    /**
     * Filter which ai_fallbacks to delete.
     */
    where: ai_fallbacksWhereUniqueInput
  }

  /**
   * ai_fallbacks deleteMany
   */
  export type ai_fallbacksDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ai_fallbacks to delete
     */
    where?: ai_fallbacksWhereInput
    /**
     * Limit how many ai_fallbacks to delete.
     */
    limit?: number
  }

  /**
   * ai_fallbacks without action
   */
  export type ai_fallbacksDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ai_fallbacks
     */
    select?: ai_fallbacksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ai_fallbacks
     */
    omit?: ai_fallbacksOmit<ExtArgs> | null
  }


  /**
   * Model ai_response_cache
   */

  export type AggregateAi_response_cache = {
    _count: Ai_response_cacheCountAggregateOutputType | null
    _avg: Ai_response_cacheAvgAggregateOutputType | null
    _sum: Ai_response_cacheSumAggregateOutputType | null
    _min: Ai_response_cacheMinAggregateOutputType | null
    _max: Ai_response_cacheMaxAggregateOutputType | null
  }

  export type Ai_response_cacheAvgAggregateOutputType = {
    id: number | null
    hit_count: number | null
  }

  export type Ai_response_cacheSumAggregateOutputType = {
    id: number | null
    hit_count: number | null
  }

  export type Ai_response_cacheMinAggregateOutputType = {
    id: number | null
    input_hash: string | null
    input_text: string | null
    interaction_type: string | null
    hit_count: number | null
    expires_at: Date | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Ai_response_cacheMaxAggregateOutputType = {
    id: number | null
    input_hash: string | null
    input_text: string | null
    interaction_type: string | null
    hit_count: number | null
    expires_at: Date | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Ai_response_cacheCountAggregateOutputType = {
    id: number
    input_hash: number
    input_text: number
    response_data: number
    interaction_type: number
    hit_count: number
    expires_at: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type Ai_response_cacheAvgAggregateInputType = {
    id?: true
    hit_count?: true
  }

  export type Ai_response_cacheSumAggregateInputType = {
    id?: true
    hit_count?: true
  }

  export type Ai_response_cacheMinAggregateInputType = {
    id?: true
    input_hash?: true
    input_text?: true
    interaction_type?: true
    hit_count?: true
    expires_at?: true
    created_at?: true
    updated_at?: true
  }

  export type Ai_response_cacheMaxAggregateInputType = {
    id?: true
    input_hash?: true
    input_text?: true
    interaction_type?: true
    hit_count?: true
    expires_at?: true
    created_at?: true
    updated_at?: true
  }

  export type Ai_response_cacheCountAggregateInputType = {
    id?: true
    input_hash?: true
    input_text?: true
    response_data?: true
    interaction_type?: true
    hit_count?: true
    expires_at?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type Ai_response_cacheAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ai_response_cache to aggregate.
     */
    where?: ai_response_cacheWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ai_response_caches to fetch.
     */
    orderBy?: ai_response_cacheOrderByWithRelationInput | ai_response_cacheOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ai_response_cacheWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ai_response_caches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ai_response_caches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ai_response_caches
    **/
    _count?: true | Ai_response_cacheCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Ai_response_cacheAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Ai_response_cacheSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Ai_response_cacheMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Ai_response_cacheMaxAggregateInputType
  }

  export type GetAi_response_cacheAggregateType<T extends Ai_response_cacheAggregateArgs> = {
        [P in keyof T & keyof AggregateAi_response_cache]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAi_response_cache[P]>
      : GetScalarType<T[P], AggregateAi_response_cache[P]>
  }




  export type ai_response_cacheGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ai_response_cacheWhereInput
    orderBy?: ai_response_cacheOrderByWithAggregationInput | ai_response_cacheOrderByWithAggregationInput[]
    by: Ai_response_cacheScalarFieldEnum[] | Ai_response_cacheScalarFieldEnum
    having?: ai_response_cacheScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Ai_response_cacheCountAggregateInputType | true
    _avg?: Ai_response_cacheAvgAggregateInputType
    _sum?: Ai_response_cacheSumAggregateInputType
    _min?: Ai_response_cacheMinAggregateInputType
    _max?: Ai_response_cacheMaxAggregateInputType
  }

  export type Ai_response_cacheGroupByOutputType = {
    id: number
    input_hash: string
    input_text: string
    response_data: JsonValue
    interaction_type: string
    hit_count: number
    expires_at: Date
    created_at: Date
    updated_at: Date
    _count: Ai_response_cacheCountAggregateOutputType | null
    _avg: Ai_response_cacheAvgAggregateOutputType | null
    _sum: Ai_response_cacheSumAggregateOutputType | null
    _min: Ai_response_cacheMinAggregateOutputType | null
    _max: Ai_response_cacheMaxAggregateOutputType | null
  }

  type GetAi_response_cacheGroupByPayload<T extends ai_response_cacheGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Ai_response_cacheGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Ai_response_cacheGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Ai_response_cacheGroupByOutputType[P]>
            : GetScalarType<T[P], Ai_response_cacheGroupByOutputType[P]>
        }
      >
    >


  export type ai_response_cacheSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    input_hash?: boolean
    input_text?: boolean
    response_data?: boolean
    interaction_type?: boolean
    hit_count?: boolean
    expires_at?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["ai_response_cache"]>

  export type ai_response_cacheSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    input_hash?: boolean
    input_text?: boolean
    response_data?: boolean
    interaction_type?: boolean
    hit_count?: boolean
    expires_at?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["ai_response_cache"]>

  export type ai_response_cacheSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    input_hash?: boolean
    input_text?: boolean
    response_data?: boolean
    interaction_type?: boolean
    hit_count?: boolean
    expires_at?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["ai_response_cache"]>

  export type ai_response_cacheSelectScalar = {
    id?: boolean
    input_hash?: boolean
    input_text?: boolean
    response_data?: boolean
    interaction_type?: boolean
    hit_count?: boolean
    expires_at?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type ai_response_cacheOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "input_hash" | "input_text" | "response_data" | "interaction_type" | "hit_count" | "expires_at" | "created_at" | "updated_at", ExtArgs["result"]["ai_response_cache"]>

  export type $ai_response_cachePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ai_response_cache"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      input_hash: string
      input_text: string
      response_data: Prisma.JsonValue
      interaction_type: string
      hit_count: number
      expires_at: Date
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["ai_response_cache"]>
    composites: {}
  }

  type ai_response_cacheGetPayload<S extends boolean | null | undefined | ai_response_cacheDefaultArgs> = $Result.GetResult<Prisma.$ai_response_cachePayload, S>

  type ai_response_cacheCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ai_response_cacheFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Ai_response_cacheCountAggregateInputType | true
    }

  export interface ai_response_cacheDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ai_response_cache'], meta: { name: 'ai_response_cache' } }
    /**
     * Find zero or one Ai_response_cache that matches the filter.
     * @param {ai_response_cacheFindUniqueArgs} args - Arguments to find a Ai_response_cache
     * @example
     * // Get one Ai_response_cache
     * const ai_response_cache = await prisma.ai_response_cache.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ai_response_cacheFindUniqueArgs>(args: SelectSubset<T, ai_response_cacheFindUniqueArgs<ExtArgs>>): Prisma__ai_response_cacheClient<$Result.GetResult<Prisma.$ai_response_cachePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Ai_response_cache that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ai_response_cacheFindUniqueOrThrowArgs} args - Arguments to find a Ai_response_cache
     * @example
     * // Get one Ai_response_cache
     * const ai_response_cache = await prisma.ai_response_cache.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ai_response_cacheFindUniqueOrThrowArgs>(args: SelectSubset<T, ai_response_cacheFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ai_response_cacheClient<$Result.GetResult<Prisma.$ai_response_cachePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Ai_response_cache that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ai_response_cacheFindFirstArgs} args - Arguments to find a Ai_response_cache
     * @example
     * // Get one Ai_response_cache
     * const ai_response_cache = await prisma.ai_response_cache.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ai_response_cacheFindFirstArgs>(args?: SelectSubset<T, ai_response_cacheFindFirstArgs<ExtArgs>>): Prisma__ai_response_cacheClient<$Result.GetResult<Prisma.$ai_response_cachePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Ai_response_cache that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ai_response_cacheFindFirstOrThrowArgs} args - Arguments to find a Ai_response_cache
     * @example
     * // Get one Ai_response_cache
     * const ai_response_cache = await prisma.ai_response_cache.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ai_response_cacheFindFirstOrThrowArgs>(args?: SelectSubset<T, ai_response_cacheFindFirstOrThrowArgs<ExtArgs>>): Prisma__ai_response_cacheClient<$Result.GetResult<Prisma.$ai_response_cachePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Ai_response_caches that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ai_response_cacheFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Ai_response_caches
     * const ai_response_caches = await prisma.ai_response_cache.findMany()
     * 
     * // Get first 10 Ai_response_caches
     * const ai_response_caches = await prisma.ai_response_cache.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ai_response_cacheWithIdOnly = await prisma.ai_response_cache.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ai_response_cacheFindManyArgs>(args?: SelectSubset<T, ai_response_cacheFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ai_response_cachePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Ai_response_cache.
     * @param {ai_response_cacheCreateArgs} args - Arguments to create a Ai_response_cache.
     * @example
     * // Create one Ai_response_cache
     * const Ai_response_cache = await prisma.ai_response_cache.create({
     *   data: {
     *     // ... data to create a Ai_response_cache
     *   }
     * })
     * 
     */
    create<T extends ai_response_cacheCreateArgs>(args: SelectSubset<T, ai_response_cacheCreateArgs<ExtArgs>>): Prisma__ai_response_cacheClient<$Result.GetResult<Prisma.$ai_response_cachePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Ai_response_caches.
     * @param {ai_response_cacheCreateManyArgs} args - Arguments to create many Ai_response_caches.
     * @example
     * // Create many Ai_response_caches
     * const ai_response_cache = await prisma.ai_response_cache.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ai_response_cacheCreateManyArgs>(args?: SelectSubset<T, ai_response_cacheCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Ai_response_caches and returns the data saved in the database.
     * @param {ai_response_cacheCreateManyAndReturnArgs} args - Arguments to create many Ai_response_caches.
     * @example
     * // Create many Ai_response_caches
     * const ai_response_cache = await prisma.ai_response_cache.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Ai_response_caches and only return the `id`
     * const ai_response_cacheWithIdOnly = await prisma.ai_response_cache.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ai_response_cacheCreateManyAndReturnArgs>(args?: SelectSubset<T, ai_response_cacheCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ai_response_cachePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Ai_response_cache.
     * @param {ai_response_cacheDeleteArgs} args - Arguments to delete one Ai_response_cache.
     * @example
     * // Delete one Ai_response_cache
     * const Ai_response_cache = await prisma.ai_response_cache.delete({
     *   where: {
     *     // ... filter to delete one Ai_response_cache
     *   }
     * })
     * 
     */
    delete<T extends ai_response_cacheDeleteArgs>(args: SelectSubset<T, ai_response_cacheDeleteArgs<ExtArgs>>): Prisma__ai_response_cacheClient<$Result.GetResult<Prisma.$ai_response_cachePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Ai_response_cache.
     * @param {ai_response_cacheUpdateArgs} args - Arguments to update one Ai_response_cache.
     * @example
     * // Update one Ai_response_cache
     * const ai_response_cache = await prisma.ai_response_cache.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ai_response_cacheUpdateArgs>(args: SelectSubset<T, ai_response_cacheUpdateArgs<ExtArgs>>): Prisma__ai_response_cacheClient<$Result.GetResult<Prisma.$ai_response_cachePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Ai_response_caches.
     * @param {ai_response_cacheDeleteManyArgs} args - Arguments to filter Ai_response_caches to delete.
     * @example
     * // Delete a few Ai_response_caches
     * const { count } = await prisma.ai_response_cache.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ai_response_cacheDeleteManyArgs>(args?: SelectSubset<T, ai_response_cacheDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ai_response_caches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ai_response_cacheUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Ai_response_caches
     * const ai_response_cache = await prisma.ai_response_cache.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ai_response_cacheUpdateManyArgs>(args: SelectSubset<T, ai_response_cacheUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ai_response_caches and returns the data updated in the database.
     * @param {ai_response_cacheUpdateManyAndReturnArgs} args - Arguments to update many Ai_response_caches.
     * @example
     * // Update many Ai_response_caches
     * const ai_response_cache = await prisma.ai_response_cache.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Ai_response_caches and only return the `id`
     * const ai_response_cacheWithIdOnly = await prisma.ai_response_cache.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ai_response_cacheUpdateManyAndReturnArgs>(args: SelectSubset<T, ai_response_cacheUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ai_response_cachePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Ai_response_cache.
     * @param {ai_response_cacheUpsertArgs} args - Arguments to update or create a Ai_response_cache.
     * @example
     * // Update or create a Ai_response_cache
     * const ai_response_cache = await prisma.ai_response_cache.upsert({
     *   create: {
     *     // ... data to create a Ai_response_cache
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Ai_response_cache we want to update
     *   }
     * })
     */
    upsert<T extends ai_response_cacheUpsertArgs>(args: SelectSubset<T, ai_response_cacheUpsertArgs<ExtArgs>>): Prisma__ai_response_cacheClient<$Result.GetResult<Prisma.$ai_response_cachePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Ai_response_caches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ai_response_cacheCountArgs} args - Arguments to filter Ai_response_caches to count.
     * @example
     * // Count the number of Ai_response_caches
     * const count = await prisma.ai_response_cache.count({
     *   where: {
     *     // ... the filter for the Ai_response_caches we want to count
     *   }
     * })
    **/
    count<T extends ai_response_cacheCountArgs>(
      args?: Subset<T, ai_response_cacheCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Ai_response_cacheCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Ai_response_cache.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Ai_response_cacheAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Ai_response_cacheAggregateArgs>(args: Subset<T, Ai_response_cacheAggregateArgs>): Prisma.PrismaPromise<GetAi_response_cacheAggregateType<T>>

    /**
     * Group by Ai_response_cache.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ai_response_cacheGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ai_response_cacheGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ai_response_cacheGroupByArgs['orderBy'] }
        : { orderBy?: ai_response_cacheGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ai_response_cacheGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAi_response_cacheGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ai_response_cache model
   */
  readonly fields: ai_response_cacheFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ai_response_cache.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ai_response_cacheClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ai_response_cache model
   */
  interface ai_response_cacheFieldRefs {
    readonly id: FieldRef<"ai_response_cache", 'Int'>
    readonly input_hash: FieldRef<"ai_response_cache", 'String'>
    readonly input_text: FieldRef<"ai_response_cache", 'String'>
    readonly response_data: FieldRef<"ai_response_cache", 'Json'>
    readonly interaction_type: FieldRef<"ai_response_cache", 'String'>
    readonly hit_count: FieldRef<"ai_response_cache", 'Int'>
    readonly expires_at: FieldRef<"ai_response_cache", 'DateTime'>
    readonly created_at: FieldRef<"ai_response_cache", 'DateTime'>
    readonly updated_at: FieldRef<"ai_response_cache", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ai_response_cache findUnique
   */
  export type ai_response_cacheFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ai_response_cache
     */
    select?: ai_response_cacheSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ai_response_cache
     */
    omit?: ai_response_cacheOmit<ExtArgs> | null
    /**
     * Filter, which ai_response_cache to fetch.
     */
    where: ai_response_cacheWhereUniqueInput
  }

  /**
   * ai_response_cache findUniqueOrThrow
   */
  export type ai_response_cacheFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ai_response_cache
     */
    select?: ai_response_cacheSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ai_response_cache
     */
    omit?: ai_response_cacheOmit<ExtArgs> | null
    /**
     * Filter, which ai_response_cache to fetch.
     */
    where: ai_response_cacheWhereUniqueInput
  }

  /**
   * ai_response_cache findFirst
   */
  export type ai_response_cacheFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ai_response_cache
     */
    select?: ai_response_cacheSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ai_response_cache
     */
    omit?: ai_response_cacheOmit<ExtArgs> | null
    /**
     * Filter, which ai_response_cache to fetch.
     */
    where?: ai_response_cacheWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ai_response_caches to fetch.
     */
    orderBy?: ai_response_cacheOrderByWithRelationInput | ai_response_cacheOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ai_response_caches.
     */
    cursor?: ai_response_cacheWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ai_response_caches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ai_response_caches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ai_response_caches.
     */
    distinct?: Ai_response_cacheScalarFieldEnum | Ai_response_cacheScalarFieldEnum[]
  }

  /**
   * ai_response_cache findFirstOrThrow
   */
  export type ai_response_cacheFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ai_response_cache
     */
    select?: ai_response_cacheSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ai_response_cache
     */
    omit?: ai_response_cacheOmit<ExtArgs> | null
    /**
     * Filter, which ai_response_cache to fetch.
     */
    where?: ai_response_cacheWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ai_response_caches to fetch.
     */
    orderBy?: ai_response_cacheOrderByWithRelationInput | ai_response_cacheOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ai_response_caches.
     */
    cursor?: ai_response_cacheWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ai_response_caches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ai_response_caches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ai_response_caches.
     */
    distinct?: Ai_response_cacheScalarFieldEnum | Ai_response_cacheScalarFieldEnum[]
  }

  /**
   * ai_response_cache findMany
   */
  export type ai_response_cacheFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ai_response_cache
     */
    select?: ai_response_cacheSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ai_response_cache
     */
    omit?: ai_response_cacheOmit<ExtArgs> | null
    /**
     * Filter, which ai_response_caches to fetch.
     */
    where?: ai_response_cacheWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ai_response_caches to fetch.
     */
    orderBy?: ai_response_cacheOrderByWithRelationInput | ai_response_cacheOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ai_response_caches.
     */
    cursor?: ai_response_cacheWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ai_response_caches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ai_response_caches.
     */
    skip?: number
    distinct?: Ai_response_cacheScalarFieldEnum | Ai_response_cacheScalarFieldEnum[]
  }

  /**
   * ai_response_cache create
   */
  export type ai_response_cacheCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ai_response_cache
     */
    select?: ai_response_cacheSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ai_response_cache
     */
    omit?: ai_response_cacheOmit<ExtArgs> | null
    /**
     * The data needed to create a ai_response_cache.
     */
    data: XOR<ai_response_cacheCreateInput, ai_response_cacheUncheckedCreateInput>
  }

  /**
   * ai_response_cache createMany
   */
  export type ai_response_cacheCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ai_response_caches.
     */
    data: ai_response_cacheCreateManyInput | ai_response_cacheCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ai_response_cache createManyAndReturn
   */
  export type ai_response_cacheCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ai_response_cache
     */
    select?: ai_response_cacheSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ai_response_cache
     */
    omit?: ai_response_cacheOmit<ExtArgs> | null
    /**
     * The data used to create many ai_response_caches.
     */
    data: ai_response_cacheCreateManyInput | ai_response_cacheCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ai_response_cache update
   */
  export type ai_response_cacheUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ai_response_cache
     */
    select?: ai_response_cacheSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ai_response_cache
     */
    omit?: ai_response_cacheOmit<ExtArgs> | null
    /**
     * The data needed to update a ai_response_cache.
     */
    data: XOR<ai_response_cacheUpdateInput, ai_response_cacheUncheckedUpdateInput>
    /**
     * Choose, which ai_response_cache to update.
     */
    where: ai_response_cacheWhereUniqueInput
  }

  /**
   * ai_response_cache updateMany
   */
  export type ai_response_cacheUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ai_response_caches.
     */
    data: XOR<ai_response_cacheUpdateManyMutationInput, ai_response_cacheUncheckedUpdateManyInput>
    /**
     * Filter which ai_response_caches to update
     */
    where?: ai_response_cacheWhereInput
    /**
     * Limit how many ai_response_caches to update.
     */
    limit?: number
  }

  /**
   * ai_response_cache updateManyAndReturn
   */
  export type ai_response_cacheUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ai_response_cache
     */
    select?: ai_response_cacheSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ai_response_cache
     */
    omit?: ai_response_cacheOmit<ExtArgs> | null
    /**
     * The data used to update ai_response_caches.
     */
    data: XOR<ai_response_cacheUpdateManyMutationInput, ai_response_cacheUncheckedUpdateManyInput>
    /**
     * Filter which ai_response_caches to update
     */
    where?: ai_response_cacheWhereInput
    /**
     * Limit how many ai_response_caches to update.
     */
    limit?: number
  }

  /**
   * ai_response_cache upsert
   */
  export type ai_response_cacheUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ai_response_cache
     */
    select?: ai_response_cacheSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ai_response_cache
     */
    omit?: ai_response_cacheOmit<ExtArgs> | null
    /**
     * The filter to search for the ai_response_cache to update in case it exists.
     */
    where: ai_response_cacheWhereUniqueInput
    /**
     * In case the ai_response_cache found by the `where` argument doesn't exist, create a new ai_response_cache with this data.
     */
    create: XOR<ai_response_cacheCreateInput, ai_response_cacheUncheckedCreateInput>
    /**
     * In case the ai_response_cache was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ai_response_cacheUpdateInput, ai_response_cacheUncheckedUpdateInput>
  }

  /**
   * ai_response_cache delete
   */
  export type ai_response_cacheDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ai_response_cache
     */
    select?: ai_response_cacheSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ai_response_cache
     */
    omit?: ai_response_cacheOmit<ExtArgs> | null
    /**
     * Filter which ai_response_cache to delete.
     */
    where: ai_response_cacheWhereUniqueInput
  }

  /**
   * ai_response_cache deleteMany
   */
  export type ai_response_cacheDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ai_response_caches to delete
     */
    where?: ai_response_cacheWhereInput
    /**
     * Limit how many ai_response_caches to delete.
     */
    limit?: number
  }

  /**
   * ai_response_cache without action
   */
  export type ai_response_cacheDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ai_response_cache
     */
    select?: ai_response_cacheSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ai_response_cache
     */
    omit?: ai_response_cacheOmit<ExtArgs> | null
  }


  /**
   * Model associated_databases
   */

  export type AggregateAssociated_databases = {
    _count: Associated_databasesCountAggregateOutputType | null
    _avg: Associated_databasesAvgAggregateOutputType | null
    _sum: Associated_databasesSumAggregateOutputType | null
    _min: Associated_databasesMinAggregateOutputType | null
    _max: Associated_databasesMaxAggregateOutputType | null
  }

  export type Associated_databasesAvgAggregateOutputType = {
    id: number | null
  }

  export type Associated_databasesSumAggregateOutputType = {
    id: number | null
  }

  export type Associated_databasesMinAggregateOutputType = {
    id: number | null
    name: string | null
    type: string | null
    url: string | null
    schema: string | null
    description: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Associated_databasesMaxAggregateOutputType = {
    id: number | null
    name: string | null
    type: string | null
    url: string | null
    schema: string | null
    description: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Associated_databasesCountAggregateOutputType = {
    id: number
    name: number
    type: number
    url: number
    schema: number
    description: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type Associated_databasesAvgAggregateInputType = {
    id?: true
  }

  export type Associated_databasesSumAggregateInputType = {
    id?: true
  }

  export type Associated_databasesMinAggregateInputType = {
    id?: true
    name?: true
    type?: true
    url?: true
    schema?: true
    description?: true
    created_at?: true
    updated_at?: true
  }

  export type Associated_databasesMaxAggregateInputType = {
    id?: true
    name?: true
    type?: true
    url?: true
    schema?: true
    description?: true
    created_at?: true
    updated_at?: true
  }

  export type Associated_databasesCountAggregateInputType = {
    id?: true
    name?: true
    type?: true
    url?: true
    schema?: true
    description?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type Associated_databasesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which associated_databases to aggregate.
     */
    where?: associated_databasesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of associated_databases to fetch.
     */
    orderBy?: associated_databasesOrderByWithRelationInput | associated_databasesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: associated_databasesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` associated_databases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` associated_databases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned associated_databases
    **/
    _count?: true | Associated_databasesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Associated_databasesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Associated_databasesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Associated_databasesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Associated_databasesMaxAggregateInputType
  }

  export type GetAssociated_databasesAggregateType<T extends Associated_databasesAggregateArgs> = {
        [P in keyof T & keyof AggregateAssociated_databases]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAssociated_databases[P]>
      : GetScalarType<T[P], AggregateAssociated_databases[P]>
  }




  export type associated_databasesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: associated_databasesWhereInput
    orderBy?: associated_databasesOrderByWithAggregationInput | associated_databasesOrderByWithAggregationInput[]
    by: Associated_databasesScalarFieldEnum[] | Associated_databasesScalarFieldEnum
    having?: associated_databasesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Associated_databasesCountAggregateInputType | true
    _avg?: Associated_databasesAvgAggregateInputType
    _sum?: Associated_databasesSumAggregateInputType
    _min?: Associated_databasesMinAggregateInputType
    _max?: Associated_databasesMaxAggregateInputType
  }

  export type Associated_databasesGroupByOutputType = {
    id: number
    name: string
    type: string
    url: string | null
    schema: string
    description: string | null
    created_at: Date
    updated_at: Date
    _count: Associated_databasesCountAggregateOutputType | null
    _avg: Associated_databasesAvgAggregateOutputType | null
    _sum: Associated_databasesSumAggregateOutputType | null
    _min: Associated_databasesMinAggregateOutputType | null
    _max: Associated_databasesMaxAggregateOutputType | null
  }

  type GetAssociated_databasesGroupByPayload<T extends associated_databasesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Associated_databasesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Associated_databasesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Associated_databasesGroupByOutputType[P]>
            : GetScalarType<T[P], Associated_databasesGroupByOutputType[P]>
        }
      >
    >


  export type associated_databasesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    url?: boolean
    schema?: boolean
    description?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["associated_databases"]>

  export type associated_databasesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    url?: boolean
    schema?: boolean
    description?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["associated_databases"]>

  export type associated_databasesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    url?: boolean
    schema?: boolean
    description?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["associated_databases"]>

  export type associated_databasesSelectScalar = {
    id?: boolean
    name?: boolean
    type?: boolean
    url?: boolean
    schema?: boolean
    description?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type associated_databasesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "type" | "url" | "schema" | "description" | "created_at" | "updated_at", ExtArgs["result"]["associated_databases"]>

  export type $associated_databasesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "associated_databases"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      type: string
      url: string | null
      schema: string
      description: string | null
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["associated_databases"]>
    composites: {}
  }

  type associated_databasesGetPayload<S extends boolean | null | undefined | associated_databasesDefaultArgs> = $Result.GetResult<Prisma.$associated_databasesPayload, S>

  type associated_databasesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<associated_databasesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Associated_databasesCountAggregateInputType | true
    }

  export interface associated_databasesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['associated_databases'], meta: { name: 'associated_databases' } }
    /**
     * Find zero or one Associated_databases that matches the filter.
     * @param {associated_databasesFindUniqueArgs} args - Arguments to find a Associated_databases
     * @example
     * // Get one Associated_databases
     * const associated_databases = await prisma.associated_databases.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends associated_databasesFindUniqueArgs>(args: SelectSubset<T, associated_databasesFindUniqueArgs<ExtArgs>>): Prisma__associated_databasesClient<$Result.GetResult<Prisma.$associated_databasesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Associated_databases that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {associated_databasesFindUniqueOrThrowArgs} args - Arguments to find a Associated_databases
     * @example
     * // Get one Associated_databases
     * const associated_databases = await prisma.associated_databases.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends associated_databasesFindUniqueOrThrowArgs>(args: SelectSubset<T, associated_databasesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__associated_databasesClient<$Result.GetResult<Prisma.$associated_databasesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Associated_databases that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {associated_databasesFindFirstArgs} args - Arguments to find a Associated_databases
     * @example
     * // Get one Associated_databases
     * const associated_databases = await prisma.associated_databases.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends associated_databasesFindFirstArgs>(args?: SelectSubset<T, associated_databasesFindFirstArgs<ExtArgs>>): Prisma__associated_databasesClient<$Result.GetResult<Prisma.$associated_databasesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Associated_databases that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {associated_databasesFindFirstOrThrowArgs} args - Arguments to find a Associated_databases
     * @example
     * // Get one Associated_databases
     * const associated_databases = await prisma.associated_databases.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends associated_databasesFindFirstOrThrowArgs>(args?: SelectSubset<T, associated_databasesFindFirstOrThrowArgs<ExtArgs>>): Prisma__associated_databasesClient<$Result.GetResult<Prisma.$associated_databasesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Associated_databases that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {associated_databasesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Associated_databases
     * const associated_databases = await prisma.associated_databases.findMany()
     * 
     * // Get first 10 Associated_databases
     * const associated_databases = await prisma.associated_databases.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const associated_databasesWithIdOnly = await prisma.associated_databases.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends associated_databasesFindManyArgs>(args?: SelectSubset<T, associated_databasesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$associated_databasesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Associated_databases.
     * @param {associated_databasesCreateArgs} args - Arguments to create a Associated_databases.
     * @example
     * // Create one Associated_databases
     * const Associated_databases = await prisma.associated_databases.create({
     *   data: {
     *     // ... data to create a Associated_databases
     *   }
     * })
     * 
     */
    create<T extends associated_databasesCreateArgs>(args: SelectSubset<T, associated_databasesCreateArgs<ExtArgs>>): Prisma__associated_databasesClient<$Result.GetResult<Prisma.$associated_databasesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Associated_databases.
     * @param {associated_databasesCreateManyArgs} args - Arguments to create many Associated_databases.
     * @example
     * // Create many Associated_databases
     * const associated_databases = await prisma.associated_databases.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends associated_databasesCreateManyArgs>(args?: SelectSubset<T, associated_databasesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Associated_databases and returns the data saved in the database.
     * @param {associated_databasesCreateManyAndReturnArgs} args - Arguments to create many Associated_databases.
     * @example
     * // Create many Associated_databases
     * const associated_databases = await prisma.associated_databases.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Associated_databases and only return the `id`
     * const associated_databasesWithIdOnly = await prisma.associated_databases.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends associated_databasesCreateManyAndReturnArgs>(args?: SelectSubset<T, associated_databasesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$associated_databasesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Associated_databases.
     * @param {associated_databasesDeleteArgs} args - Arguments to delete one Associated_databases.
     * @example
     * // Delete one Associated_databases
     * const Associated_databases = await prisma.associated_databases.delete({
     *   where: {
     *     // ... filter to delete one Associated_databases
     *   }
     * })
     * 
     */
    delete<T extends associated_databasesDeleteArgs>(args: SelectSubset<T, associated_databasesDeleteArgs<ExtArgs>>): Prisma__associated_databasesClient<$Result.GetResult<Prisma.$associated_databasesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Associated_databases.
     * @param {associated_databasesUpdateArgs} args - Arguments to update one Associated_databases.
     * @example
     * // Update one Associated_databases
     * const associated_databases = await prisma.associated_databases.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends associated_databasesUpdateArgs>(args: SelectSubset<T, associated_databasesUpdateArgs<ExtArgs>>): Prisma__associated_databasesClient<$Result.GetResult<Prisma.$associated_databasesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Associated_databases.
     * @param {associated_databasesDeleteManyArgs} args - Arguments to filter Associated_databases to delete.
     * @example
     * // Delete a few Associated_databases
     * const { count } = await prisma.associated_databases.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends associated_databasesDeleteManyArgs>(args?: SelectSubset<T, associated_databasesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Associated_databases.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {associated_databasesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Associated_databases
     * const associated_databases = await prisma.associated_databases.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends associated_databasesUpdateManyArgs>(args: SelectSubset<T, associated_databasesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Associated_databases and returns the data updated in the database.
     * @param {associated_databasesUpdateManyAndReturnArgs} args - Arguments to update many Associated_databases.
     * @example
     * // Update many Associated_databases
     * const associated_databases = await prisma.associated_databases.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Associated_databases and only return the `id`
     * const associated_databasesWithIdOnly = await prisma.associated_databases.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends associated_databasesUpdateManyAndReturnArgs>(args: SelectSubset<T, associated_databasesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$associated_databasesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Associated_databases.
     * @param {associated_databasesUpsertArgs} args - Arguments to update or create a Associated_databases.
     * @example
     * // Update or create a Associated_databases
     * const associated_databases = await prisma.associated_databases.upsert({
     *   create: {
     *     // ... data to create a Associated_databases
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Associated_databases we want to update
     *   }
     * })
     */
    upsert<T extends associated_databasesUpsertArgs>(args: SelectSubset<T, associated_databasesUpsertArgs<ExtArgs>>): Prisma__associated_databasesClient<$Result.GetResult<Prisma.$associated_databasesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Associated_databases.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {associated_databasesCountArgs} args - Arguments to filter Associated_databases to count.
     * @example
     * // Count the number of Associated_databases
     * const count = await prisma.associated_databases.count({
     *   where: {
     *     // ... the filter for the Associated_databases we want to count
     *   }
     * })
    **/
    count<T extends associated_databasesCountArgs>(
      args?: Subset<T, associated_databasesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Associated_databasesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Associated_databases.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Associated_databasesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Associated_databasesAggregateArgs>(args: Subset<T, Associated_databasesAggregateArgs>): Prisma.PrismaPromise<GetAssociated_databasesAggregateType<T>>

    /**
     * Group by Associated_databases.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {associated_databasesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends associated_databasesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: associated_databasesGroupByArgs['orderBy'] }
        : { orderBy?: associated_databasesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, associated_databasesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAssociated_databasesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the associated_databases model
   */
  readonly fields: associated_databasesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for associated_databases.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__associated_databasesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the associated_databases model
   */
  interface associated_databasesFieldRefs {
    readonly id: FieldRef<"associated_databases", 'Int'>
    readonly name: FieldRef<"associated_databases", 'String'>
    readonly type: FieldRef<"associated_databases", 'String'>
    readonly url: FieldRef<"associated_databases", 'String'>
    readonly schema: FieldRef<"associated_databases", 'String'>
    readonly description: FieldRef<"associated_databases", 'String'>
    readonly created_at: FieldRef<"associated_databases", 'DateTime'>
    readonly updated_at: FieldRef<"associated_databases", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * associated_databases findUnique
   */
  export type associated_databasesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the associated_databases
     */
    select?: associated_databasesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the associated_databases
     */
    omit?: associated_databasesOmit<ExtArgs> | null
    /**
     * Filter, which associated_databases to fetch.
     */
    where: associated_databasesWhereUniqueInput
  }

  /**
   * associated_databases findUniqueOrThrow
   */
  export type associated_databasesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the associated_databases
     */
    select?: associated_databasesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the associated_databases
     */
    omit?: associated_databasesOmit<ExtArgs> | null
    /**
     * Filter, which associated_databases to fetch.
     */
    where: associated_databasesWhereUniqueInput
  }

  /**
   * associated_databases findFirst
   */
  export type associated_databasesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the associated_databases
     */
    select?: associated_databasesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the associated_databases
     */
    omit?: associated_databasesOmit<ExtArgs> | null
    /**
     * Filter, which associated_databases to fetch.
     */
    where?: associated_databasesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of associated_databases to fetch.
     */
    orderBy?: associated_databasesOrderByWithRelationInput | associated_databasesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for associated_databases.
     */
    cursor?: associated_databasesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` associated_databases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` associated_databases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of associated_databases.
     */
    distinct?: Associated_databasesScalarFieldEnum | Associated_databasesScalarFieldEnum[]
  }

  /**
   * associated_databases findFirstOrThrow
   */
  export type associated_databasesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the associated_databases
     */
    select?: associated_databasesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the associated_databases
     */
    omit?: associated_databasesOmit<ExtArgs> | null
    /**
     * Filter, which associated_databases to fetch.
     */
    where?: associated_databasesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of associated_databases to fetch.
     */
    orderBy?: associated_databasesOrderByWithRelationInput | associated_databasesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for associated_databases.
     */
    cursor?: associated_databasesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` associated_databases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` associated_databases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of associated_databases.
     */
    distinct?: Associated_databasesScalarFieldEnum | Associated_databasesScalarFieldEnum[]
  }

  /**
   * associated_databases findMany
   */
  export type associated_databasesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the associated_databases
     */
    select?: associated_databasesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the associated_databases
     */
    omit?: associated_databasesOmit<ExtArgs> | null
    /**
     * Filter, which associated_databases to fetch.
     */
    where?: associated_databasesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of associated_databases to fetch.
     */
    orderBy?: associated_databasesOrderByWithRelationInput | associated_databasesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing associated_databases.
     */
    cursor?: associated_databasesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` associated_databases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` associated_databases.
     */
    skip?: number
    distinct?: Associated_databasesScalarFieldEnum | Associated_databasesScalarFieldEnum[]
  }

  /**
   * associated_databases create
   */
  export type associated_databasesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the associated_databases
     */
    select?: associated_databasesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the associated_databases
     */
    omit?: associated_databasesOmit<ExtArgs> | null
    /**
     * The data needed to create a associated_databases.
     */
    data: XOR<associated_databasesCreateInput, associated_databasesUncheckedCreateInput>
  }

  /**
   * associated_databases createMany
   */
  export type associated_databasesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many associated_databases.
     */
    data: associated_databasesCreateManyInput | associated_databasesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * associated_databases createManyAndReturn
   */
  export type associated_databasesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the associated_databases
     */
    select?: associated_databasesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the associated_databases
     */
    omit?: associated_databasesOmit<ExtArgs> | null
    /**
     * The data used to create many associated_databases.
     */
    data: associated_databasesCreateManyInput | associated_databasesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * associated_databases update
   */
  export type associated_databasesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the associated_databases
     */
    select?: associated_databasesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the associated_databases
     */
    omit?: associated_databasesOmit<ExtArgs> | null
    /**
     * The data needed to update a associated_databases.
     */
    data: XOR<associated_databasesUpdateInput, associated_databasesUncheckedUpdateInput>
    /**
     * Choose, which associated_databases to update.
     */
    where: associated_databasesWhereUniqueInput
  }

  /**
   * associated_databases updateMany
   */
  export type associated_databasesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update associated_databases.
     */
    data: XOR<associated_databasesUpdateManyMutationInput, associated_databasesUncheckedUpdateManyInput>
    /**
     * Filter which associated_databases to update
     */
    where?: associated_databasesWhereInput
    /**
     * Limit how many associated_databases to update.
     */
    limit?: number
  }

  /**
   * associated_databases updateManyAndReturn
   */
  export type associated_databasesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the associated_databases
     */
    select?: associated_databasesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the associated_databases
     */
    omit?: associated_databasesOmit<ExtArgs> | null
    /**
     * The data used to update associated_databases.
     */
    data: XOR<associated_databasesUpdateManyMutationInput, associated_databasesUncheckedUpdateManyInput>
    /**
     * Filter which associated_databases to update
     */
    where?: associated_databasesWhereInput
    /**
     * Limit how many associated_databases to update.
     */
    limit?: number
  }

  /**
   * associated_databases upsert
   */
  export type associated_databasesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the associated_databases
     */
    select?: associated_databasesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the associated_databases
     */
    omit?: associated_databasesOmit<ExtArgs> | null
    /**
     * The filter to search for the associated_databases to update in case it exists.
     */
    where: associated_databasesWhereUniqueInput
    /**
     * In case the associated_databases found by the `where` argument doesn't exist, create a new associated_databases with this data.
     */
    create: XOR<associated_databasesCreateInput, associated_databasesUncheckedCreateInput>
    /**
     * In case the associated_databases was found with the provided `where` argument, update it with this data.
     */
    update: XOR<associated_databasesUpdateInput, associated_databasesUncheckedUpdateInput>
  }

  /**
   * associated_databases delete
   */
  export type associated_databasesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the associated_databases
     */
    select?: associated_databasesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the associated_databases
     */
    omit?: associated_databasesOmit<ExtArgs> | null
    /**
     * Filter which associated_databases to delete.
     */
    where: associated_databasesWhereUniqueInput
  }

  /**
   * associated_databases deleteMany
   */
  export type associated_databasesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which associated_databases to delete
     */
    where?: associated_databasesWhereInput
    /**
     * Limit how many associated_databases to delete.
     */
    limit?: number
  }

  /**
   * associated_databases without action
   */
  export type associated_databasesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the associated_databases
     */
    select?: associated_databasesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the associated_databases
     */
    omit?: associated_databasesOmit<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UsersScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    password_hash: 'password_hash',
    role: 'role',
    created_at: 'created_at'
  };

  export type UsersScalarFieldEnum = (typeof UsersScalarFieldEnum)[keyof typeof UsersScalarFieldEnum]


  export const QueriesScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    question_text: 'question_text',
    created_at: 'created_at'
  };

  export type QueriesScalarFieldEnum = (typeof QueriesScalarFieldEnum)[keyof typeof QueriesScalarFieldEnum]


  export const ResultsScalarFieldEnum: {
    id: 'id',
    query_id: 'query_id',
    result_type: 'result_type',
    content: 'content',
    created_at: 'created_at'
  };

  export type ResultsScalarFieldEnum = (typeof ResultsScalarFieldEnum)[keyof typeof ResultsScalarFieldEnum]


  export const HistoryScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    query_id: 'query_id',
    success: 'success',
    execution_time: 'execution_time',
    created_at: 'created_at'
  };

  export type HistoryScalarFieldEnum = (typeof HistoryScalarFieldEnum)[keyof typeof HistoryScalarFieldEnum]


  export const ExportsScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    file_type: 'file_type',
    file_path: 'file_path',
    created_at: 'created_at'
  };

  export type ExportsScalarFieldEnum = (typeof ExportsScalarFieldEnum)[keyof typeof ExportsScalarFieldEnum]


  export const SuggestionsScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    content: 'content',
    source: 'source',
    created_at: 'created_at'
  };

  export type SuggestionsScalarFieldEnum = (typeof SuggestionsScalarFieldEnum)[keyof typeof SuggestionsScalarFieldEnum]


  export const Access_logsScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    action: 'action',
    ip_address: 'ip_address',
    created_at: 'created_at'
  };

  export type Access_logsScalarFieldEnum = (typeof Access_logsScalarFieldEnum)[keyof typeof Access_logsScalarFieldEnum]


  export const Ai_chat_sessionsScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    session_token: 'session_token',
    status: 'status',
    context_data: 'context_data',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type Ai_chat_sessionsScalarFieldEnum = (typeof Ai_chat_sessionsScalarFieldEnum)[keyof typeof Ai_chat_sessionsScalarFieldEnum]


  export const Ai_interactionsScalarFieldEnum: {
    id: 'id',
    session_id: 'session_id',
    user_id: 'user_id',
    interaction_type: 'interaction_type',
    input_text: 'input_text',
    input_language: 'input_language',
    processed_query: 'processed_query',
    ai_response: 'ai_response',
    execution_status: 'execution_status',
    execution_time_ms: 'execution_time_ms',
    confidence_score: 'confidence_score',
    error_message: 'error_message',
    fallback_used: 'fallback_used',
    version: 'version',
    metadata: 'metadata',
    created_at: 'created_at'
  };

  export type Ai_interactionsScalarFieldEnum = (typeof Ai_interactionsScalarFieldEnum)[keyof typeof Ai_interactionsScalarFieldEnum]


  export const Ai_insightsScalarFieldEnum: {
    id: 'id',
    interaction_id: 'interaction_id',
    user_id: 'user_id',
    insight_type: 'insight_type',
    title: 'title',
    description: 'description',
    data_analysis: 'data_analysis',
    confidence_level: 'confidence_level',
    impact_score: 'impact_score',
    status: 'status',
    expires_at: 'expires_at',
    created_at: 'created_at'
  };

  export type Ai_insightsScalarFieldEnum = (typeof Ai_insightsScalarFieldEnum)[keyof typeof Ai_insightsScalarFieldEnum]


  export const Ai_fallbacksScalarFieldEnum: {
    id: 'id',
    trigger_pattern: 'trigger_pattern',
    fallback_type: 'fallback_type',
    response_template: 'response_template',
    escalation_level: 'escalation_level',
    is_active: 'is_active',
    usage_count: 'usage_count',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type Ai_fallbacksScalarFieldEnum = (typeof Ai_fallbacksScalarFieldEnum)[keyof typeof Ai_fallbacksScalarFieldEnum]


  export const Ai_response_cacheScalarFieldEnum: {
    id: 'id',
    input_hash: 'input_hash',
    input_text: 'input_text',
    response_data: 'response_data',
    interaction_type: 'interaction_type',
    hit_count: 'hit_count',
    expires_at: 'expires_at',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type Ai_response_cacheScalarFieldEnum = (typeof Ai_response_cacheScalarFieldEnum)[keyof typeof Ai_response_cacheScalarFieldEnum]


  export const Associated_databasesScalarFieldEnum: {
    id: 'id',
    name: 'name',
    type: 'type',
    url: 'url',
    schema: 'schema',
    description: 'description',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type Associated_databasesScalarFieldEnum = (typeof Associated_databasesScalarFieldEnum)[keyof typeof Associated_databasesScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type usersWhereInput = {
    AND?: usersWhereInput | usersWhereInput[]
    OR?: usersWhereInput[]
    NOT?: usersWhereInput | usersWhereInput[]
    id?: IntFilter<"users"> | number
    name?: StringFilter<"users"> | string
    email?: StringFilter<"users"> | string
    password_hash?: StringFilter<"users"> | string
    role?: StringNullableFilter<"users"> | string | null
    created_at?: DateTimeFilter<"users"> | Date | string
    queries?: QueriesListRelationFilter
    history?: HistoryListRelationFilter
    exports?: ExportsListRelationFilter
    suggestions?: SuggestionsListRelationFilter
    access_logs?: Access_logsListRelationFilter
    ai_chat_sessions?: Ai_chat_sessionsListRelationFilter
    ai_interactions?: Ai_interactionsListRelationFilter
    ai_insights?: Ai_insightsListRelationFilter
  }

  export type usersOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password_hash?: SortOrder
    role?: SortOrderInput | SortOrder
    created_at?: SortOrder
    queries?: queriesOrderByRelationAggregateInput
    history?: historyOrderByRelationAggregateInput
    exports?: exportsOrderByRelationAggregateInput
    suggestions?: suggestionsOrderByRelationAggregateInput
    access_logs?: access_logsOrderByRelationAggregateInput
    ai_chat_sessions?: ai_chat_sessionsOrderByRelationAggregateInput
    ai_interactions?: ai_interactionsOrderByRelationAggregateInput
    ai_insights?: ai_insightsOrderByRelationAggregateInput
  }

  export type usersWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    email?: string
    AND?: usersWhereInput | usersWhereInput[]
    OR?: usersWhereInput[]
    NOT?: usersWhereInput | usersWhereInput[]
    name?: StringFilter<"users"> | string
    password_hash?: StringFilter<"users"> | string
    role?: StringNullableFilter<"users"> | string | null
    created_at?: DateTimeFilter<"users"> | Date | string
    queries?: QueriesListRelationFilter
    history?: HistoryListRelationFilter
    exports?: ExportsListRelationFilter
    suggestions?: SuggestionsListRelationFilter
    access_logs?: Access_logsListRelationFilter
    ai_chat_sessions?: Ai_chat_sessionsListRelationFilter
    ai_interactions?: Ai_interactionsListRelationFilter
    ai_insights?: Ai_insightsListRelationFilter
  }, "id" | "email">

  export type usersOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password_hash?: SortOrder
    role?: SortOrderInput | SortOrder
    created_at?: SortOrder
    _count?: usersCountOrderByAggregateInput
    _avg?: usersAvgOrderByAggregateInput
    _max?: usersMaxOrderByAggregateInput
    _min?: usersMinOrderByAggregateInput
    _sum?: usersSumOrderByAggregateInput
  }

  export type usersScalarWhereWithAggregatesInput = {
    AND?: usersScalarWhereWithAggregatesInput | usersScalarWhereWithAggregatesInput[]
    OR?: usersScalarWhereWithAggregatesInput[]
    NOT?: usersScalarWhereWithAggregatesInput | usersScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"users"> | number
    name?: StringWithAggregatesFilter<"users"> | string
    email?: StringWithAggregatesFilter<"users"> | string
    password_hash?: StringWithAggregatesFilter<"users"> | string
    role?: StringNullableWithAggregatesFilter<"users"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"users"> | Date | string
  }

  export type queriesWhereInput = {
    AND?: queriesWhereInput | queriesWhereInput[]
    OR?: queriesWhereInput[]
    NOT?: queriesWhereInput | queriesWhereInput[]
    id?: IntFilter<"queries"> | number
    user_id?: IntFilter<"queries"> | number
    question_text?: StringNullableFilter<"queries"> | string | null
    created_at?: DateTimeFilter<"queries"> | Date | string
    user?: XOR<UsersScalarRelationFilter, usersWhereInput>
    results?: ResultsListRelationFilter
    history?: HistoryListRelationFilter
  }

  export type queriesOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    question_text?: SortOrderInput | SortOrder
    created_at?: SortOrder
    user?: usersOrderByWithRelationInput
    results?: resultsOrderByRelationAggregateInput
    history?: historyOrderByRelationAggregateInput
  }

  export type queriesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: queriesWhereInput | queriesWhereInput[]
    OR?: queriesWhereInput[]
    NOT?: queriesWhereInput | queriesWhereInput[]
    user_id?: IntFilter<"queries"> | number
    question_text?: StringNullableFilter<"queries"> | string | null
    created_at?: DateTimeFilter<"queries"> | Date | string
    user?: XOR<UsersScalarRelationFilter, usersWhereInput>
    results?: ResultsListRelationFilter
    history?: HistoryListRelationFilter
  }, "id">

  export type queriesOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    question_text?: SortOrderInput | SortOrder
    created_at?: SortOrder
    _count?: queriesCountOrderByAggregateInput
    _avg?: queriesAvgOrderByAggregateInput
    _max?: queriesMaxOrderByAggregateInput
    _min?: queriesMinOrderByAggregateInput
    _sum?: queriesSumOrderByAggregateInput
  }

  export type queriesScalarWhereWithAggregatesInput = {
    AND?: queriesScalarWhereWithAggregatesInput | queriesScalarWhereWithAggregatesInput[]
    OR?: queriesScalarWhereWithAggregatesInput[]
    NOT?: queriesScalarWhereWithAggregatesInput | queriesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"queries"> | number
    user_id?: IntWithAggregatesFilter<"queries"> | number
    question_text?: StringNullableWithAggregatesFilter<"queries"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"queries"> | Date | string
  }

  export type resultsWhereInput = {
    AND?: resultsWhereInput | resultsWhereInput[]
    OR?: resultsWhereInput[]
    NOT?: resultsWhereInput | resultsWhereInput[]
    id?: IntFilter<"results"> | number
    query_id?: IntFilter<"results"> | number
    result_type?: StringNullableFilter<"results"> | string | null
    content?: JsonNullableFilter<"results">
    created_at?: DateTimeFilter<"results"> | Date | string
    query?: XOR<QueriesScalarRelationFilter, queriesWhereInput>
  }

  export type resultsOrderByWithRelationInput = {
    id?: SortOrder
    query_id?: SortOrder
    result_type?: SortOrderInput | SortOrder
    content?: SortOrderInput | SortOrder
    created_at?: SortOrder
    query?: queriesOrderByWithRelationInput
  }

  export type resultsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: resultsWhereInput | resultsWhereInput[]
    OR?: resultsWhereInput[]
    NOT?: resultsWhereInput | resultsWhereInput[]
    query_id?: IntFilter<"results"> | number
    result_type?: StringNullableFilter<"results"> | string | null
    content?: JsonNullableFilter<"results">
    created_at?: DateTimeFilter<"results"> | Date | string
    query?: XOR<QueriesScalarRelationFilter, queriesWhereInput>
  }, "id">

  export type resultsOrderByWithAggregationInput = {
    id?: SortOrder
    query_id?: SortOrder
    result_type?: SortOrderInput | SortOrder
    content?: SortOrderInput | SortOrder
    created_at?: SortOrder
    _count?: resultsCountOrderByAggregateInput
    _avg?: resultsAvgOrderByAggregateInput
    _max?: resultsMaxOrderByAggregateInput
    _min?: resultsMinOrderByAggregateInput
    _sum?: resultsSumOrderByAggregateInput
  }

  export type resultsScalarWhereWithAggregatesInput = {
    AND?: resultsScalarWhereWithAggregatesInput | resultsScalarWhereWithAggregatesInput[]
    OR?: resultsScalarWhereWithAggregatesInput[]
    NOT?: resultsScalarWhereWithAggregatesInput | resultsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"results"> | number
    query_id?: IntWithAggregatesFilter<"results"> | number
    result_type?: StringNullableWithAggregatesFilter<"results"> | string | null
    content?: JsonNullableWithAggregatesFilter<"results">
    created_at?: DateTimeWithAggregatesFilter<"results"> | Date | string
  }

  export type historyWhereInput = {
    AND?: historyWhereInput | historyWhereInput[]
    OR?: historyWhereInput[]
    NOT?: historyWhereInput | historyWhereInput[]
    id?: IntFilter<"history"> | number
    user_id?: IntFilter<"history"> | number
    query_id?: IntNullableFilter<"history"> | number | null
    success?: BoolNullableFilter<"history"> | boolean | null
    execution_time?: FloatNullableFilter<"history"> | number | null
    created_at?: DateTimeFilter<"history"> | Date | string
    user?: XOR<UsersScalarRelationFilter, usersWhereInput>
    query?: XOR<QueriesNullableScalarRelationFilter, queriesWhereInput> | null
  }

  export type historyOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    query_id?: SortOrderInput | SortOrder
    success?: SortOrderInput | SortOrder
    execution_time?: SortOrderInput | SortOrder
    created_at?: SortOrder
    user?: usersOrderByWithRelationInput
    query?: queriesOrderByWithRelationInput
  }

  export type historyWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: historyWhereInput | historyWhereInput[]
    OR?: historyWhereInput[]
    NOT?: historyWhereInput | historyWhereInput[]
    user_id?: IntFilter<"history"> | number
    query_id?: IntNullableFilter<"history"> | number | null
    success?: BoolNullableFilter<"history"> | boolean | null
    execution_time?: FloatNullableFilter<"history"> | number | null
    created_at?: DateTimeFilter<"history"> | Date | string
    user?: XOR<UsersScalarRelationFilter, usersWhereInput>
    query?: XOR<QueriesNullableScalarRelationFilter, queriesWhereInput> | null
  }, "id">

  export type historyOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    query_id?: SortOrderInput | SortOrder
    success?: SortOrderInput | SortOrder
    execution_time?: SortOrderInput | SortOrder
    created_at?: SortOrder
    _count?: historyCountOrderByAggregateInput
    _avg?: historyAvgOrderByAggregateInput
    _max?: historyMaxOrderByAggregateInput
    _min?: historyMinOrderByAggregateInput
    _sum?: historySumOrderByAggregateInput
  }

  export type historyScalarWhereWithAggregatesInput = {
    AND?: historyScalarWhereWithAggregatesInput | historyScalarWhereWithAggregatesInput[]
    OR?: historyScalarWhereWithAggregatesInput[]
    NOT?: historyScalarWhereWithAggregatesInput | historyScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"history"> | number
    user_id?: IntWithAggregatesFilter<"history"> | number
    query_id?: IntNullableWithAggregatesFilter<"history"> | number | null
    success?: BoolNullableWithAggregatesFilter<"history"> | boolean | null
    execution_time?: FloatNullableWithAggregatesFilter<"history"> | number | null
    created_at?: DateTimeWithAggregatesFilter<"history"> | Date | string
  }

  export type exportsWhereInput = {
    AND?: exportsWhereInput | exportsWhereInput[]
    OR?: exportsWhereInput[]
    NOT?: exportsWhereInput | exportsWhereInput[]
    id?: IntFilter<"exports"> | number
    user_id?: IntFilter<"exports"> | number
    file_type?: StringNullableFilter<"exports"> | string | null
    file_path?: StringNullableFilter<"exports"> | string | null
    created_at?: DateTimeFilter<"exports"> | Date | string
    user?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }

  export type exportsOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    file_type?: SortOrderInput | SortOrder
    file_path?: SortOrderInput | SortOrder
    created_at?: SortOrder
    user?: usersOrderByWithRelationInput
  }

  export type exportsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: exportsWhereInput | exportsWhereInput[]
    OR?: exportsWhereInput[]
    NOT?: exportsWhereInput | exportsWhereInput[]
    user_id?: IntFilter<"exports"> | number
    file_type?: StringNullableFilter<"exports"> | string | null
    file_path?: StringNullableFilter<"exports"> | string | null
    created_at?: DateTimeFilter<"exports"> | Date | string
    user?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }, "id">

  export type exportsOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    file_type?: SortOrderInput | SortOrder
    file_path?: SortOrderInput | SortOrder
    created_at?: SortOrder
    _count?: exportsCountOrderByAggregateInput
    _avg?: exportsAvgOrderByAggregateInput
    _max?: exportsMaxOrderByAggregateInput
    _min?: exportsMinOrderByAggregateInput
    _sum?: exportsSumOrderByAggregateInput
  }

  export type exportsScalarWhereWithAggregatesInput = {
    AND?: exportsScalarWhereWithAggregatesInput | exportsScalarWhereWithAggregatesInput[]
    OR?: exportsScalarWhereWithAggregatesInput[]
    NOT?: exportsScalarWhereWithAggregatesInput | exportsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"exports"> | number
    user_id?: IntWithAggregatesFilter<"exports"> | number
    file_type?: StringNullableWithAggregatesFilter<"exports"> | string | null
    file_path?: StringNullableWithAggregatesFilter<"exports"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"exports"> | Date | string
  }

  export type suggestionsWhereInput = {
    AND?: suggestionsWhereInput | suggestionsWhereInput[]
    OR?: suggestionsWhereInput[]
    NOT?: suggestionsWhereInput | suggestionsWhereInput[]
    id?: IntFilter<"suggestions"> | number
    user_id?: IntFilter<"suggestions"> | number
    content?: StringNullableFilter<"suggestions"> | string | null
    source?: StringNullableFilter<"suggestions"> | string | null
    created_at?: DateTimeFilter<"suggestions"> | Date | string
    user?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }

  export type suggestionsOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    content?: SortOrderInput | SortOrder
    source?: SortOrderInput | SortOrder
    created_at?: SortOrder
    user?: usersOrderByWithRelationInput
  }

  export type suggestionsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: suggestionsWhereInput | suggestionsWhereInput[]
    OR?: suggestionsWhereInput[]
    NOT?: suggestionsWhereInput | suggestionsWhereInput[]
    user_id?: IntFilter<"suggestions"> | number
    content?: StringNullableFilter<"suggestions"> | string | null
    source?: StringNullableFilter<"suggestions"> | string | null
    created_at?: DateTimeFilter<"suggestions"> | Date | string
    user?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }, "id">

  export type suggestionsOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    content?: SortOrderInput | SortOrder
    source?: SortOrderInput | SortOrder
    created_at?: SortOrder
    _count?: suggestionsCountOrderByAggregateInput
    _avg?: suggestionsAvgOrderByAggregateInput
    _max?: suggestionsMaxOrderByAggregateInput
    _min?: suggestionsMinOrderByAggregateInput
    _sum?: suggestionsSumOrderByAggregateInput
  }

  export type suggestionsScalarWhereWithAggregatesInput = {
    AND?: suggestionsScalarWhereWithAggregatesInput | suggestionsScalarWhereWithAggregatesInput[]
    OR?: suggestionsScalarWhereWithAggregatesInput[]
    NOT?: suggestionsScalarWhereWithAggregatesInput | suggestionsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"suggestions"> | number
    user_id?: IntWithAggregatesFilter<"suggestions"> | number
    content?: StringNullableWithAggregatesFilter<"suggestions"> | string | null
    source?: StringNullableWithAggregatesFilter<"suggestions"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"suggestions"> | Date | string
  }

  export type access_logsWhereInput = {
    AND?: access_logsWhereInput | access_logsWhereInput[]
    OR?: access_logsWhereInput[]
    NOT?: access_logsWhereInput | access_logsWhereInput[]
    id?: IntFilter<"access_logs"> | number
    user_id?: IntNullableFilter<"access_logs"> | number | null
    action?: StringNullableFilter<"access_logs"> | string | null
    ip_address?: StringNullableFilter<"access_logs"> | string | null
    created_at?: DateTimeFilter<"access_logs"> | Date | string
    user?: XOR<UsersNullableScalarRelationFilter, usersWhereInput> | null
  }

  export type access_logsOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrderInput | SortOrder
    action?: SortOrderInput | SortOrder
    ip_address?: SortOrderInput | SortOrder
    created_at?: SortOrder
    user?: usersOrderByWithRelationInput
  }

  export type access_logsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: access_logsWhereInput | access_logsWhereInput[]
    OR?: access_logsWhereInput[]
    NOT?: access_logsWhereInput | access_logsWhereInput[]
    user_id?: IntNullableFilter<"access_logs"> | number | null
    action?: StringNullableFilter<"access_logs"> | string | null
    ip_address?: StringNullableFilter<"access_logs"> | string | null
    created_at?: DateTimeFilter<"access_logs"> | Date | string
    user?: XOR<UsersNullableScalarRelationFilter, usersWhereInput> | null
  }, "id">

  export type access_logsOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrderInput | SortOrder
    action?: SortOrderInput | SortOrder
    ip_address?: SortOrderInput | SortOrder
    created_at?: SortOrder
    _count?: access_logsCountOrderByAggregateInput
    _avg?: access_logsAvgOrderByAggregateInput
    _max?: access_logsMaxOrderByAggregateInput
    _min?: access_logsMinOrderByAggregateInput
    _sum?: access_logsSumOrderByAggregateInput
  }

  export type access_logsScalarWhereWithAggregatesInput = {
    AND?: access_logsScalarWhereWithAggregatesInput | access_logsScalarWhereWithAggregatesInput[]
    OR?: access_logsScalarWhereWithAggregatesInput[]
    NOT?: access_logsScalarWhereWithAggregatesInput | access_logsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"access_logs"> | number
    user_id?: IntNullableWithAggregatesFilter<"access_logs"> | number | null
    action?: StringNullableWithAggregatesFilter<"access_logs"> | string | null
    ip_address?: StringNullableWithAggregatesFilter<"access_logs"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"access_logs"> | Date | string
  }

  export type ai_chat_sessionsWhereInput = {
    AND?: ai_chat_sessionsWhereInput | ai_chat_sessionsWhereInput[]
    OR?: ai_chat_sessionsWhereInput[]
    NOT?: ai_chat_sessionsWhereInput | ai_chat_sessionsWhereInput[]
    id?: IntFilter<"ai_chat_sessions"> | number
    user_id?: IntFilter<"ai_chat_sessions"> | number
    session_token?: StringFilter<"ai_chat_sessions"> | string
    status?: StringFilter<"ai_chat_sessions"> | string
    context_data?: JsonNullableFilter<"ai_chat_sessions">
    created_at?: DateTimeFilter<"ai_chat_sessions"> | Date | string
    updated_at?: DateTimeFilter<"ai_chat_sessions"> | Date | string
    user?: XOR<UsersScalarRelationFilter, usersWhereInput>
    interactions?: Ai_interactionsListRelationFilter
  }

  export type ai_chat_sessionsOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    session_token?: SortOrder
    status?: SortOrder
    context_data?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    user?: usersOrderByWithRelationInput
    interactions?: ai_interactionsOrderByRelationAggregateInput
  }

  export type ai_chat_sessionsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    session_token?: string
    AND?: ai_chat_sessionsWhereInput | ai_chat_sessionsWhereInput[]
    OR?: ai_chat_sessionsWhereInput[]
    NOT?: ai_chat_sessionsWhereInput | ai_chat_sessionsWhereInput[]
    user_id?: IntFilter<"ai_chat_sessions"> | number
    status?: StringFilter<"ai_chat_sessions"> | string
    context_data?: JsonNullableFilter<"ai_chat_sessions">
    created_at?: DateTimeFilter<"ai_chat_sessions"> | Date | string
    updated_at?: DateTimeFilter<"ai_chat_sessions"> | Date | string
    user?: XOR<UsersScalarRelationFilter, usersWhereInput>
    interactions?: Ai_interactionsListRelationFilter
  }, "id" | "session_token">

  export type ai_chat_sessionsOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    session_token?: SortOrder
    status?: SortOrder
    context_data?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: ai_chat_sessionsCountOrderByAggregateInput
    _avg?: ai_chat_sessionsAvgOrderByAggregateInput
    _max?: ai_chat_sessionsMaxOrderByAggregateInput
    _min?: ai_chat_sessionsMinOrderByAggregateInput
    _sum?: ai_chat_sessionsSumOrderByAggregateInput
  }

  export type ai_chat_sessionsScalarWhereWithAggregatesInput = {
    AND?: ai_chat_sessionsScalarWhereWithAggregatesInput | ai_chat_sessionsScalarWhereWithAggregatesInput[]
    OR?: ai_chat_sessionsScalarWhereWithAggregatesInput[]
    NOT?: ai_chat_sessionsScalarWhereWithAggregatesInput | ai_chat_sessionsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ai_chat_sessions"> | number
    user_id?: IntWithAggregatesFilter<"ai_chat_sessions"> | number
    session_token?: StringWithAggregatesFilter<"ai_chat_sessions"> | string
    status?: StringWithAggregatesFilter<"ai_chat_sessions"> | string
    context_data?: JsonNullableWithAggregatesFilter<"ai_chat_sessions">
    created_at?: DateTimeWithAggregatesFilter<"ai_chat_sessions"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"ai_chat_sessions"> | Date | string
  }

  export type ai_interactionsWhereInput = {
    AND?: ai_interactionsWhereInput | ai_interactionsWhereInput[]
    OR?: ai_interactionsWhereInput[]
    NOT?: ai_interactionsWhereInput | ai_interactionsWhereInput[]
    id?: IntFilter<"ai_interactions"> | number
    session_id?: IntFilter<"ai_interactions"> | number
    user_id?: IntFilter<"ai_interactions"> | number
    interaction_type?: StringFilter<"ai_interactions"> | string
    input_text?: StringFilter<"ai_interactions"> | string
    input_language?: StringFilter<"ai_interactions"> | string
    processed_query?: StringNullableFilter<"ai_interactions"> | string | null
    ai_response?: JsonNullableFilter<"ai_interactions">
    execution_status?: StringFilter<"ai_interactions"> | string
    execution_time_ms?: IntNullableFilter<"ai_interactions"> | number | null
    confidence_score?: FloatNullableFilter<"ai_interactions"> | number | null
    error_message?: StringNullableFilter<"ai_interactions"> | string | null
    fallback_used?: BoolFilter<"ai_interactions"> | boolean
    version?: StringFilter<"ai_interactions"> | string
    metadata?: JsonNullableFilter<"ai_interactions">
    created_at?: DateTimeFilter<"ai_interactions"> | Date | string
    session?: XOR<Ai_chat_sessionsScalarRelationFilter, ai_chat_sessionsWhereInput>
    user?: XOR<UsersScalarRelationFilter, usersWhereInput>
    insights?: Ai_insightsListRelationFilter
  }

  export type ai_interactionsOrderByWithRelationInput = {
    id?: SortOrder
    session_id?: SortOrder
    user_id?: SortOrder
    interaction_type?: SortOrder
    input_text?: SortOrder
    input_language?: SortOrder
    processed_query?: SortOrderInput | SortOrder
    ai_response?: SortOrderInput | SortOrder
    execution_status?: SortOrder
    execution_time_ms?: SortOrderInput | SortOrder
    confidence_score?: SortOrderInput | SortOrder
    error_message?: SortOrderInput | SortOrder
    fallback_used?: SortOrder
    version?: SortOrder
    metadata?: SortOrderInput | SortOrder
    created_at?: SortOrder
    session?: ai_chat_sessionsOrderByWithRelationInput
    user?: usersOrderByWithRelationInput
    insights?: ai_insightsOrderByRelationAggregateInput
  }

  export type ai_interactionsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ai_interactionsWhereInput | ai_interactionsWhereInput[]
    OR?: ai_interactionsWhereInput[]
    NOT?: ai_interactionsWhereInput | ai_interactionsWhereInput[]
    session_id?: IntFilter<"ai_interactions"> | number
    user_id?: IntFilter<"ai_interactions"> | number
    interaction_type?: StringFilter<"ai_interactions"> | string
    input_text?: StringFilter<"ai_interactions"> | string
    input_language?: StringFilter<"ai_interactions"> | string
    processed_query?: StringNullableFilter<"ai_interactions"> | string | null
    ai_response?: JsonNullableFilter<"ai_interactions">
    execution_status?: StringFilter<"ai_interactions"> | string
    execution_time_ms?: IntNullableFilter<"ai_interactions"> | number | null
    confidence_score?: FloatNullableFilter<"ai_interactions"> | number | null
    error_message?: StringNullableFilter<"ai_interactions"> | string | null
    fallback_used?: BoolFilter<"ai_interactions"> | boolean
    version?: StringFilter<"ai_interactions"> | string
    metadata?: JsonNullableFilter<"ai_interactions">
    created_at?: DateTimeFilter<"ai_interactions"> | Date | string
    session?: XOR<Ai_chat_sessionsScalarRelationFilter, ai_chat_sessionsWhereInput>
    user?: XOR<UsersScalarRelationFilter, usersWhereInput>
    insights?: Ai_insightsListRelationFilter
  }, "id">

  export type ai_interactionsOrderByWithAggregationInput = {
    id?: SortOrder
    session_id?: SortOrder
    user_id?: SortOrder
    interaction_type?: SortOrder
    input_text?: SortOrder
    input_language?: SortOrder
    processed_query?: SortOrderInput | SortOrder
    ai_response?: SortOrderInput | SortOrder
    execution_status?: SortOrder
    execution_time_ms?: SortOrderInput | SortOrder
    confidence_score?: SortOrderInput | SortOrder
    error_message?: SortOrderInput | SortOrder
    fallback_used?: SortOrder
    version?: SortOrder
    metadata?: SortOrderInput | SortOrder
    created_at?: SortOrder
    _count?: ai_interactionsCountOrderByAggregateInput
    _avg?: ai_interactionsAvgOrderByAggregateInput
    _max?: ai_interactionsMaxOrderByAggregateInput
    _min?: ai_interactionsMinOrderByAggregateInput
    _sum?: ai_interactionsSumOrderByAggregateInput
  }

  export type ai_interactionsScalarWhereWithAggregatesInput = {
    AND?: ai_interactionsScalarWhereWithAggregatesInput | ai_interactionsScalarWhereWithAggregatesInput[]
    OR?: ai_interactionsScalarWhereWithAggregatesInput[]
    NOT?: ai_interactionsScalarWhereWithAggregatesInput | ai_interactionsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ai_interactions"> | number
    session_id?: IntWithAggregatesFilter<"ai_interactions"> | number
    user_id?: IntWithAggregatesFilter<"ai_interactions"> | number
    interaction_type?: StringWithAggregatesFilter<"ai_interactions"> | string
    input_text?: StringWithAggregatesFilter<"ai_interactions"> | string
    input_language?: StringWithAggregatesFilter<"ai_interactions"> | string
    processed_query?: StringNullableWithAggregatesFilter<"ai_interactions"> | string | null
    ai_response?: JsonNullableWithAggregatesFilter<"ai_interactions">
    execution_status?: StringWithAggregatesFilter<"ai_interactions"> | string
    execution_time_ms?: IntNullableWithAggregatesFilter<"ai_interactions"> | number | null
    confidence_score?: FloatNullableWithAggregatesFilter<"ai_interactions"> | number | null
    error_message?: StringNullableWithAggregatesFilter<"ai_interactions"> | string | null
    fallback_used?: BoolWithAggregatesFilter<"ai_interactions"> | boolean
    version?: StringWithAggregatesFilter<"ai_interactions"> | string
    metadata?: JsonNullableWithAggregatesFilter<"ai_interactions">
    created_at?: DateTimeWithAggregatesFilter<"ai_interactions"> | Date | string
  }

  export type ai_insightsWhereInput = {
    AND?: ai_insightsWhereInput | ai_insightsWhereInput[]
    OR?: ai_insightsWhereInput[]
    NOT?: ai_insightsWhereInput | ai_insightsWhereInput[]
    id?: IntFilter<"ai_insights"> | number
    interaction_id?: IntNullableFilter<"ai_insights"> | number | null
    user_id?: IntFilter<"ai_insights"> | number
    insight_type?: StringFilter<"ai_insights"> | string
    title?: StringFilter<"ai_insights"> | string
    description?: StringFilter<"ai_insights"> | string
    data_analysis?: JsonFilter<"ai_insights">
    confidence_level?: StringFilter<"ai_insights"> | string
    impact_score?: FloatNullableFilter<"ai_insights"> | number | null
    status?: StringFilter<"ai_insights"> | string
    expires_at?: DateTimeNullableFilter<"ai_insights"> | Date | string | null
    created_at?: DateTimeFilter<"ai_insights"> | Date | string
    interaction?: XOR<Ai_interactionsNullableScalarRelationFilter, ai_interactionsWhereInput> | null
    user?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }

  export type ai_insightsOrderByWithRelationInput = {
    id?: SortOrder
    interaction_id?: SortOrderInput | SortOrder
    user_id?: SortOrder
    insight_type?: SortOrder
    title?: SortOrder
    description?: SortOrder
    data_analysis?: SortOrder
    confidence_level?: SortOrder
    impact_score?: SortOrderInput | SortOrder
    status?: SortOrder
    expires_at?: SortOrderInput | SortOrder
    created_at?: SortOrder
    interaction?: ai_interactionsOrderByWithRelationInput
    user?: usersOrderByWithRelationInput
  }

  export type ai_insightsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ai_insightsWhereInput | ai_insightsWhereInput[]
    OR?: ai_insightsWhereInput[]
    NOT?: ai_insightsWhereInput | ai_insightsWhereInput[]
    interaction_id?: IntNullableFilter<"ai_insights"> | number | null
    user_id?: IntFilter<"ai_insights"> | number
    insight_type?: StringFilter<"ai_insights"> | string
    title?: StringFilter<"ai_insights"> | string
    description?: StringFilter<"ai_insights"> | string
    data_analysis?: JsonFilter<"ai_insights">
    confidence_level?: StringFilter<"ai_insights"> | string
    impact_score?: FloatNullableFilter<"ai_insights"> | number | null
    status?: StringFilter<"ai_insights"> | string
    expires_at?: DateTimeNullableFilter<"ai_insights"> | Date | string | null
    created_at?: DateTimeFilter<"ai_insights"> | Date | string
    interaction?: XOR<Ai_interactionsNullableScalarRelationFilter, ai_interactionsWhereInput> | null
    user?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }, "id">

  export type ai_insightsOrderByWithAggregationInput = {
    id?: SortOrder
    interaction_id?: SortOrderInput | SortOrder
    user_id?: SortOrder
    insight_type?: SortOrder
    title?: SortOrder
    description?: SortOrder
    data_analysis?: SortOrder
    confidence_level?: SortOrder
    impact_score?: SortOrderInput | SortOrder
    status?: SortOrder
    expires_at?: SortOrderInput | SortOrder
    created_at?: SortOrder
    _count?: ai_insightsCountOrderByAggregateInput
    _avg?: ai_insightsAvgOrderByAggregateInput
    _max?: ai_insightsMaxOrderByAggregateInput
    _min?: ai_insightsMinOrderByAggregateInput
    _sum?: ai_insightsSumOrderByAggregateInput
  }

  export type ai_insightsScalarWhereWithAggregatesInput = {
    AND?: ai_insightsScalarWhereWithAggregatesInput | ai_insightsScalarWhereWithAggregatesInput[]
    OR?: ai_insightsScalarWhereWithAggregatesInput[]
    NOT?: ai_insightsScalarWhereWithAggregatesInput | ai_insightsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ai_insights"> | number
    interaction_id?: IntNullableWithAggregatesFilter<"ai_insights"> | number | null
    user_id?: IntWithAggregatesFilter<"ai_insights"> | number
    insight_type?: StringWithAggregatesFilter<"ai_insights"> | string
    title?: StringWithAggregatesFilter<"ai_insights"> | string
    description?: StringWithAggregatesFilter<"ai_insights"> | string
    data_analysis?: JsonWithAggregatesFilter<"ai_insights">
    confidence_level?: StringWithAggregatesFilter<"ai_insights"> | string
    impact_score?: FloatNullableWithAggregatesFilter<"ai_insights"> | number | null
    status?: StringWithAggregatesFilter<"ai_insights"> | string
    expires_at?: DateTimeNullableWithAggregatesFilter<"ai_insights"> | Date | string | null
    created_at?: DateTimeWithAggregatesFilter<"ai_insights"> | Date | string
  }

  export type ai_fallbacksWhereInput = {
    AND?: ai_fallbacksWhereInput | ai_fallbacksWhereInput[]
    OR?: ai_fallbacksWhereInput[]
    NOT?: ai_fallbacksWhereInput | ai_fallbacksWhereInput[]
    id?: IntFilter<"ai_fallbacks"> | number
    trigger_pattern?: StringFilter<"ai_fallbacks"> | string
    fallback_type?: StringFilter<"ai_fallbacks"> | string
    response_template?: StringFilter<"ai_fallbacks"> | string
    escalation_level?: IntFilter<"ai_fallbacks"> | number
    is_active?: BoolFilter<"ai_fallbacks"> | boolean
    usage_count?: IntFilter<"ai_fallbacks"> | number
    created_at?: DateTimeFilter<"ai_fallbacks"> | Date | string
    updated_at?: DateTimeFilter<"ai_fallbacks"> | Date | string
  }

  export type ai_fallbacksOrderByWithRelationInput = {
    id?: SortOrder
    trigger_pattern?: SortOrder
    fallback_type?: SortOrder
    response_template?: SortOrder
    escalation_level?: SortOrder
    is_active?: SortOrder
    usage_count?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ai_fallbacksWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    trigger_pattern?: string
    AND?: ai_fallbacksWhereInput | ai_fallbacksWhereInput[]
    OR?: ai_fallbacksWhereInput[]
    NOT?: ai_fallbacksWhereInput | ai_fallbacksWhereInput[]
    fallback_type?: StringFilter<"ai_fallbacks"> | string
    response_template?: StringFilter<"ai_fallbacks"> | string
    escalation_level?: IntFilter<"ai_fallbacks"> | number
    is_active?: BoolFilter<"ai_fallbacks"> | boolean
    usage_count?: IntFilter<"ai_fallbacks"> | number
    created_at?: DateTimeFilter<"ai_fallbacks"> | Date | string
    updated_at?: DateTimeFilter<"ai_fallbacks"> | Date | string
  }, "id" | "trigger_pattern">

  export type ai_fallbacksOrderByWithAggregationInput = {
    id?: SortOrder
    trigger_pattern?: SortOrder
    fallback_type?: SortOrder
    response_template?: SortOrder
    escalation_level?: SortOrder
    is_active?: SortOrder
    usage_count?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: ai_fallbacksCountOrderByAggregateInput
    _avg?: ai_fallbacksAvgOrderByAggregateInput
    _max?: ai_fallbacksMaxOrderByAggregateInput
    _min?: ai_fallbacksMinOrderByAggregateInput
    _sum?: ai_fallbacksSumOrderByAggregateInput
  }

  export type ai_fallbacksScalarWhereWithAggregatesInput = {
    AND?: ai_fallbacksScalarWhereWithAggregatesInput | ai_fallbacksScalarWhereWithAggregatesInput[]
    OR?: ai_fallbacksScalarWhereWithAggregatesInput[]
    NOT?: ai_fallbacksScalarWhereWithAggregatesInput | ai_fallbacksScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ai_fallbacks"> | number
    trigger_pattern?: StringWithAggregatesFilter<"ai_fallbacks"> | string
    fallback_type?: StringWithAggregatesFilter<"ai_fallbacks"> | string
    response_template?: StringWithAggregatesFilter<"ai_fallbacks"> | string
    escalation_level?: IntWithAggregatesFilter<"ai_fallbacks"> | number
    is_active?: BoolWithAggregatesFilter<"ai_fallbacks"> | boolean
    usage_count?: IntWithAggregatesFilter<"ai_fallbacks"> | number
    created_at?: DateTimeWithAggregatesFilter<"ai_fallbacks"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"ai_fallbacks"> | Date | string
  }

  export type ai_response_cacheWhereInput = {
    AND?: ai_response_cacheWhereInput | ai_response_cacheWhereInput[]
    OR?: ai_response_cacheWhereInput[]
    NOT?: ai_response_cacheWhereInput | ai_response_cacheWhereInput[]
    id?: IntFilter<"ai_response_cache"> | number
    input_hash?: StringFilter<"ai_response_cache"> | string
    input_text?: StringFilter<"ai_response_cache"> | string
    response_data?: JsonFilter<"ai_response_cache">
    interaction_type?: StringFilter<"ai_response_cache"> | string
    hit_count?: IntFilter<"ai_response_cache"> | number
    expires_at?: DateTimeFilter<"ai_response_cache"> | Date | string
    created_at?: DateTimeFilter<"ai_response_cache"> | Date | string
    updated_at?: DateTimeFilter<"ai_response_cache"> | Date | string
  }

  export type ai_response_cacheOrderByWithRelationInput = {
    id?: SortOrder
    input_hash?: SortOrder
    input_text?: SortOrder
    response_data?: SortOrder
    interaction_type?: SortOrder
    hit_count?: SortOrder
    expires_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ai_response_cacheWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    input_hash?: string
    AND?: ai_response_cacheWhereInput | ai_response_cacheWhereInput[]
    OR?: ai_response_cacheWhereInput[]
    NOT?: ai_response_cacheWhereInput | ai_response_cacheWhereInput[]
    input_text?: StringFilter<"ai_response_cache"> | string
    response_data?: JsonFilter<"ai_response_cache">
    interaction_type?: StringFilter<"ai_response_cache"> | string
    hit_count?: IntFilter<"ai_response_cache"> | number
    expires_at?: DateTimeFilter<"ai_response_cache"> | Date | string
    created_at?: DateTimeFilter<"ai_response_cache"> | Date | string
    updated_at?: DateTimeFilter<"ai_response_cache"> | Date | string
  }, "id" | "input_hash">

  export type ai_response_cacheOrderByWithAggregationInput = {
    id?: SortOrder
    input_hash?: SortOrder
    input_text?: SortOrder
    response_data?: SortOrder
    interaction_type?: SortOrder
    hit_count?: SortOrder
    expires_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: ai_response_cacheCountOrderByAggregateInput
    _avg?: ai_response_cacheAvgOrderByAggregateInput
    _max?: ai_response_cacheMaxOrderByAggregateInput
    _min?: ai_response_cacheMinOrderByAggregateInput
    _sum?: ai_response_cacheSumOrderByAggregateInput
  }

  export type ai_response_cacheScalarWhereWithAggregatesInput = {
    AND?: ai_response_cacheScalarWhereWithAggregatesInput | ai_response_cacheScalarWhereWithAggregatesInput[]
    OR?: ai_response_cacheScalarWhereWithAggregatesInput[]
    NOT?: ai_response_cacheScalarWhereWithAggregatesInput | ai_response_cacheScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ai_response_cache"> | number
    input_hash?: StringWithAggregatesFilter<"ai_response_cache"> | string
    input_text?: StringWithAggregatesFilter<"ai_response_cache"> | string
    response_data?: JsonWithAggregatesFilter<"ai_response_cache">
    interaction_type?: StringWithAggregatesFilter<"ai_response_cache"> | string
    hit_count?: IntWithAggregatesFilter<"ai_response_cache"> | number
    expires_at?: DateTimeWithAggregatesFilter<"ai_response_cache"> | Date | string
    created_at?: DateTimeWithAggregatesFilter<"ai_response_cache"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"ai_response_cache"> | Date | string
  }

  export type associated_databasesWhereInput = {
    AND?: associated_databasesWhereInput | associated_databasesWhereInput[]
    OR?: associated_databasesWhereInput[]
    NOT?: associated_databasesWhereInput | associated_databasesWhereInput[]
    id?: IntFilter<"associated_databases"> | number
    name?: StringFilter<"associated_databases"> | string
    type?: StringFilter<"associated_databases"> | string
    url?: StringNullableFilter<"associated_databases"> | string | null
    schema?: StringFilter<"associated_databases"> | string
    description?: StringNullableFilter<"associated_databases"> | string | null
    created_at?: DateTimeFilter<"associated_databases"> | Date | string
    updated_at?: DateTimeFilter<"associated_databases"> | Date | string
  }

  export type associated_databasesOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    url?: SortOrderInput | SortOrder
    schema?: SortOrder
    description?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type associated_databasesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: associated_databasesWhereInput | associated_databasesWhereInput[]
    OR?: associated_databasesWhereInput[]
    NOT?: associated_databasesWhereInput | associated_databasesWhereInput[]
    name?: StringFilter<"associated_databases"> | string
    type?: StringFilter<"associated_databases"> | string
    url?: StringNullableFilter<"associated_databases"> | string | null
    schema?: StringFilter<"associated_databases"> | string
    description?: StringNullableFilter<"associated_databases"> | string | null
    created_at?: DateTimeFilter<"associated_databases"> | Date | string
    updated_at?: DateTimeFilter<"associated_databases"> | Date | string
  }, "id">

  export type associated_databasesOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    url?: SortOrderInput | SortOrder
    schema?: SortOrder
    description?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: associated_databasesCountOrderByAggregateInput
    _avg?: associated_databasesAvgOrderByAggregateInput
    _max?: associated_databasesMaxOrderByAggregateInput
    _min?: associated_databasesMinOrderByAggregateInput
    _sum?: associated_databasesSumOrderByAggregateInput
  }

  export type associated_databasesScalarWhereWithAggregatesInput = {
    AND?: associated_databasesScalarWhereWithAggregatesInput | associated_databasesScalarWhereWithAggregatesInput[]
    OR?: associated_databasesScalarWhereWithAggregatesInput[]
    NOT?: associated_databasesScalarWhereWithAggregatesInput | associated_databasesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"associated_databases"> | number
    name?: StringWithAggregatesFilter<"associated_databases"> | string
    type?: StringWithAggregatesFilter<"associated_databases"> | string
    url?: StringNullableWithAggregatesFilter<"associated_databases"> | string | null
    schema?: StringWithAggregatesFilter<"associated_databases"> | string
    description?: StringNullableWithAggregatesFilter<"associated_databases"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"associated_databases"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"associated_databases"> | Date | string
  }

  export type usersCreateInput = {
    name: string
    email: string
    password_hash: string
    role?: string | null
    created_at?: Date | string
    queries?: queriesCreateNestedManyWithoutUserInput
    history?: historyCreateNestedManyWithoutUserInput
    exports?: exportsCreateNestedManyWithoutUserInput
    suggestions?: suggestionsCreateNestedManyWithoutUserInput
    access_logs?: access_logsCreateNestedManyWithoutUserInput
    ai_chat_sessions?: ai_chat_sessionsCreateNestedManyWithoutUserInput
    ai_interactions?: ai_interactionsCreateNestedManyWithoutUserInput
    ai_insights?: ai_insightsCreateNestedManyWithoutUserInput
  }

  export type usersUncheckedCreateInput = {
    id?: number
    name: string
    email: string
    password_hash: string
    role?: string | null
    created_at?: Date | string
    queries?: queriesUncheckedCreateNestedManyWithoutUserInput
    history?: historyUncheckedCreateNestedManyWithoutUserInput
    exports?: exportsUncheckedCreateNestedManyWithoutUserInput
    suggestions?: suggestionsUncheckedCreateNestedManyWithoutUserInput
    access_logs?: access_logsUncheckedCreateNestedManyWithoutUserInput
    ai_chat_sessions?: ai_chat_sessionsUncheckedCreateNestedManyWithoutUserInput
    ai_interactions?: ai_interactionsUncheckedCreateNestedManyWithoutUserInput
    ai_insights?: ai_insightsUncheckedCreateNestedManyWithoutUserInput
  }

  export type usersUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    queries?: queriesUpdateManyWithoutUserNestedInput
    history?: historyUpdateManyWithoutUserNestedInput
    exports?: exportsUpdateManyWithoutUserNestedInput
    suggestions?: suggestionsUpdateManyWithoutUserNestedInput
    access_logs?: access_logsUpdateManyWithoutUserNestedInput
    ai_chat_sessions?: ai_chat_sessionsUpdateManyWithoutUserNestedInput
    ai_interactions?: ai_interactionsUpdateManyWithoutUserNestedInput
    ai_insights?: ai_insightsUpdateManyWithoutUserNestedInput
  }

  export type usersUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    queries?: queriesUncheckedUpdateManyWithoutUserNestedInput
    history?: historyUncheckedUpdateManyWithoutUserNestedInput
    exports?: exportsUncheckedUpdateManyWithoutUserNestedInput
    suggestions?: suggestionsUncheckedUpdateManyWithoutUserNestedInput
    access_logs?: access_logsUncheckedUpdateManyWithoutUserNestedInput
    ai_chat_sessions?: ai_chat_sessionsUncheckedUpdateManyWithoutUserNestedInput
    ai_interactions?: ai_interactionsUncheckedUpdateManyWithoutUserNestedInput
    ai_insights?: ai_insightsUncheckedUpdateManyWithoutUserNestedInput
  }

  export type usersCreateManyInput = {
    id?: number
    name: string
    email: string
    password_hash: string
    role?: string | null
    created_at?: Date | string
  }

  export type usersUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type usersUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type queriesCreateInput = {
    question_text?: string | null
    created_at?: Date | string
    user: usersCreateNestedOneWithoutQueriesInput
    results?: resultsCreateNestedManyWithoutQueryInput
    history?: historyCreateNestedManyWithoutQueryInput
  }

  export type queriesUncheckedCreateInput = {
    id?: number
    user_id: number
    question_text?: string | null
    created_at?: Date | string
    results?: resultsUncheckedCreateNestedManyWithoutQueryInput
    history?: historyUncheckedCreateNestedManyWithoutQueryInput
  }

  export type queriesUpdateInput = {
    question_text?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: usersUpdateOneRequiredWithoutQueriesNestedInput
    results?: resultsUpdateManyWithoutQueryNestedInput
    history?: historyUpdateManyWithoutQueryNestedInput
  }

  export type queriesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    question_text?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    results?: resultsUncheckedUpdateManyWithoutQueryNestedInput
    history?: historyUncheckedUpdateManyWithoutQueryNestedInput
  }

  export type queriesCreateManyInput = {
    id?: number
    user_id: number
    question_text?: string | null
    created_at?: Date | string
  }

  export type queriesUpdateManyMutationInput = {
    question_text?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type queriesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    question_text?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type resultsCreateInput = {
    result_type?: string | null
    content?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    query: queriesCreateNestedOneWithoutResultsInput
  }

  export type resultsUncheckedCreateInput = {
    id?: number
    query_id: number
    result_type?: string | null
    content?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
  }

  export type resultsUpdateInput = {
    result_type?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    query?: queriesUpdateOneRequiredWithoutResultsNestedInput
  }

  export type resultsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    query_id?: IntFieldUpdateOperationsInput | number
    result_type?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type resultsCreateManyInput = {
    id?: number
    query_id: number
    result_type?: string | null
    content?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
  }

  export type resultsUpdateManyMutationInput = {
    result_type?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type resultsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    query_id?: IntFieldUpdateOperationsInput | number
    result_type?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type historyCreateInput = {
    success?: boolean | null
    execution_time?: number | null
    created_at?: Date | string
    user: usersCreateNestedOneWithoutHistoryInput
    query?: queriesCreateNestedOneWithoutHistoryInput
  }

  export type historyUncheckedCreateInput = {
    id?: number
    user_id: number
    query_id?: number | null
    success?: boolean | null
    execution_time?: number | null
    created_at?: Date | string
  }

  export type historyUpdateInput = {
    success?: NullableBoolFieldUpdateOperationsInput | boolean | null
    execution_time?: NullableFloatFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: usersUpdateOneRequiredWithoutHistoryNestedInput
    query?: queriesUpdateOneWithoutHistoryNestedInput
  }

  export type historyUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    query_id?: NullableIntFieldUpdateOperationsInput | number | null
    success?: NullableBoolFieldUpdateOperationsInput | boolean | null
    execution_time?: NullableFloatFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type historyCreateManyInput = {
    id?: number
    user_id: number
    query_id?: number | null
    success?: boolean | null
    execution_time?: number | null
    created_at?: Date | string
  }

  export type historyUpdateManyMutationInput = {
    success?: NullableBoolFieldUpdateOperationsInput | boolean | null
    execution_time?: NullableFloatFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type historyUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    query_id?: NullableIntFieldUpdateOperationsInput | number | null
    success?: NullableBoolFieldUpdateOperationsInput | boolean | null
    execution_time?: NullableFloatFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type exportsCreateInput = {
    file_type?: string | null
    file_path?: string | null
    created_at?: Date | string
    user: usersCreateNestedOneWithoutExportsInput
  }

  export type exportsUncheckedCreateInput = {
    id?: number
    user_id: number
    file_type?: string | null
    file_path?: string | null
    created_at?: Date | string
  }

  export type exportsUpdateInput = {
    file_type?: NullableStringFieldUpdateOperationsInput | string | null
    file_path?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: usersUpdateOneRequiredWithoutExportsNestedInput
  }

  export type exportsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    file_type?: NullableStringFieldUpdateOperationsInput | string | null
    file_path?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type exportsCreateManyInput = {
    id?: number
    user_id: number
    file_type?: string | null
    file_path?: string | null
    created_at?: Date | string
  }

  export type exportsUpdateManyMutationInput = {
    file_type?: NullableStringFieldUpdateOperationsInput | string | null
    file_path?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type exportsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    file_type?: NullableStringFieldUpdateOperationsInput | string | null
    file_path?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type suggestionsCreateInput = {
    content?: string | null
    source?: string | null
    created_at?: Date | string
    user: usersCreateNestedOneWithoutSuggestionsInput
  }

  export type suggestionsUncheckedCreateInput = {
    id?: number
    user_id: number
    content?: string | null
    source?: string | null
    created_at?: Date | string
  }

  export type suggestionsUpdateInput = {
    content?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: usersUpdateOneRequiredWithoutSuggestionsNestedInput
  }

  export type suggestionsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    content?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type suggestionsCreateManyInput = {
    id?: number
    user_id: number
    content?: string | null
    source?: string | null
    created_at?: Date | string
  }

  export type suggestionsUpdateManyMutationInput = {
    content?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type suggestionsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    content?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type access_logsCreateInput = {
    action?: string | null
    ip_address?: string | null
    created_at?: Date | string
    user?: usersCreateNestedOneWithoutAccess_logsInput
  }

  export type access_logsUncheckedCreateInput = {
    id?: number
    user_id?: number | null
    action?: string | null
    ip_address?: string | null
    created_at?: Date | string
  }

  export type access_logsUpdateInput = {
    action?: NullableStringFieldUpdateOperationsInput | string | null
    ip_address?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: usersUpdateOneWithoutAccess_logsNestedInput
  }

  export type access_logsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    action?: NullableStringFieldUpdateOperationsInput | string | null
    ip_address?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type access_logsCreateManyInput = {
    id?: number
    user_id?: number | null
    action?: string | null
    ip_address?: string | null
    created_at?: Date | string
  }

  export type access_logsUpdateManyMutationInput = {
    action?: NullableStringFieldUpdateOperationsInput | string | null
    ip_address?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type access_logsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    action?: NullableStringFieldUpdateOperationsInput | string | null
    ip_address?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ai_chat_sessionsCreateInput = {
    session_token: string
    status?: string
    context_data?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
    user: usersCreateNestedOneWithoutAi_chat_sessionsInput
    interactions?: ai_interactionsCreateNestedManyWithoutSessionInput
  }

  export type ai_chat_sessionsUncheckedCreateInput = {
    id?: number
    user_id: number
    session_token: string
    status?: string
    context_data?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
    interactions?: ai_interactionsUncheckedCreateNestedManyWithoutSessionInput
  }

  export type ai_chat_sessionsUpdateInput = {
    session_token?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    context_data?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: usersUpdateOneRequiredWithoutAi_chat_sessionsNestedInput
    interactions?: ai_interactionsUpdateManyWithoutSessionNestedInput
  }

  export type ai_chat_sessionsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    session_token?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    context_data?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    interactions?: ai_interactionsUncheckedUpdateManyWithoutSessionNestedInput
  }

  export type ai_chat_sessionsCreateManyInput = {
    id?: number
    user_id: number
    session_token: string
    status?: string
    context_data?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ai_chat_sessionsUpdateManyMutationInput = {
    session_token?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    context_data?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ai_chat_sessionsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    session_token?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    context_data?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ai_interactionsCreateInput = {
    interaction_type: string
    input_text: string
    input_language?: string
    processed_query?: string | null
    ai_response?: NullableJsonNullValueInput | InputJsonValue
    execution_status?: string
    execution_time_ms?: number | null
    confidence_score?: number | null
    error_message?: string | null
    fallback_used?: boolean
    version?: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    session: ai_chat_sessionsCreateNestedOneWithoutInteractionsInput
    user: usersCreateNestedOneWithoutAi_interactionsInput
    insights?: ai_insightsCreateNestedManyWithoutInteractionInput
  }

  export type ai_interactionsUncheckedCreateInput = {
    id?: number
    session_id: number
    user_id: number
    interaction_type: string
    input_text: string
    input_language?: string
    processed_query?: string | null
    ai_response?: NullableJsonNullValueInput | InputJsonValue
    execution_status?: string
    execution_time_ms?: number | null
    confidence_score?: number | null
    error_message?: string | null
    fallback_used?: boolean
    version?: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    insights?: ai_insightsUncheckedCreateNestedManyWithoutInteractionInput
  }

  export type ai_interactionsUpdateInput = {
    interaction_type?: StringFieldUpdateOperationsInput | string
    input_text?: StringFieldUpdateOperationsInput | string
    input_language?: StringFieldUpdateOperationsInput | string
    processed_query?: NullableStringFieldUpdateOperationsInput | string | null
    ai_response?: NullableJsonNullValueInput | InputJsonValue
    execution_status?: StringFieldUpdateOperationsInput | string
    execution_time_ms?: NullableIntFieldUpdateOperationsInput | number | null
    confidence_score?: NullableFloatFieldUpdateOperationsInput | number | null
    error_message?: NullableStringFieldUpdateOperationsInput | string | null
    fallback_used?: BoolFieldUpdateOperationsInput | boolean
    version?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    session?: ai_chat_sessionsUpdateOneRequiredWithoutInteractionsNestedInput
    user?: usersUpdateOneRequiredWithoutAi_interactionsNestedInput
    insights?: ai_insightsUpdateManyWithoutInteractionNestedInput
  }

  export type ai_interactionsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    session_id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    interaction_type?: StringFieldUpdateOperationsInput | string
    input_text?: StringFieldUpdateOperationsInput | string
    input_language?: StringFieldUpdateOperationsInput | string
    processed_query?: NullableStringFieldUpdateOperationsInput | string | null
    ai_response?: NullableJsonNullValueInput | InputJsonValue
    execution_status?: StringFieldUpdateOperationsInput | string
    execution_time_ms?: NullableIntFieldUpdateOperationsInput | number | null
    confidence_score?: NullableFloatFieldUpdateOperationsInput | number | null
    error_message?: NullableStringFieldUpdateOperationsInput | string | null
    fallback_used?: BoolFieldUpdateOperationsInput | boolean
    version?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    insights?: ai_insightsUncheckedUpdateManyWithoutInteractionNestedInput
  }

  export type ai_interactionsCreateManyInput = {
    id?: number
    session_id: number
    user_id: number
    interaction_type: string
    input_text: string
    input_language?: string
    processed_query?: string | null
    ai_response?: NullableJsonNullValueInput | InputJsonValue
    execution_status?: string
    execution_time_ms?: number | null
    confidence_score?: number | null
    error_message?: string | null
    fallback_used?: boolean
    version?: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
  }

  export type ai_interactionsUpdateManyMutationInput = {
    interaction_type?: StringFieldUpdateOperationsInput | string
    input_text?: StringFieldUpdateOperationsInput | string
    input_language?: StringFieldUpdateOperationsInput | string
    processed_query?: NullableStringFieldUpdateOperationsInput | string | null
    ai_response?: NullableJsonNullValueInput | InputJsonValue
    execution_status?: StringFieldUpdateOperationsInput | string
    execution_time_ms?: NullableIntFieldUpdateOperationsInput | number | null
    confidence_score?: NullableFloatFieldUpdateOperationsInput | number | null
    error_message?: NullableStringFieldUpdateOperationsInput | string | null
    fallback_used?: BoolFieldUpdateOperationsInput | boolean
    version?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ai_interactionsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    session_id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    interaction_type?: StringFieldUpdateOperationsInput | string
    input_text?: StringFieldUpdateOperationsInput | string
    input_language?: StringFieldUpdateOperationsInput | string
    processed_query?: NullableStringFieldUpdateOperationsInput | string | null
    ai_response?: NullableJsonNullValueInput | InputJsonValue
    execution_status?: StringFieldUpdateOperationsInput | string
    execution_time_ms?: NullableIntFieldUpdateOperationsInput | number | null
    confidence_score?: NullableFloatFieldUpdateOperationsInput | number | null
    error_message?: NullableStringFieldUpdateOperationsInput | string | null
    fallback_used?: BoolFieldUpdateOperationsInput | boolean
    version?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ai_insightsCreateInput = {
    insight_type: string
    title: string
    description: string
    data_analysis: JsonNullValueInput | InputJsonValue
    confidence_level: string
    impact_score?: number | null
    status?: string
    expires_at?: Date | string | null
    created_at?: Date | string
    interaction?: ai_interactionsCreateNestedOneWithoutInsightsInput
    user: usersCreateNestedOneWithoutAi_insightsInput
  }

  export type ai_insightsUncheckedCreateInput = {
    id?: number
    interaction_id?: number | null
    user_id: number
    insight_type: string
    title: string
    description: string
    data_analysis: JsonNullValueInput | InputJsonValue
    confidence_level: string
    impact_score?: number | null
    status?: string
    expires_at?: Date | string | null
    created_at?: Date | string
  }

  export type ai_insightsUpdateInput = {
    insight_type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    data_analysis?: JsonNullValueInput | InputJsonValue
    confidence_level?: StringFieldUpdateOperationsInput | string
    impact_score?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    expires_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    interaction?: ai_interactionsUpdateOneWithoutInsightsNestedInput
    user?: usersUpdateOneRequiredWithoutAi_insightsNestedInput
  }

  export type ai_insightsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    interaction_id?: NullableIntFieldUpdateOperationsInput | number | null
    user_id?: IntFieldUpdateOperationsInput | number
    insight_type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    data_analysis?: JsonNullValueInput | InputJsonValue
    confidence_level?: StringFieldUpdateOperationsInput | string
    impact_score?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    expires_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ai_insightsCreateManyInput = {
    id?: number
    interaction_id?: number | null
    user_id: number
    insight_type: string
    title: string
    description: string
    data_analysis: JsonNullValueInput | InputJsonValue
    confidence_level: string
    impact_score?: number | null
    status?: string
    expires_at?: Date | string | null
    created_at?: Date | string
  }

  export type ai_insightsUpdateManyMutationInput = {
    insight_type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    data_analysis?: JsonNullValueInput | InputJsonValue
    confidence_level?: StringFieldUpdateOperationsInput | string
    impact_score?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    expires_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ai_insightsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    interaction_id?: NullableIntFieldUpdateOperationsInput | number | null
    user_id?: IntFieldUpdateOperationsInput | number
    insight_type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    data_analysis?: JsonNullValueInput | InputJsonValue
    confidence_level?: StringFieldUpdateOperationsInput | string
    impact_score?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    expires_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ai_fallbacksCreateInput = {
    trigger_pattern: string
    fallback_type: string
    response_template: string
    escalation_level?: number
    is_active?: boolean
    usage_count?: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ai_fallbacksUncheckedCreateInput = {
    id?: number
    trigger_pattern: string
    fallback_type: string
    response_template: string
    escalation_level?: number
    is_active?: boolean
    usage_count?: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ai_fallbacksUpdateInput = {
    trigger_pattern?: StringFieldUpdateOperationsInput | string
    fallback_type?: StringFieldUpdateOperationsInput | string
    response_template?: StringFieldUpdateOperationsInput | string
    escalation_level?: IntFieldUpdateOperationsInput | number
    is_active?: BoolFieldUpdateOperationsInput | boolean
    usage_count?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ai_fallbacksUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    trigger_pattern?: StringFieldUpdateOperationsInput | string
    fallback_type?: StringFieldUpdateOperationsInput | string
    response_template?: StringFieldUpdateOperationsInput | string
    escalation_level?: IntFieldUpdateOperationsInput | number
    is_active?: BoolFieldUpdateOperationsInput | boolean
    usage_count?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ai_fallbacksCreateManyInput = {
    id?: number
    trigger_pattern: string
    fallback_type: string
    response_template: string
    escalation_level?: number
    is_active?: boolean
    usage_count?: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ai_fallbacksUpdateManyMutationInput = {
    trigger_pattern?: StringFieldUpdateOperationsInput | string
    fallback_type?: StringFieldUpdateOperationsInput | string
    response_template?: StringFieldUpdateOperationsInput | string
    escalation_level?: IntFieldUpdateOperationsInput | number
    is_active?: BoolFieldUpdateOperationsInput | boolean
    usage_count?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ai_fallbacksUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    trigger_pattern?: StringFieldUpdateOperationsInput | string
    fallback_type?: StringFieldUpdateOperationsInput | string
    response_template?: StringFieldUpdateOperationsInput | string
    escalation_level?: IntFieldUpdateOperationsInput | number
    is_active?: BoolFieldUpdateOperationsInput | boolean
    usage_count?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ai_response_cacheCreateInput = {
    input_hash: string
    input_text: string
    response_data: JsonNullValueInput | InputJsonValue
    interaction_type: string
    hit_count?: number
    expires_at: Date | string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ai_response_cacheUncheckedCreateInput = {
    id?: number
    input_hash: string
    input_text: string
    response_data: JsonNullValueInput | InputJsonValue
    interaction_type: string
    hit_count?: number
    expires_at: Date | string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ai_response_cacheUpdateInput = {
    input_hash?: StringFieldUpdateOperationsInput | string
    input_text?: StringFieldUpdateOperationsInput | string
    response_data?: JsonNullValueInput | InputJsonValue
    interaction_type?: StringFieldUpdateOperationsInput | string
    hit_count?: IntFieldUpdateOperationsInput | number
    expires_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ai_response_cacheUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    input_hash?: StringFieldUpdateOperationsInput | string
    input_text?: StringFieldUpdateOperationsInput | string
    response_data?: JsonNullValueInput | InputJsonValue
    interaction_type?: StringFieldUpdateOperationsInput | string
    hit_count?: IntFieldUpdateOperationsInput | number
    expires_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ai_response_cacheCreateManyInput = {
    id?: number
    input_hash: string
    input_text: string
    response_data: JsonNullValueInput | InputJsonValue
    interaction_type: string
    hit_count?: number
    expires_at: Date | string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ai_response_cacheUpdateManyMutationInput = {
    input_hash?: StringFieldUpdateOperationsInput | string
    input_text?: StringFieldUpdateOperationsInput | string
    response_data?: JsonNullValueInput | InputJsonValue
    interaction_type?: StringFieldUpdateOperationsInput | string
    hit_count?: IntFieldUpdateOperationsInput | number
    expires_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ai_response_cacheUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    input_hash?: StringFieldUpdateOperationsInput | string
    input_text?: StringFieldUpdateOperationsInput | string
    response_data?: JsonNullValueInput | InputJsonValue
    interaction_type?: StringFieldUpdateOperationsInput | string
    hit_count?: IntFieldUpdateOperationsInput | number
    expires_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type associated_databasesCreateInput = {
    name: string
    type: string
    url?: string | null
    schema: string
    description?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type associated_databasesUncheckedCreateInput = {
    id?: number
    name: string
    type: string
    url?: string | null
    schema: string
    description?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type associated_databasesUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    schema?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type associated_databasesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    schema?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type associated_databasesCreateManyInput = {
    id?: number
    name: string
    type: string
    url?: string | null
    schema: string
    description?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type associated_databasesUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    schema?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type associated_databasesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    schema?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type QueriesListRelationFilter = {
    every?: queriesWhereInput
    some?: queriesWhereInput
    none?: queriesWhereInput
  }

  export type HistoryListRelationFilter = {
    every?: historyWhereInput
    some?: historyWhereInput
    none?: historyWhereInput
  }

  export type ExportsListRelationFilter = {
    every?: exportsWhereInput
    some?: exportsWhereInput
    none?: exportsWhereInput
  }

  export type SuggestionsListRelationFilter = {
    every?: suggestionsWhereInput
    some?: suggestionsWhereInput
    none?: suggestionsWhereInput
  }

  export type Access_logsListRelationFilter = {
    every?: access_logsWhereInput
    some?: access_logsWhereInput
    none?: access_logsWhereInput
  }

  export type Ai_chat_sessionsListRelationFilter = {
    every?: ai_chat_sessionsWhereInput
    some?: ai_chat_sessionsWhereInput
    none?: ai_chat_sessionsWhereInput
  }

  export type Ai_interactionsListRelationFilter = {
    every?: ai_interactionsWhereInput
    some?: ai_interactionsWhereInput
    none?: ai_interactionsWhereInput
  }

  export type Ai_insightsListRelationFilter = {
    every?: ai_insightsWhereInput
    some?: ai_insightsWhereInput
    none?: ai_insightsWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type queriesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type historyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type exportsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type suggestionsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type access_logsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ai_chat_sessionsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ai_interactionsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ai_insightsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type usersCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password_hash?: SortOrder
    role?: SortOrder
    created_at?: SortOrder
  }

  export type usersAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type usersMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password_hash?: SortOrder
    role?: SortOrder
    created_at?: SortOrder
  }

  export type usersMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password_hash?: SortOrder
    role?: SortOrder
    created_at?: SortOrder
  }

  export type usersSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type UsersScalarRelationFilter = {
    is?: usersWhereInput
    isNot?: usersWhereInput
  }

  export type ResultsListRelationFilter = {
    every?: resultsWhereInput
    some?: resultsWhereInput
    none?: resultsWhereInput
  }

  export type resultsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type queriesCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    question_text?: SortOrder
    created_at?: SortOrder
  }

  export type queriesAvgOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
  }

  export type queriesMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    question_text?: SortOrder
    created_at?: SortOrder
  }

  export type queriesMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    question_text?: SortOrder
    created_at?: SortOrder
  }

  export type queriesSumOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type QueriesScalarRelationFilter = {
    is?: queriesWhereInput
    isNot?: queriesWhereInput
  }

  export type resultsCountOrderByAggregateInput = {
    id?: SortOrder
    query_id?: SortOrder
    result_type?: SortOrder
    content?: SortOrder
    created_at?: SortOrder
  }

  export type resultsAvgOrderByAggregateInput = {
    id?: SortOrder
    query_id?: SortOrder
  }

  export type resultsMaxOrderByAggregateInput = {
    id?: SortOrder
    query_id?: SortOrder
    result_type?: SortOrder
    created_at?: SortOrder
  }

  export type resultsMinOrderByAggregateInput = {
    id?: SortOrder
    query_id?: SortOrder
    result_type?: SortOrder
    created_at?: SortOrder
  }

  export type resultsSumOrderByAggregateInput = {
    id?: SortOrder
    query_id?: SortOrder
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type QueriesNullableScalarRelationFilter = {
    is?: queriesWhereInput | null
    isNot?: queriesWhereInput | null
  }

  export type historyCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    query_id?: SortOrder
    success?: SortOrder
    execution_time?: SortOrder
    created_at?: SortOrder
  }

  export type historyAvgOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    query_id?: SortOrder
    execution_time?: SortOrder
  }

  export type historyMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    query_id?: SortOrder
    success?: SortOrder
    execution_time?: SortOrder
    created_at?: SortOrder
  }

  export type historyMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    query_id?: SortOrder
    success?: SortOrder
    execution_time?: SortOrder
    created_at?: SortOrder
  }

  export type historySumOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    query_id?: SortOrder
    execution_time?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type exportsCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    file_type?: SortOrder
    file_path?: SortOrder
    created_at?: SortOrder
  }

  export type exportsAvgOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
  }

  export type exportsMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    file_type?: SortOrder
    file_path?: SortOrder
    created_at?: SortOrder
  }

  export type exportsMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    file_type?: SortOrder
    file_path?: SortOrder
    created_at?: SortOrder
  }

  export type exportsSumOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
  }

  export type suggestionsCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    content?: SortOrder
    source?: SortOrder
    created_at?: SortOrder
  }

  export type suggestionsAvgOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
  }

  export type suggestionsMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    content?: SortOrder
    source?: SortOrder
    created_at?: SortOrder
  }

  export type suggestionsMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    content?: SortOrder
    source?: SortOrder
    created_at?: SortOrder
  }

  export type suggestionsSumOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
  }

  export type UsersNullableScalarRelationFilter = {
    is?: usersWhereInput | null
    isNot?: usersWhereInput | null
  }

  export type access_logsCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    action?: SortOrder
    ip_address?: SortOrder
    created_at?: SortOrder
  }

  export type access_logsAvgOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
  }

  export type access_logsMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    action?: SortOrder
    ip_address?: SortOrder
    created_at?: SortOrder
  }

  export type access_logsMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    action?: SortOrder
    ip_address?: SortOrder
    created_at?: SortOrder
  }

  export type access_logsSumOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
  }

  export type ai_chat_sessionsCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    session_token?: SortOrder
    status?: SortOrder
    context_data?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ai_chat_sessionsAvgOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
  }

  export type ai_chat_sessionsMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    session_token?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ai_chat_sessionsMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    session_token?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ai_chat_sessionsSumOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type Ai_chat_sessionsScalarRelationFilter = {
    is?: ai_chat_sessionsWhereInput
    isNot?: ai_chat_sessionsWhereInput
  }

  export type ai_interactionsCountOrderByAggregateInput = {
    id?: SortOrder
    session_id?: SortOrder
    user_id?: SortOrder
    interaction_type?: SortOrder
    input_text?: SortOrder
    input_language?: SortOrder
    processed_query?: SortOrder
    ai_response?: SortOrder
    execution_status?: SortOrder
    execution_time_ms?: SortOrder
    confidence_score?: SortOrder
    error_message?: SortOrder
    fallback_used?: SortOrder
    version?: SortOrder
    metadata?: SortOrder
    created_at?: SortOrder
  }

  export type ai_interactionsAvgOrderByAggregateInput = {
    id?: SortOrder
    session_id?: SortOrder
    user_id?: SortOrder
    execution_time_ms?: SortOrder
    confidence_score?: SortOrder
  }

  export type ai_interactionsMaxOrderByAggregateInput = {
    id?: SortOrder
    session_id?: SortOrder
    user_id?: SortOrder
    interaction_type?: SortOrder
    input_text?: SortOrder
    input_language?: SortOrder
    processed_query?: SortOrder
    execution_status?: SortOrder
    execution_time_ms?: SortOrder
    confidence_score?: SortOrder
    error_message?: SortOrder
    fallback_used?: SortOrder
    version?: SortOrder
    created_at?: SortOrder
  }

  export type ai_interactionsMinOrderByAggregateInput = {
    id?: SortOrder
    session_id?: SortOrder
    user_id?: SortOrder
    interaction_type?: SortOrder
    input_text?: SortOrder
    input_language?: SortOrder
    processed_query?: SortOrder
    execution_status?: SortOrder
    execution_time_ms?: SortOrder
    confidence_score?: SortOrder
    error_message?: SortOrder
    fallback_used?: SortOrder
    version?: SortOrder
    created_at?: SortOrder
  }

  export type ai_interactionsSumOrderByAggregateInput = {
    id?: SortOrder
    session_id?: SortOrder
    user_id?: SortOrder
    execution_time_ms?: SortOrder
    confidence_score?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }
  export type JsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type Ai_interactionsNullableScalarRelationFilter = {
    is?: ai_interactionsWhereInput | null
    isNot?: ai_interactionsWhereInput | null
  }

  export type ai_insightsCountOrderByAggregateInput = {
    id?: SortOrder
    interaction_id?: SortOrder
    user_id?: SortOrder
    insight_type?: SortOrder
    title?: SortOrder
    description?: SortOrder
    data_analysis?: SortOrder
    confidence_level?: SortOrder
    impact_score?: SortOrder
    status?: SortOrder
    expires_at?: SortOrder
    created_at?: SortOrder
  }

  export type ai_insightsAvgOrderByAggregateInput = {
    id?: SortOrder
    interaction_id?: SortOrder
    user_id?: SortOrder
    impact_score?: SortOrder
  }

  export type ai_insightsMaxOrderByAggregateInput = {
    id?: SortOrder
    interaction_id?: SortOrder
    user_id?: SortOrder
    insight_type?: SortOrder
    title?: SortOrder
    description?: SortOrder
    confidence_level?: SortOrder
    impact_score?: SortOrder
    status?: SortOrder
    expires_at?: SortOrder
    created_at?: SortOrder
  }

  export type ai_insightsMinOrderByAggregateInput = {
    id?: SortOrder
    interaction_id?: SortOrder
    user_id?: SortOrder
    insight_type?: SortOrder
    title?: SortOrder
    description?: SortOrder
    confidence_level?: SortOrder
    impact_score?: SortOrder
    status?: SortOrder
    expires_at?: SortOrder
    created_at?: SortOrder
  }

  export type ai_insightsSumOrderByAggregateInput = {
    id?: SortOrder
    interaction_id?: SortOrder
    user_id?: SortOrder
    impact_score?: SortOrder
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type ai_fallbacksCountOrderByAggregateInput = {
    id?: SortOrder
    trigger_pattern?: SortOrder
    fallback_type?: SortOrder
    response_template?: SortOrder
    escalation_level?: SortOrder
    is_active?: SortOrder
    usage_count?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ai_fallbacksAvgOrderByAggregateInput = {
    id?: SortOrder
    escalation_level?: SortOrder
    usage_count?: SortOrder
  }

  export type ai_fallbacksMaxOrderByAggregateInput = {
    id?: SortOrder
    trigger_pattern?: SortOrder
    fallback_type?: SortOrder
    response_template?: SortOrder
    escalation_level?: SortOrder
    is_active?: SortOrder
    usage_count?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ai_fallbacksMinOrderByAggregateInput = {
    id?: SortOrder
    trigger_pattern?: SortOrder
    fallback_type?: SortOrder
    response_template?: SortOrder
    escalation_level?: SortOrder
    is_active?: SortOrder
    usage_count?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ai_fallbacksSumOrderByAggregateInput = {
    id?: SortOrder
    escalation_level?: SortOrder
    usage_count?: SortOrder
  }

  export type ai_response_cacheCountOrderByAggregateInput = {
    id?: SortOrder
    input_hash?: SortOrder
    input_text?: SortOrder
    response_data?: SortOrder
    interaction_type?: SortOrder
    hit_count?: SortOrder
    expires_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ai_response_cacheAvgOrderByAggregateInput = {
    id?: SortOrder
    hit_count?: SortOrder
  }

  export type ai_response_cacheMaxOrderByAggregateInput = {
    id?: SortOrder
    input_hash?: SortOrder
    input_text?: SortOrder
    interaction_type?: SortOrder
    hit_count?: SortOrder
    expires_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ai_response_cacheMinOrderByAggregateInput = {
    id?: SortOrder
    input_hash?: SortOrder
    input_text?: SortOrder
    interaction_type?: SortOrder
    hit_count?: SortOrder
    expires_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ai_response_cacheSumOrderByAggregateInput = {
    id?: SortOrder
    hit_count?: SortOrder
  }

  export type associated_databasesCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    url?: SortOrder
    schema?: SortOrder
    description?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type associated_databasesAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type associated_databasesMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    url?: SortOrder
    schema?: SortOrder
    description?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type associated_databasesMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    url?: SortOrder
    schema?: SortOrder
    description?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type associated_databasesSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type queriesCreateNestedManyWithoutUserInput = {
    create?: XOR<queriesCreateWithoutUserInput, queriesUncheckedCreateWithoutUserInput> | queriesCreateWithoutUserInput[] | queriesUncheckedCreateWithoutUserInput[]
    connectOrCreate?: queriesCreateOrConnectWithoutUserInput | queriesCreateOrConnectWithoutUserInput[]
    createMany?: queriesCreateManyUserInputEnvelope
    connect?: queriesWhereUniqueInput | queriesWhereUniqueInput[]
  }

  export type historyCreateNestedManyWithoutUserInput = {
    create?: XOR<historyCreateWithoutUserInput, historyUncheckedCreateWithoutUserInput> | historyCreateWithoutUserInput[] | historyUncheckedCreateWithoutUserInput[]
    connectOrCreate?: historyCreateOrConnectWithoutUserInput | historyCreateOrConnectWithoutUserInput[]
    createMany?: historyCreateManyUserInputEnvelope
    connect?: historyWhereUniqueInput | historyWhereUniqueInput[]
  }

  export type exportsCreateNestedManyWithoutUserInput = {
    create?: XOR<exportsCreateWithoutUserInput, exportsUncheckedCreateWithoutUserInput> | exportsCreateWithoutUserInput[] | exportsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: exportsCreateOrConnectWithoutUserInput | exportsCreateOrConnectWithoutUserInput[]
    createMany?: exportsCreateManyUserInputEnvelope
    connect?: exportsWhereUniqueInput | exportsWhereUniqueInput[]
  }

  export type suggestionsCreateNestedManyWithoutUserInput = {
    create?: XOR<suggestionsCreateWithoutUserInput, suggestionsUncheckedCreateWithoutUserInput> | suggestionsCreateWithoutUserInput[] | suggestionsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: suggestionsCreateOrConnectWithoutUserInput | suggestionsCreateOrConnectWithoutUserInput[]
    createMany?: suggestionsCreateManyUserInputEnvelope
    connect?: suggestionsWhereUniqueInput | suggestionsWhereUniqueInput[]
  }

  export type access_logsCreateNestedManyWithoutUserInput = {
    create?: XOR<access_logsCreateWithoutUserInput, access_logsUncheckedCreateWithoutUserInput> | access_logsCreateWithoutUserInput[] | access_logsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: access_logsCreateOrConnectWithoutUserInput | access_logsCreateOrConnectWithoutUserInput[]
    createMany?: access_logsCreateManyUserInputEnvelope
    connect?: access_logsWhereUniqueInput | access_logsWhereUniqueInput[]
  }

  export type ai_chat_sessionsCreateNestedManyWithoutUserInput = {
    create?: XOR<ai_chat_sessionsCreateWithoutUserInput, ai_chat_sessionsUncheckedCreateWithoutUserInput> | ai_chat_sessionsCreateWithoutUserInput[] | ai_chat_sessionsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ai_chat_sessionsCreateOrConnectWithoutUserInput | ai_chat_sessionsCreateOrConnectWithoutUserInput[]
    createMany?: ai_chat_sessionsCreateManyUserInputEnvelope
    connect?: ai_chat_sessionsWhereUniqueInput | ai_chat_sessionsWhereUniqueInput[]
  }

  export type ai_interactionsCreateNestedManyWithoutUserInput = {
    create?: XOR<ai_interactionsCreateWithoutUserInput, ai_interactionsUncheckedCreateWithoutUserInput> | ai_interactionsCreateWithoutUserInput[] | ai_interactionsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ai_interactionsCreateOrConnectWithoutUserInput | ai_interactionsCreateOrConnectWithoutUserInput[]
    createMany?: ai_interactionsCreateManyUserInputEnvelope
    connect?: ai_interactionsWhereUniqueInput | ai_interactionsWhereUniqueInput[]
  }

  export type ai_insightsCreateNestedManyWithoutUserInput = {
    create?: XOR<ai_insightsCreateWithoutUserInput, ai_insightsUncheckedCreateWithoutUserInput> | ai_insightsCreateWithoutUserInput[] | ai_insightsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ai_insightsCreateOrConnectWithoutUserInput | ai_insightsCreateOrConnectWithoutUserInput[]
    createMany?: ai_insightsCreateManyUserInputEnvelope
    connect?: ai_insightsWhereUniqueInput | ai_insightsWhereUniqueInput[]
  }

  export type queriesUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<queriesCreateWithoutUserInput, queriesUncheckedCreateWithoutUserInput> | queriesCreateWithoutUserInput[] | queriesUncheckedCreateWithoutUserInput[]
    connectOrCreate?: queriesCreateOrConnectWithoutUserInput | queriesCreateOrConnectWithoutUserInput[]
    createMany?: queriesCreateManyUserInputEnvelope
    connect?: queriesWhereUniqueInput | queriesWhereUniqueInput[]
  }

  export type historyUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<historyCreateWithoutUserInput, historyUncheckedCreateWithoutUserInput> | historyCreateWithoutUserInput[] | historyUncheckedCreateWithoutUserInput[]
    connectOrCreate?: historyCreateOrConnectWithoutUserInput | historyCreateOrConnectWithoutUserInput[]
    createMany?: historyCreateManyUserInputEnvelope
    connect?: historyWhereUniqueInput | historyWhereUniqueInput[]
  }

  export type exportsUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<exportsCreateWithoutUserInput, exportsUncheckedCreateWithoutUserInput> | exportsCreateWithoutUserInput[] | exportsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: exportsCreateOrConnectWithoutUserInput | exportsCreateOrConnectWithoutUserInput[]
    createMany?: exportsCreateManyUserInputEnvelope
    connect?: exportsWhereUniqueInput | exportsWhereUniqueInput[]
  }

  export type suggestionsUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<suggestionsCreateWithoutUserInput, suggestionsUncheckedCreateWithoutUserInput> | suggestionsCreateWithoutUserInput[] | suggestionsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: suggestionsCreateOrConnectWithoutUserInput | suggestionsCreateOrConnectWithoutUserInput[]
    createMany?: suggestionsCreateManyUserInputEnvelope
    connect?: suggestionsWhereUniqueInput | suggestionsWhereUniqueInput[]
  }

  export type access_logsUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<access_logsCreateWithoutUserInput, access_logsUncheckedCreateWithoutUserInput> | access_logsCreateWithoutUserInput[] | access_logsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: access_logsCreateOrConnectWithoutUserInput | access_logsCreateOrConnectWithoutUserInput[]
    createMany?: access_logsCreateManyUserInputEnvelope
    connect?: access_logsWhereUniqueInput | access_logsWhereUniqueInput[]
  }

  export type ai_chat_sessionsUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ai_chat_sessionsCreateWithoutUserInput, ai_chat_sessionsUncheckedCreateWithoutUserInput> | ai_chat_sessionsCreateWithoutUserInput[] | ai_chat_sessionsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ai_chat_sessionsCreateOrConnectWithoutUserInput | ai_chat_sessionsCreateOrConnectWithoutUserInput[]
    createMany?: ai_chat_sessionsCreateManyUserInputEnvelope
    connect?: ai_chat_sessionsWhereUniqueInput | ai_chat_sessionsWhereUniqueInput[]
  }

  export type ai_interactionsUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ai_interactionsCreateWithoutUserInput, ai_interactionsUncheckedCreateWithoutUserInput> | ai_interactionsCreateWithoutUserInput[] | ai_interactionsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ai_interactionsCreateOrConnectWithoutUserInput | ai_interactionsCreateOrConnectWithoutUserInput[]
    createMany?: ai_interactionsCreateManyUserInputEnvelope
    connect?: ai_interactionsWhereUniqueInput | ai_interactionsWhereUniqueInput[]
  }

  export type ai_insightsUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ai_insightsCreateWithoutUserInput, ai_insightsUncheckedCreateWithoutUserInput> | ai_insightsCreateWithoutUserInput[] | ai_insightsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ai_insightsCreateOrConnectWithoutUserInput | ai_insightsCreateOrConnectWithoutUserInput[]
    createMany?: ai_insightsCreateManyUserInputEnvelope
    connect?: ai_insightsWhereUniqueInput | ai_insightsWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type queriesUpdateManyWithoutUserNestedInput = {
    create?: XOR<queriesCreateWithoutUserInput, queriesUncheckedCreateWithoutUserInput> | queriesCreateWithoutUserInput[] | queriesUncheckedCreateWithoutUserInput[]
    connectOrCreate?: queriesCreateOrConnectWithoutUserInput | queriesCreateOrConnectWithoutUserInput[]
    upsert?: queriesUpsertWithWhereUniqueWithoutUserInput | queriesUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: queriesCreateManyUserInputEnvelope
    set?: queriesWhereUniqueInput | queriesWhereUniqueInput[]
    disconnect?: queriesWhereUniqueInput | queriesWhereUniqueInput[]
    delete?: queriesWhereUniqueInput | queriesWhereUniqueInput[]
    connect?: queriesWhereUniqueInput | queriesWhereUniqueInput[]
    update?: queriesUpdateWithWhereUniqueWithoutUserInput | queriesUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: queriesUpdateManyWithWhereWithoutUserInput | queriesUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: queriesScalarWhereInput | queriesScalarWhereInput[]
  }

  export type historyUpdateManyWithoutUserNestedInput = {
    create?: XOR<historyCreateWithoutUserInput, historyUncheckedCreateWithoutUserInput> | historyCreateWithoutUserInput[] | historyUncheckedCreateWithoutUserInput[]
    connectOrCreate?: historyCreateOrConnectWithoutUserInput | historyCreateOrConnectWithoutUserInput[]
    upsert?: historyUpsertWithWhereUniqueWithoutUserInput | historyUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: historyCreateManyUserInputEnvelope
    set?: historyWhereUniqueInput | historyWhereUniqueInput[]
    disconnect?: historyWhereUniqueInput | historyWhereUniqueInput[]
    delete?: historyWhereUniqueInput | historyWhereUniqueInput[]
    connect?: historyWhereUniqueInput | historyWhereUniqueInput[]
    update?: historyUpdateWithWhereUniqueWithoutUserInput | historyUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: historyUpdateManyWithWhereWithoutUserInput | historyUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: historyScalarWhereInput | historyScalarWhereInput[]
  }

  export type exportsUpdateManyWithoutUserNestedInput = {
    create?: XOR<exportsCreateWithoutUserInput, exportsUncheckedCreateWithoutUserInput> | exportsCreateWithoutUserInput[] | exportsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: exportsCreateOrConnectWithoutUserInput | exportsCreateOrConnectWithoutUserInput[]
    upsert?: exportsUpsertWithWhereUniqueWithoutUserInput | exportsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: exportsCreateManyUserInputEnvelope
    set?: exportsWhereUniqueInput | exportsWhereUniqueInput[]
    disconnect?: exportsWhereUniqueInput | exportsWhereUniqueInput[]
    delete?: exportsWhereUniqueInput | exportsWhereUniqueInput[]
    connect?: exportsWhereUniqueInput | exportsWhereUniqueInput[]
    update?: exportsUpdateWithWhereUniqueWithoutUserInput | exportsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: exportsUpdateManyWithWhereWithoutUserInput | exportsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: exportsScalarWhereInput | exportsScalarWhereInput[]
  }

  export type suggestionsUpdateManyWithoutUserNestedInput = {
    create?: XOR<suggestionsCreateWithoutUserInput, suggestionsUncheckedCreateWithoutUserInput> | suggestionsCreateWithoutUserInput[] | suggestionsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: suggestionsCreateOrConnectWithoutUserInput | suggestionsCreateOrConnectWithoutUserInput[]
    upsert?: suggestionsUpsertWithWhereUniqueWithoutUserInput | suggestionsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: suggestionsCreateManyUserInputEnvelope
    set?: suggestionsWhereUniqueInput | suggestionsWhereUniqueInput[]
    disconnect?: suggestionsWhereUniqueInput | suggestionsWhereUniqueInput[]
    delete?: suggestionsWhereUniqueInput | suggestionsWhereUniqueInput[]
    connect?: suggestionsWhereUniqueInput | suggestionsWhereUniqueInput[]
    update?: suggestionsUpdateWithWhereUniqueWithoutUserInput | suggestionsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: suggestionsUpdateManyWithWhereWithoutUserInput | suggestionsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: suggestionsScalarWhereInput | suggestionsScalarWhereInput[]
  }

  export type access_logsUpdateManyWithoutUserNestedInput = {
    create?: XOR<access_logsCreateWithoutUserInput, access_logsUncheckedCreateWithoutUserInput> | access_logsCreateWithoutUserInput[] | access_logsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: access_logsCreateOrConnectWithoutUserInput | access_logsCreateOrConnectWithoutUserInput[]
    upsert?: access_logsUpsertWithWhereUniqueWithoutUserInput | access_logsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: access_logsCreateManyUserInputEnvelope
    set?: access_logsWhereUniqueInput | access_logsWhereUniqueInput[]
    disconnect?: access_logsWhereUniqueInput | access_logsWhereUniqueInput[]
    delete?: access_logsWhereUniqueInput | access_logsWhereUniqueInput[]
    connect?: access_logsWhereUniqueInput | access_logsWhereUniqueInput[]
    update?: access_logsUpdateWithWhereUniqueWithoutUserInput | access_logsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: access_logsUpdateManyWithWhereWithoutUserInput | access_logsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: access_logsScalarWhereInput | access_logsScalarWhereInput[]
  }

  export type ai_chat_sessionsUpdateManyWithoutUserNestedInput = {
    create?: XOR<ai_chat_sessionsCreateWithoutUserInput, ai_chat_sessionsUncheckedCreateWithoutUserInput> | ai_chat_sessionsCreateWithoutUserInput[] | ai_chat_sessionsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ai_chat_sessionsCreateOrConnectWithoutUserInput | ai_chat_sessionsCreateOrConnectWithoutUserInput[]
    upsert?: ai_chat_sessionsUpsertWithWhereUniqueWithoutUserInput | ai_chat_sessionsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ai_chat_sessionsCreateManyUserInputEnvelope
    set?: ai_chat_sessionsWhereUniqueInput | ai_chat_sessionsWhereUniqueInput[]
    disconnect?: ai_chat_sessionsWhereUniqueInput | ai_chat_sessionsWhereUniqueInput[]
    delete?: ai_chat_sessionsWhereUniqueInput | ai_chat_sessionsWhereUniqueInput[]
    connect?: ai_chat_sessionsWhereUniqueInput | ai_chat_sessionsWhereUniqueInput[]
    update?: ai_chat_sessionsUpdateWithWhereUniqueWithoutUserInput | ai_chat_sessionsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ai_chat_sessionsUpdateManyWithWhereWithoutUserInput | ai_chat_sessionsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ai_chat_sessionsScalarWhereInput | ai_chat_sessionsScalarWhereInput[]
  }

  export type ai_interactionsUpdateManyWithoutUserNestedInput = {
    create?: XOR<ai_interactionsCreateWithoutUserInput, ai_interactionsUncheckedCreateWithoutUserInput> | ai_interactionsCreateWithoutUserInput[] | ai_interactionsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ai_interactionsCreateOrConnectWithoutUserInput | ai_interactionsCreateOrConnectWithoutUserInput[]
    upsert?: ai_interactionsUpsertWithWhereUniqueWithoutUserInput | ai_interactionsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ai_interactionsCreateManyUserInputEnvelope
    set?: ai_interactionsWhereUniqueInput | ai_interactionsWhereUniqueInput[]
    disconnect?: ai_interactionsWhereUniqueInput | ai_interactionsWhereUniqueInput[]
    delete?: ai_interactionsWhereUniqueInput | ai_interactionsWhereUniqueInput[]
    connect?: ai_interactionsWhereUniqueInput | ai_interactionsWhereUniqueInput[]
    update?: ai_interactionsUpdateWithWhereUniqueWithoutUserInput | ai_interactionsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ai_interactionsUpdateManyWithWhereWithoutUserInput | ai_interactionsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ai_interactionsScalarWhereInput | ai_interactionsScalarWhereInput[]
  }

  export type ai_insightsUpdateManyWithoutUserNestedInput = {
    create?: XOR<ai_insightsCreateWithoutUserInput, ai_insightsUncheckedCreateWithoutUserInput> | ai_insightsCreateWithoutUserInput[] | ai_insightsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ai_insightsCreateOrConnectWithoutUserInput | ai_insightsCreateOrConnectWithoutUserInput[]
    upsert?: ai_insightsUpsertWithWhereUniqueWithoutUserInput | ai_insightsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ai_insightsCreateManyUserInputEnvelope
    set?: ai_insightsWhereUniqueInput | ai_insightsWhereUniqueInput[]
    disconnect?: ai_insightsWhereUniqueInput | ai_insightsWhereUniqueInput[]
    delete?: ai_insightsWhereUniqueInput | ai_insightsWhereUniqueInput[]
    connect?: ai_insightsWhereUniqueInput | ai_insightsWhereUniqueInput[]
    update?: ai_insightsUpdateWithWhereUniqueWithoutUserInput | ai_insightsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ai_insightsUpdateManyWithWhereWithoutUserInput | ai_insightsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ai_insightsScalarWhereInput | ai_insightsScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type queriesUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<queriesCreateWithoutUserInput, queriesUncheckedCreateWithoutUserInput> | queriesCreateWithoutUserInput[] | queriesUncheckedCreateWithoutUserInput[]
    connectOrCreate?: queriesCreateOrConnectWithoutUserInput | queriesCreateOrConnectWithoutUserInput[]
    upsert?: queriesUpsertWithWhereUniqueWithoutUserInput | queriesUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: queriesCreateManyUserInputEnvelope
    set?: queriesWhereUniqueInput | queriesWhereUniqueInput[]
    disconnect?: queriesWhereUniqueInput | queriesWhereUniqueInput[]
    delete?: queriesWhereUniqueInput | queriesWhereUniqueInput[]
    connect?: queriesWhereUniqueInput | queriesWhereUniqueInput[]
    update?: queriesUpdateWithWhereUniqueWithoutUserInput | queriesUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: queriesUpdateManyWithWhereWithoutUserInput | queriesUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: queriesScalarWhereInput | queriesScalarWhereInput[]
  }

  export type historyUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<historyCreateWithoutUserInput, historyUncheckedCreateWithoutUserInput> | historyCreateWithoutUserInput[] | historyUncheckedCreateWithoutUserInput[]
    connectOrCreate?: historyCreateOrConnectWithoutUserInput | historyCreateOrConnectWithoutUserInput[]
    upsert?: historyUpsertWithWhereUniqueWithoutUserInput | historyUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: historyCreateManyUserInputEnvelope
    set?: historyWhereUniqueInput | historyWhereUniqueInput[]
    disconnect?: historyWhereUniqueInput | historyWhereUniqueInput[]
    delete?: historyWhereUniqueInput | historyWhereUniqueInput[]
    connect?: historyWhereUniqueInput | historyWhereUniqueInput[]
    update?: historyUpdateWithWhereUniqueWithoutUserInput | historyUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: historyUpdateManyWithWhereWithoutUserInput | historyUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: historyScalarWhereInput | historyScalarWhereInput[]
  }

  export type exportsUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<exportsCreateWithoutUserInput, exportsUncheckedCreateWithoutUserInput> | exportsCreateWithoutUserInput[] | exportsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: exportsCreateOrConnectWithoutUserInput | exportsCreateOrConnectWithoutUserInput[]
    upsert?: exportsUpsertWithWhereUniqueWithoutUserInput | exportsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: exportsCreateManyUserInputEnvelope
    set?: exportsWhereUniqueInput | exportsWhereUniqueInput[]
    disconnect?: exportsWhereUniqueInput | exportsWhereUniqueInput[]
    delete?: exportsWhereUniqueInput | exportsWhereUniqueInput[]
    connect?: exportsWhereUniqueInput | exportsWhereUniqueInput[]
    update?: exportsUpdateWithWhereUniqueWithoutUserInput | exportsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: exportsUpdateManyWithWhereWithoutUserInput | exportsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: exportsScalarWhereInput | exportsScalarWhereInput[]
  }

  export type suggestionsUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<suggestionsCreateWithoutUserInput, suggestionsUncheckedCreateWithoutUserInput> | suggestionsCreateWithoutUserInput[] | suggestionsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: suggestionsCreateOrConnectWithoutUserInput | suggestionsCreateOrConnectWithoutUserInput[]
    upsert?: suggestionsUpsertWithWhereUniqueWithoutUserInput | suggestionsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: suggestionsCreateManyUserInputEnvelope
    set?: suggestionsWhereUniqueInput | suggestionsWhereUniqueInput[]
    disconnect?: suggestionsWhereUniqueInput | suggestionsWhereUniqueInput[]
    delete?: suggestionsWhereUniqueInput | suggestionsWhereUniqueInput[]
    connect?: suggestionsWhereUniqueInput | suggestionsWhereUniqueInput[]
    update?: suggestionsUpdateWithWhereUniqueWithoutUserInput | suggestionsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: suggestionsUpdateManyWithWhereWithoutUserInput | suggestionsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: suggestionsScalarWhereInput | suggestionsScalarWhereInput[]
  }

  export type access_logsUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<access_logsCreateWithoutUserInput, access_logsUncheckedCreateWithoutUserInput> | access_logsCreateWithoutUserInput[] | access_logsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: access_logsCreateOrConnectWithoutUserInput | access_logsCreateOrConnectWithoutUserInput[]
    upsert?: access_logsUpsertWithWhereUniqueWithoutUserInput | access_logsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: access_logsCreateManyUserInputEnvelope
    set?: access_logsWhereUniqueInput | access_logsWhereUniqueInput[]
    disconnect?: access_logsWhereUniqueInput | access_logsWhereUniqueInput[]
    delete?: access_logsWhereUniqueInput | access_logsWhereUniqueInput[]
    connect?: access_logsWhereUniqueInput | access_logsWhereUniqueInput[]
    update?: access_logsUpdateWithWhereUniqueWithoutUserInput | access_logsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: access_logsUpdateManyWithWhereWithoutUserInput | access_logsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: access_logsScalarWhereInput | access_logsScalarWhereInput[]
  }

  export type ai_chat_sessionsUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ai_chat_sessionsCreateWithoutUserInput, ai_chat_sessionsUncheckedCreateWithoutUserInput> | ai_chat_sessionsCreateWithoutUserInput[] | ai_chat_sessionsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ai_chat_sessionsCreateOrConnectWithoutUserInput | ai_chat_sessionsCreateOrConnectWithoutUserInput[]
    upsert?: ai_chat_sessionsUpsertWithWhereUniqueWithoutUserInput | ai_chat_sessionsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ai_chat_sessionsCreateManyUserInputEnvelope
    set?: ai_chat_sessionsWhereUniqueInput | ai_chat_sessionsWhereUniqueInput[]
    disconnect?: ai_chat_sessionsWhereUniqueInput | ai_chat_sessionsWhereUniqueInput[]
    delete?: ai_chat_sessionsWhereUniqueInput | ai_chat_sessionsWhereUniqueInput[]
    connect?: ai_chat_sessionsWhereUniqueInput | ai_chat_sessionsWhereUniqueInput[]
    update?: ai_chat_sessionsUpdateWithWhereUniqueWithoutUserInput | ai_chat_sessionsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ai_chat_sessionsUpdateManyWithWhereWithoutUserInput | ai_chat_sessionsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ai_chat_sessionsScalarWhereInput | ai_chat_sessionsScalarWhereInput[]
  }

  export type ai_interactionsUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ai_interactionsCreateWithoutUserInput, ai_interactionsUncheckedCreateWithoutUserInput> | ai_interactionsCreateWithoutUserInput[] | ai_interactionsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ai_interactionsCreateOrConnectWithoutUserInput | ai_interactionsCreateOrConnectWithoutUserInput[]
    upsert?: ai_interactionsUpsertWithWhereUniqueWithoutUserInput | ai_interactionsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ai_interactionsCreateManyUserInputEnvelope
    set?: ai_interactionsWhereUniqueInput | ai_interactionsWhereUniqueInput[]
    disconnect?: ai_interactionsWhereUniqueInput | ai_interactionsWhereUniqueInput[]
    delete?: ai_interactionsWhereUniqueInput | ai_interactionsWhereUniqueInput[]
    connect?: ai_interactionsWhereUniqueInput | ai_interactionsWhereUniqueInput[]
    update?: ai_interactionsUpdateWithWhereUniqueWithoutUserInput | ai_interactionsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ai_interactionsUpdateManyWithWhereWithoutUserInput | ai_interactionsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ai_interactionsScalarWhereInput | ai_interactionsScalarWhereInput[]
  }

  export type ai_insightsUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ai_insightsCreateWithoutUserInput, ai_insightsUncheckedCreateWithoutUserInput> | ai_insightsCreateWithoutUserInput[] | ai_insightsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ai_insightsCreateOrConnectWithoutUserInput | ai_insightsCreateOrConnectWithoutUserInput[]
    upsert?: ai_insightsUpsertWithWhereUniqueWithoutUserInput | ai_insightsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ai_insightsCreateManyUserInputEnvelope
    set?: ai_insightsWhereUniqueInput | ai_insightsWhereUniqueInput[]
    disconnect?: ai_insightsWhereUniqueInput | ai_insightsWhereUniqueInput[]
    delete?: ai_insightsWhereUniqueInput | ai_insightsWhereUniqueInput[]
    connect?: ai_insightsWhereUniqueInput | ai_insightsWhereUniqueInput[]
    update?: ai_insightsUpdateWithWhereUniqueWithoutUserInput | ai_insightsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ai_insightsUpdateManyWithWhereWithoutUserInput | ai_insightsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ai_insightsScalarWhereInput | ai_insightsScalarWhereInput[]
  }

  export type usersCreateNestedOneWithoutQueriesInput = {
    create?: XOR<usersCreateWithoutQueriesInput, usersUncheckedCreateWithoutQueriesInput>
    connectOrCreate?: usersCreateOrConnectWithoutQueriesInput
    connect?: usersWhereUniqueInput
  }

  export type resultsCreateNestedManyWithoutQueryInput = {
    create?: XOR<resultsCreateWithoutQueryInput, resultsUncheckedCreateWithoutQueryInput> | resultsCreateWithoutQueryInput[] | resultsUncheckedCreateWithoutQueryInput[]
    connectOrCreate?: resultsCreateOrConnectWithoutQueryInput | resultsCreateOrConnectWithoutQueryInput[]
    createMany?: resultsCreateManyQueryInputEnvelope
    connect?: resultsWhereUniqueInput | resultsWhereUniqueInput[]
  }

  export type historyCreateNestedManyWithoutQueryInput = {
    create?: XOR<historyCreateWithoutQueryInput, historyUncheckedCreateWithoutQueryInput> | historyCreateWithoutQueryInput[] | historyUncheckedCreateWithoutQueryInput[]
    connectOrCreate?: historyCreateOrConnectWithoutQueryInput | historyCreateOrConnectWithoutQueryInput[]
    createMany?: historyCreateManyQueryInputEnvelope
    connect?: historyWhereUniqueInput | historyWhereUniqueInput[]
  }

  export type resultsUncheckedCreateNestedManyWithoutQueryInput = {
    create?: XOR<resultsCreateWithoutQueryInput, resultsUncheckedCreateWithoutQueryInput> | resultsCreateWithoutQueryInput[] | resultsUncheckedCreateWithoutQueryInput[]
    connectOrCreate?: resultsCreateOrConnectWithoutQueryInput | resultsCreateOrConnectWithoutQueryInput[]
    createMany?: resultsCreateManyQueryInputEnvelope
    connect?: resultsWhereUniqueInput | resultsWhereUniqueInput[]
  }

  export type historyUncheckedCreateNestedManyWithoutQueryInput = {
    create?: XOR<historyCreateWithoutQueryInput, historyUncheckedCreateWithoutQueryInput> | historyCreateWithoutQueryInput[] | historyUncheckedCreateWithoutQueryInput[]
    connectOrCreate?: historyCreateOrConnectWithoutQueryInput | historyCreateOrConnectWithoutQueryInput[]
    createMany?: historyCreateManyQueryInputEnvelope
    connect?: historyWhereUniqueInput | historyWhereUniqueInput[]
  }

  export type usersUpdateOneRequiredWithoutQueriesNestedInput = {
    create?: XOR<usersCreateWithoutQueriesInput, usersUncheckedCreateWithoutQueriesInput>
    connectOrCreate?: usersCreateOrConnectWithoutQueriesInput
    upsert?: usersUpsertWithoutQueriesInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutQueriesInput, usersUpdateWithoutQueriesInput>, usersUncheckedUpdateWithoutQueriesInput>
  }

  export type resultsUpdateManyWithoutQueryNestedInput = {
    create?: XOR<resultsCreateWithoutQueryInput, resultsUncheckedCreateWithoutQueryInput> | resultsCreateWithoutQueryInput[] | resultsUncheckedCreateWithoutQueryInput[]
    connectOrCreate?: resultsCreateOrConnectWithoutQueryInput | resultsCreateOrConnectWithoutQueryInput[]
    upsert?: resultsUpsertWithWhereUniqueWithoutQueryInput | resultsUpsertWithWhereUniqueWithoutQueryInput[]
    createMany?: resultsCreateManyQueryInputEnvelope
    set?: resultsWhereUniqueInput | resultsWhereUniqueInput[]
    disconnect?: resultsWhereUniqueInput | resultsWhereUniqueInput[]
    delete?: resultsWhereUniqueInput | resultsWhereUniqueInput[]
    connect?: resultsWhereUniqueInput | resultsWhereUniqueInput[]
    update?: resultsUpdateWithWhereUniqueWithoutQueryInput | resultsUpdateWithWhereUniqueWithoutQueryInput[]
    updateMany?: resultsUpdateManyWithWhereWithoutQueryInput | resultsUpdateManyWithWhereWithoutQueryInput[]
    deleteMany?: resultsScalarWhereInput | resultsScalarWhereInput[]
  }

  export type historyUpdateManyWithoutQueryNestedInput = {
    create?: XOR<historyCreateWithoutQueryInput, historyUncheckedCreateWithoutQueryInput> | historyCreateWithoutQueryInput[] | historyUncheckedCreateWithoutQueryInput[]
    connectOrCreate?: historyCreateOrConnectWithoutQueryInput | historyCreateOrConnectWithoutQueryInput[]
    upsert?: historyUpsertWithWhereUniqueWithoutQueryInput | historyUpsertWithWhereUniqueWithoutQueryInput[]
    createMany?: historyCreateManyQueryInputEnvelope
    set?: historyWhereUniqueInput | historyWhereUniqueInput[]
    disconnect?: historyWhereUniqueInput | historyWhereUniqueInput[]
    delete?: historyWhereUniqueInput | historyWhereUniqueInput[]
    connect?: historyWhereUniqueInput | historyWhereUniqueInput[]
    update?: historyUpdateWithWhereUniqueWithoutQueryInput | historyUpdateWithWhereUniqueWithoutQueryInput[]
    updateMany?: historyUpdateManyWithWhereWithoutQueryInput | historyUpdateManyWithWhereWithoutQueryInput[]
    deleteMany?: historyScalarWhereInput | historyScalarWhereInput[]
  }

  export type resultsUncheckedUpdateManyWithoutQueryNestedInput = {
    create?: XOR<resultsCreateWithoutQueryInput, resultsUncheckedCreateWithoutQueryInput> | resultsCreateWithoutQueryInput[] | resultsUncheckedCreateWithoutQueryInput[]
    connectOrCreate?: resultsCreateOrConnectWithoutQueryInput | resultsCreateOrConnectWithoutQueryInput[]
    upsert?: resultsUpsertWithWhereUniqueWithoutQueryInput | resultsUpsertWithWhereUniqueWithoutQueryInput[]
    createMany?: resultsCreateManyQueryInputEnvelope
    set?: resultsWhereUniqueInput | resultsWhereUniqueInput[]
    disconnect?: resultsWhereUniqueInput | resultsWhereUniqueInput[]
    delete?: resultsWhereUniqueInput | resultsWhereUniqueInput[]
    connect?: resultsWhereUniqueInput | resultsWhereUniqueInput[]
    update?: resultsUpdateWithWhereUniqueWithoutQueryInput | resultsUpdateWithWhereUniqueWithoutQueryInput[]
    updateMany?: resultsUpdateManyWithWhereWithoutQueryInput | resultsUpdateManyWithWhereWithoutQueryInput[]
    deleteMany?: resultsScalarWhereInput | resultsScalarWhereInput[]
  }

  export type historyUncheckedUpdateManyWithoutQueryNestedInput = {
    create?: XOR<historyCreateWithoutQueryInput, historyUncheckedCreateWithoutQueryInput> | historyCreateWithoutQueryInput[] | historyUncheckedCreateWithoutQueryInput[]
    connectOrCreate?: historyCreateOrConnectWithoutQueryInput | historyCreateOrConnectWithoutQueryInput[]
    upsert?: historyUpsertWithWhereUniqueWithoutQueryInput | historyUpsertWithWhereUniqueWithoutQueryInput[]
    createMany?: historyCreateManyQueryInputEnvelope
    set?: historyWhereUniqueInput | historyWhereUniqueInput[]
    disconnect?: historyWhereUniqueInput | historyWhereUniqueInput[]
    delete?: historyWhereUniqueInput | historyWhereUniqueInput[]
    connect?: historyWhereUniqueInput | historyWhereUniqueInput[]
    update?: historyUpdateWithWhereUniqueWithoutQueryInput | historyUpdateWithWhereUniqueWithoutQueryInput[]
    updateMany?: historyUpdateManyWithWhereWithoutQueryInput | historyUpdateManyWithWhereWithoutQueryInput[]
    deleteMany?: historyScalarWhereInput | historyScalarWhereInput[]
  }

  export type queriesCreateNestedOneWithoutResultsInput = {
    create?: XOR<queriesCreateWithoutResultsInput, queriesUncheckedCreateWithoutResultsInput>
    connectOrCreate?: queriesCreateOrConnectWithoutResultsInput
    connect?: queriesWhereUniqueInput
  }

  export type queriesUpdateOneRequiredWithoutResultsNestedInput = {
    create?: XOR<queriesCreateWithoutResultsInput, queriesUncheckedCreateWithoutResultsInput>
    connectOrCreate?: queriesCreateOrConnectWithoutResultsInput
    upsert?: queriesUpsertWithoutResultsInput
    connect?: queriesWhereUniqueInput
    update?: XOR<XOR<queriesUpdateToOneWithWhereWithoutResultsInput, queriesUpdateWithoutResultsInput>, queriesUncheckedUpdateWithoutResultsInput>
  }

  export type usersCreateNestedOneWithoutHistoryInput = {
    create?: XOR<usersCreateWithoutHistoryInput, usersUncheckedCreateWithoutHistoryInput>
    connectOrCreate?: usersCreateOrConnectWithoutHistoryInput
    connect?: usersWhereUniqueInput
  }

  export type queriesCreateNestedOneWithoutHistoryInput = {
    create?: XOR<queriesCreateWithoutHistoryInput, queriesUncheckedCreateWithoutHistoryInput>
    connectOrCreate?: queriesCreateOrConnectWithoutHistoryInput
    connect?: queriesWhereUniqueInput
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type usersUpdateOneRequiredWithoutHistoryNestedInput = {
    create?: XOR<usersCreateWithoutHistoryInput, usersUncheckedCreateWithoutHistoryInput>
    connectOrCreate?: usersCreateOrConnectWithoutHistoryInput
    upsert?: usersUpsertWithoutHistoryInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutHistoryInput, usersUpdateWithoutHistoryInput>, usersUncheckedUpdateWithoutHistoryInput>
  }

  export type queriesUpdateOneWithoutHistoryNestedInput = {
    create?: XOR<queriesCreateWithoutHistoryInput, queriesUncheckedCreateWithoutHistoryInput>
    connectOrCreate?: queriesCreateOrConnectWithoutHistoryInput
    upsert?: queriesUpsertWithoutHistoryInput
    disconnect?: queriesWhereInput | boolean
    delete?: queriesWhereInput | boolean
    connect?: queriesWhereUniqueInput
    update?: XOR<XOR<queriesUpdateToOneWithWhereWithoutHistoryInput, queriesUpdateWithoutHistoryInput>, queriesUncheckedUpdateWithoutHistoryInput>
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type usersCreateNestedOneWithoutExportsInput = {
    create?: XOR<usersCreateWithoutExportsInput, usersUncheckedCreateWithoutExportsInput>
    connectOrCreate?: usersCreateOrConnectWithoutExportsInput
    connect?: usersWhereUniqueInput
  }

  export type usersUpdateOneRequiredWithoutExportsNestedInput = {
    create?: XOR<usersCreateWithoutExportsInput, usersUncheckedCreateWithoutExportsInput>
    connectOrCreate?: usersCreateOrConnectWithoutExportsInput
    upsert?: usersUpsertWithoutExportsInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutExportsInput, usersUpdateWithoutExportsInput>, usersUncheckedUpdateWithoutExportsInput>
  }

  export type usersCreateNestedOneWithoutSuggestionsInput = {
    create?: XOR<usersCreateWithoutSuggestionsInput, usersUncheckedCreateWithoutSuggestionsInput>
    connectOrCreate?: usersCreateOrConnectWithoutSuggestionsInput
    connect?: usersWhereUniqueInput
  }

  export type usersUpdateOneRequiredWithoutSuggestionsNestedInput = {
    create?: XOR<usersCreateWithoutSuggestionsInput, usersUncheckedCreateWithoutSuggestionsInput>
    connectOrCreate?: usersCreateOrConnectWithoutSuggestionsInput
    upsert?: usersUpsertWithoutSuggestionsInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutSuggestionsInput, usersUpdateWithoutSuggestionsInput>, usersUncheckedUpdateWithoutSuggestionsInput>
  }

  export type usersCreateNestedOneWithoutAccess_logsInput = {
    create?: XOR<usersCreateWithoutAccess_logsInput, usersUncheckedCreateWithoutAccess_logsInput>
    connectOrCreate?: usersCreateOrConnectWithoutAccess_logsInput
    connect?: usersWhereUniqueInput
  }

  export type usersUpdateOneWithoutAccess_logsNestedInput = {
    create?: XOR<usersCreateWithoutAccess_logsInput, usersUncheckedCreateWithoutAccess_logsInput>
    connectOrCreate?: usersCreateOrConnectWithoutAccess_logsInput
    upsert?: usersUpsertWithoutAccess_logsInput
    disconnect?: usersWhereInput | boolean
    delete?: usersWhereInput | boolean
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutAccess_logsInput, usersUpdateWithoutAccess_logsInput>, usersUncheckedUpdateWithoutAccess_logsInput>
  }

  export type usersCreateNestedOneWithoutAi_chat_sessionsInput = {
    create?: XOR<usersCreateWithoutAi_chat_sessionsInput, usersUncheckedCreateWithoutAi_chat_sessionsInput>
    connectOrCreate?: usersCreateOrConnectWithoutAi_chat_sessionsInput
    connect?: usersWhereUniqueInput
  }

  export type ai_interactionsCreateNestedManyWithoutSessionInput = {
    create?: XOR<ai_interactionsCreateWithoutSessionInput, ai_interactionsUncheckedCreateWithoutSessionInput> | ai_interactionsCreateWithoutSessionInput[] | ai_interactionsUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: ai_interactionsCreateOrConnectWithoutSessionInput | ai_interactionsCreateOrConnectWithoutSessionInput[]
    createMany?: ai_interactionsCreateManySessionInputEnvelope
    connect?: ai_interactionsWhereUniqueInput | ai_interactionsWhereUniqueInput[]
  }

  export type ai_interactionsUncheckedCreateNestedManyWithoutSessionInput = {
    create?: XOR<ai_interactionsCreateWithoutSessionInput, ai_interactionsUncheckedCreateWithoutSessionInput> | ai_interactionsCreateWithoutSessionInput[] | ai_interactionsUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: ai_interactionsCreateOrConnectWithoutSessionInput | ai_interactionsCreateOrConnectWithoutSessionInput[]
    createMany?: ai_interactionsCreateManySessionInputEnvelope
    connect?: ai_interactionsWhereUniqueInput | ai_interactionsWhereUniqueInput[]
  }

  export type usersUpdateOneRequiredWithoutAi_chat_sessionsNestedInput = {
    create?: XOR<usersCreateWithoutAi_chat_sessionsInput, usersUncheckedCreateWithoutAi_chat_sessionsInput>
    connectOrCreate?: usersCreateOrConnectWithoutAi_chat_sessionsInput
    upsert?: usersUpsertWithoutAi_chat_sessionsInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutAi_chat_sessionsInput, usersUpdateWithoutAi_chat_sessionsInput>, usersUncheckedUpdateWithoutAi_chat_sessionsInput>
  }

  export type ai_interactionsUpdateManyWithoutSessionNestedInput = {
    create?: XOR<ai_interactionsCreateWithoutSessionInput, ai_interactionsUncheckedCreateWithoutSessionInput> | ai_interactionsCreateWithoutSessionInput[] | ai_interactionsUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: ai_interactionsCreateOrConnectWithoutSessionInput | ai_interactionsCreateOrConnectWithoutSessionInput[]
    upsert?: ai_interactionsUpsertWithWhereUniqueWithoutSessionInput | ai_interactionsUpsertWithWhereUniqueWithoutSessionInput[]
    createMany?: ai_interactionsCreateManySessionInputEnvelope
    set?: ai_interactionsWhereUniqueInput | ai_interactionsWhereUniqueInput[]
    disconnect?: ai_interactionsWhereUniqueInput | ai_interactionsWhereUniqueInput[]
    delete?: ai_interactionsWhereUniqueInput | ai_interactionsWhereUniqueInput[]
    connect?: ai_interactionsWhereUniqueInput | ai_interactionsWhereUniqueInput[]
    update?: ai_interactionsUpdateWithWhereUniqueWithoutSessionInput | ai_interactionsUpdateWithWhereUniqueWithoutSessionInput[]
    updateMany?: ai_interactionsUpdateManyWithWhereWithoutSessionInput | ai_interactionsUpdateManyWithWhereWithoutSessionInput[]
    deleteMany?: ai_interactionsScalarWhereInput | ai_interactionsScalarWhereInput[]
  }

  export type ai_interactionsUncheckedUpdateManyWithoutSessionNestedInput = {
    create?: XOR<ai_interactionsCreateWithoutSessionInput, ai_interactionsUncheckedCreateWithoutSessionInput> | ai_interactionsCreateWithoutSessionInput[] | ai_interactionsUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: ai_interactionsCreateOrConnectWithoutSessionInput | ai_interactionsCreateOrConnectWithoutSessionInput[]
    upsert?: ai_interactionsUpsertWithWhereUniqueWithoutSessionInput | ai_interactionsUpsertWithWhereUniqueWithoutSessionInput[]
    createMany?: ai_interactionsCreateManySessionInputEnvelope
    set?: ai_interactionsWhereUniqueInput | ai_interactionsWhereUniqueInput[]
    disconnect?: ai_interactionsWhereUniqueInput | ai_interactionsWhereUniqueInput[]
    delete?: ai_interactionsWhereUniqueInput | ai_interactionsWhereUniqueInput[]
    connect?: ai_interactionsWhereUniqueInput | ai_interactionsWhereUniqueInput[]
    update?: ai_interactionsUpdateWithWhereUniqueWithoutSessionInput | ai_interactionsUpdateWithWhereUniqueWithoutSessionInput[]
    updateMany?: ai_interactionsUpdateManyWithWhereWithoutSessionInput | ai_interactionsUpdateManyWithWhereWithoutSessionInput[]
    deleteMany?: ai_interactionsScalarWhereInput | ai_interactionsScalarWhereInput[]
  }

  export type ai_chat_sessionsCreateNestedOneWithoutInteractionsInput = {
    create?: XOR<ai_chat_sessionsCreateWithoutInteractionsInput, ai_chat_sessionsUncheckedCreateWithoutInteractionsInput>
    connectOrCreate?: ai_chat_sessionsCreateOrConnectWithoutInteractionsInput
    connect?: ai_chat_sessionsWhereUniqueInput
  }

  export type usersCreateNestedOneWithoutAi_interactionsInput = {
    create?: XOR<usersCreateWithoutAi_interactionsInput, usersUncheckedCreateWithoutAi_interactionsInput>
    connectOrCreate?: usersCreateOrConnectWithoutAi_interactionsInput
    connect?: usersWhereUniqueInput
  }

  export type ai_insightsCreateNestedManyWithoutInteractionInput = {
    create?: XOR<ai_insightsCreateWithoutInteractionInput, ai_insightsUncheckedCreateWithoutInteractionInput> | ai_insightsCreateWithoutInteractionInput[] | ai_insightsUncheckedCreateWithoutInteractionInput[]
    connectOrCreate?: ai_insightsCreateOrConnectWithoutInteractionInput | ai_insightsCreateOrConnectWithoutInteractionInput[]
    createMany?: ai_insightsCreateManyInteractionInputEnvelope
    connect?: ai_insightsWhereUniqueInput | ai_insightsWhereUniqueInput[]
  }

  export type ai_insightsUncheckedCreateNestedManyWithoutInteractionInput = {
    create?: XOR<ai_insightsCreateWithoutInteractionInput, ai_insightsUncheckedCreateWithoutInteractionInput> | ai_insightsCreateWithoutInteractionInput[] | ai_insightsUncheckedCreateWithoutInteractionInput[]
    connectOrCreate?: ai_insightsCreateOrConnectWithoutInteractionInput | ai_insightsCreateOrConnectWithoutInteractionInput[]
    createMany?: ai_insightsCreateManyInteractionInputEnvelope
    connect?: ai_insightsWhereUniqueInput | ai_insightsWhereUniqueInput[]
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type ai_chat_sessionsUpdateOneRequiredWithoutInteractionsNestedInput = {
    create?: XOR<ai_chat_sessionsCreateWithoutInteractionsInput, ai_chat_sessionsUncheckedCreateWithoutInteractionsInput>
    connectOrCreate?: ai_chat_sessionsCreateOrConnectWithoutInteractionsInput
    upsert?: ai_chat_sessionsUpsertWithoutInteractionsInput
    connect?: ai_chat_sessionsWhereUniqueInput
    update?: XOR<XOR<ai_chat_sessionsUpdateToOneWithWhereWithoutInteractionsInput, ai_chat_sessionsUpdateWithoutInteractionsInput>, ai_chat_sessionsUncheckedUpdateWithoutInteractionsInput>
  }

  export type usersUpdateOneRequiredWithoutAi_interactionsNestedInput = {
    create?: XOR<usersCreateWithoutAi_interactionsInput, usersUncheckedCreateWithoutAi_interactionsInput>
    connectOrCreate?: usersCreateOrConnectWithoutAi_interactionsInput
    upsert?: usersUpsertWithoutAi_interactionsInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutAi_interactionsInput, usersUpdateWithoutAi_interactionsInput>, usersUncheckedUpdateWithoutAi_interactionsInput>
  }

  export type ai_insightsUpdateManyWithoutInteractionNestedInput = {
    create?: XOR<ai_insightsCreateWithoutInteractionInput, ai_insightsUncheckedCreateWithoutInteractionInput> | ai_insightsCreateWithoutInteractionInput[] | ai_insightsUncheckedCreateWithoutInteractionInput[]
    connectOrCreate?: ai_insightsCreateOrConnectWithoutInteractionInput | ai_insightsCreateOrConnectWithoutInteractionInput[]
    upsert?: ai_insightsUpsertWithWhereUniqueWithoutInteractionInput | ai_insightsUpsertWithWhereUniqueWithoutInteractionInput[]
    createMany?: ai_insightsCreateManyInteractionInputEnvelope
    set?: ai_insightsWhereUniqueInput | ai_insightsWhereUniqueInput[]
    disconnect?: ai_insightsWhereUniqueInput | ai_insightsWhereUniqueInput[]
    delete?: ai_insightsWhereUniqueInput | ai_insightsWhereUniqueInput[]
    connect?: ai_insightsWhereUniqueInput | ai_insightsWhereUniqueInput[]
    update?: ai_insightsUpdateWithWhereUniqueWithoutInteractionInput | ai_insightsUpdateWithWhereUniqueWithoutInteractionInput[]
    updateMany?: ai_insightsUpdateManyWithWhereWithoutInteractionInput | ai_insightsUpdateManyWithWhereWithoutInteractionInput[]
    deleteMany?: ai_insightsScalarWhereInput | ai_insightsScalarWhereInput[]
  }

  export type ai_insightsUncheckedUpdateManyWithoutInteractionNestedInput = {
    create?: XOR<ai_insightsCreateWithoutInteractionInput, ai_insightsUncheckedCreateWithoutInteractionInput> | ai_insightsCreateWithoutInteractionInput[] | ai_insightsUncheckedCreateWithoutInteractionInput[]
    connectOrCreate?: ai_insightsCreateOrConnectWithoutInteractionInput | ai_insightsCreateOrConnectWithoutInteractionInput[]
    upsert?: ai_insightsUpsertWithWhereUniqueWithoutInteractionInput | ai_insightsUpsertWithWhereUniqueWithoutInteractionInput[]
    createMany?: ai_insightsCreateManyInteractionInputEnvelope
    set?: ai_insightsWhereUniqueInput | ai_insightsWhereUniqueInput[]
    disconnect?: ai_insightsWhereUniqueInput | ai_insightsWhereUniqueInput[]
    delete?: ai_insightsWhereUniqueInput | ai_insightsWhereUniqueInput[]
    connect?: ai_insightsWhereUniqueInput | ai_insightsWhereUniqueInput[]
    update?: ai_insightsUpdateWithWhereUniqueWithoutInteractionInput | ai_insightsUpdateWithWhereUniqueWithoutInteractionInput[]
    updateMany?: ai_insightsUpdateManyWithWhereWithoutInteractionInput | ai_insightsUpdateManyWithWhereWithoutInteractionInput[]
    deleteMany?: ai_insightsScalarWhereInput | ai_insightsScalarWhereInput[]
  }

  export type ai_interactionsCreateNestedOneWithoutInsightsInput = {
    create?: XOR<ai_interactionsCreateWithoutInsightsInput, ai_interactionsUncheckedCreateWithoutInsightsInput>
    connectOrCreate?: ai_interactionsCreateOrConnectWithoutInsightsInput
    connect?: ai_interactionsWhereUniqueInput
  }

  export type usersCreateNestedOneWithoutAi_insightsInput = {
    create?: XOR<usersCreateWithoutAi_insightsInput, usersUncheckedCreateWithoutAi_insightsInput>
    connectOrCreate?: usersCreateOrConnectWithoutAi_insightsInput
    connect?: usersWhereUniqueInput
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type ai_interactionsUpdateOneWithoutInsightsNestedInput = {
    create?: XOR<ai_interactionsCreateWithoutInsightsInput, ai_interactionsUncheckedCreateWithoutInsightsInput>
    connectOrCreate?: ai_interactionsCreateOrConnectWithoutInsightsInput
    upsert?: ai_interactionsUpsertWithoutInsightsInput
    disconnect?: ai_interactionsWhereInput | boolean
    delete?: ai_interactionsWhereInput | boolean
    connect?: ai_interactionsWhereUniqueInput
    update?: XOR<XOR<ai_interactionsUpdateToOneWithWhereWithoutInsightsInput, ai_interactionsUpdateWithoutInsightsInput>, ai_interactionsUncheckedUpdateWithoutInsightsInput>
  }

  export type usersUpdateOneRequiredWithoutAi_insightsNestedInput = {
    create?: XOR<usersCreateWithoutAi_insightsInput, usersUncheckedCreateWithoutAi_insightsInput>
    connectOrCreate?: usersCreateOrConnectWithoutAi_insightsInput
    upsert?: usersUpsertWithoutAi_insightsInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutAi_insightsInput, usersUpdateWithoutAi_insightsInput>, usersUncheckedUpdateWithoutAi_insightsInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }
  export type NestedJsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type queriesCreateWithoutUserInput = {
    question_text?: string | null
    created_at?: Date | string
    results?: resultsCreateNestedManyWithoutQueryInput
    history?: historyCreateNestedManyWithoutQueryInput
  }

  export type queriesUncheckedCreateWithoutUserInput = {
    id?: number
    question_text?: string | null
    created_at?: Date | string
    results?: resultsUncheckedCreateNestedManyWithoutQueryInput
    history?: historyUncheckedCreateNestedManyWithoutQueryInput
  }

  export type queriesCreateOrConnectWithoutUserInput = {
    where: queriesWhereUniqueInput
    create: XOR<queriesCreateWithoutUserInput, queriesUncheckedCreateWithoutUserInput>
  }

  export type queriesCreateManyUserInputEnvelope = {
    data: queriesCreateManyUserInput | queriesCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type historyCreateWithoutUserInput = {
    success?: boolean | null
    execution_time?: number | null
    created_at?: Date | string
    query?: queriesCreateNestedOneWithoutHistoryInput
  }

  export type historyUncheckedCreateWithoutUserInput = {
    id?: number
    query_id?: number | null
    success?: boolean | null
    execution_time?: number | null
    created_at?: Date | string
  }

  export type historyCreateOrConnectWithoutUserInput = {
    where: historyWhereUniqueInput
    create: XOR<historyCreateWithoutUserInput, historyUncheckedCreateWithoutUserInput>
  }

  export type historyCreateManyUserInputEnvelope = {
    data: historyCreateManyUserInput | historyCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type exportsCreateWithoutUserInput = {
    file_type?: string | null
    file_path?: string | null
    created_at?: Date | string
  }

  export type exportsUncheckedCreateWithoutUserInput = {
    id?: number
    file_type?: string | null
    file_path?: string | null
    created_at?: Date | string
  }

  export type exportsCreateOrConnectWithoutUserInput = {
    where: exportsWhereUniqueInput
    create: XOR<exportsCreateWithoutUserInput, exportsUncheckedCreateWithoutUserInput>
  }

  export type exportsCreateManyUserInputEnvelope = {
    data: exportsCreateManyUserInput | exportsCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type suggestionsCreateWithoutUserInput = {
    content?: string | null
    source?: string | null
    created_at?: Date | string
  }

  export type suggestionsUncheckedCreateWithoutUserInput = {
    id?: number
    content?: string | null
    source?: string | null
    created_at?: Date | string
  }

  export type suggestionsCreateOrConnectWithoutUserInput = {
    where: suggestionsWhereUniqueInput
    create: XOR<suggestionsCreateWithoutUserInput, suggestionsUncheckedCreateWithoutUserInput>
  }

  export type suggestionsCreateManyUserInputEnvelope = {
    data: suggestionsCreateManyUserInput | suggestionsCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type access_logsCreateWithoutUserInput = {
    action?: string | null
    ip_address?: string | null
    created_at?: Date | string
  }

  export type access_logsUncheckedCreateWithoutUserInput = {
    id?: number
    action?: string | null
    ip_address?: string | null
    created_at?: Date | string
  }

  export type access_logsCreateOrConnectWithoutUserInput = {
    where: access_logsWhereUniqueInput
    create: XOR<access_logsCreateWithoutUserInput, access_logsUncheckedCreateWithoutUserInput>
  }

  export type access_logsCreateManyUserInputEnvelope = {
    data: access_logsCreateManyUserInput | access_logsCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ai_chat_sessionsCreateWithoutUserInput = {
    session_token: string
    status?: string
    context_data?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
    interactions?: ai_interactionsCreateNestedManyWithoutSessionInput
  }

  export type ai_chat_sessionsUncheckedCreateWithoutUserInput = {
    id?: number
    session_token: string
    status?: string
    context_data?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
    interactions?: ai_interactionsUncheckedCreateNestedManyWithoutSessionInput
  }

  export type ai_chat_sessionsCreateOrConnectWithoutUserInput = {
    where: ai_chat_sessionsWhereUniqueInput
    create: XOR<ai_chat_sessionsCreateWithoutUserInput, ai_chat_sessionsUncheckedCreateWithoutUserInput>
  }

  export type ai_chat_sessionsCreateManyUserInputEnvelope = {
    data: ai_chat_sessionsCreateManyUserInput | ai_chat_sessionsCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ai_interactionsCreateWithoutUserInput = {
    interaction_type: string
    input_text: string
    input_language?: string
    processed_query?: string | null
    ai_response?: NullableJsonNullValueInput | InputJsonValue
    execution_status?: string
    execution_time_ms?: number | null
    confidence_score?: number | null
    error_message?: string | null
    fallback_used?: boolean
    version?: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    session: ai_chat_sessionsCreateNestedOneWithoutInteractionsInput
    insights?: ai_insightsCreateNestedManyWithoutInteractionInput
  }

  export type ai_interactionsUncheckedCreateWithoutUserInput = {
    id?: number
    session_id: number
    interaction_type: string
    input_text: string
    input_language?: string
    processed_query?: string | null
    ai_response?: NullableJsonNullValueInput | InputJsonValue
    execution_status?: string
    execution_time_ms?: number | null
    confidence_score?: number | null
    error_message?: string | null
    fallback_used?: boolean
    version?: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    insights?: ai_insightsUncheckedCreateNestedManyWithoutInteractionInput
  }

  export type ai_interactionsCreateOrConnectWithoutUserInput = {
    where: ai_interactionsWhereUniqueInput
    create: XOR<ai_interactionsCreateWithoutUserInput, ai_interactionsUncheckedCreateWithoutUserInput>
  }

  export type ai_interactionsCreateManyUserInputEnvelope = {
    data: ai_interactionsCreateManyUserInput | ai_interactionsCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ai_insightsCreateWithoutUserInput = {
    insight_type: string
    title: string
    description: string
    data_analysis: JsonNullValueInput | InputJsonValue
    confidence_level: string
    impact_score?: number | null
    status?: string
    expires_at?: Date | string | null
    created_at?: Date | string
    interaction?: ai_interactionsCreateNestedOneWithoutInsightsInput
  }

  export type ai_insightsUncheckedCreateWithoutUserInput = {
    id?: number
    interaction_id?: number | null
    insight_type: string
    title: string
    description: string
    data_analysis: JsonNullValueInput | InputJsonValue
    confidence_level: string
    impact_score?: number | null
    status?: string
    expires_at?: Date | string | null
    created_at?: Date | string
  }

  export type ai_insightsCreateOrConnectWithoutUserInput = {
    where: ai_insightsWhereUniqueInput
    create: XOR<ai_insightsCreateWithoutUserInput, ai_insightsUncheckedCreateWithoutUserInput>
  }

  export type ai_insightsCreateManyUserInputEnvelope = {
    data: ai_insightsCreateManyUserInput | ai_insightsCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type queriesUpsertWithWhereUniqueWithoutUserInput = {
    where: queriesWhereUniqueInput
    update: XOR<queriesUpdateWithoutUserInput, queriesUncheckedUpdateWithoutUserInput>
    create: XOR<queriesCreateWithoutUserInput, queriesUncheckedCreateWithoutUserInput>
  }

  export type queriesUpdateWithWhereUniqueWithoutUserInput = {
    where: queriesWhereUniqueInput
    data: XOR<queriesUpdateWithoutUserInput, queriesUncheckedUpdateWithoutUserInput>
  }

  export type queriesUpdateManyWithWhereWithoutUserInput = {
    where: queriesScalarWhereInput
    data: XOR<queriesUpdateManyMutationInput, queriesUncheckedUpdateManyWithoutUserInput>
  }

  export type queriesScalarWhereInput = {
    AND?: queriesScalarWhereInput | queriesScalarWhereInput[]
    OR?: queriesScalarWhereInput[]
    NOT?: queriesScalarWhereInput | queriesScalarWhereInput[]
    id?: IntFilter<"queries"> | number
    user_id?: IntFilter<"queries"> | number
    question_text?: StringNullableFilter<"queries"> | string | null
    created_at?: DateTimeFilter<"queries"> | Date | string
  }

  export type historyUpsertWithWhereUniqueWithoutUserInput = {
    where: historyWhereUniqueInput
    update: XOR<historyUpdateWithoutUserInput, historyUncheckedUpdateWithoutUserInput>
    create: XOR<historyCreateWithoutUserInput, historyUncheckedCreateWithoutUserInput>
  }

  export type historyUpdateWithWhereUniqueWithoutUserInput = {
    where: historyWhereUniqueInput
    data: XOR<historyUpdateWithoutUserInput, historyUncheckedUpdateWithoutUserInput>
  }

  export type historyUpdateManyWithWhereWithoutUserInput = {
    where: historyScalarWhereInput
    data: XOR<historyUpdateManyMutationInput, historyUncheckedUpdateManyWithoutUserInput>
  }

  export type historyScalarWhereInput = {
    AND?: historyScalarWhereInput | historyScalarWhereInput[]
    OR?: historyScalarWhereInput[]
    NOT?: historyScalarWhereInput | historyScalarWhereInput[]
    id?: IntFilter<"history"> | number
    user_id?: IntFilter<"history"> | number
    query_id?: IntNullableFilter<"history"> | number | null
    success?: BoolNullableFilter<"history"> | boolean | null
    execution_time?: FloatNullableFilter<"history"> | number | null
    created_at?: DateTimeFilter<"history"> | Date | string
  }

  export type exportsUpsertWithWhereUniqueWithoutUserInput = {
    where: exportsWhereUniqueInput
    update: XOR<exportsUpdateWithoutUserInput, exportsUncheckedUpdateWithoutUserInput>
    create: XOR<exportsCreateWithoutUserInput, exportsUncheckedCreateWithoutUserInput>
  }

  export type exportsUpdateWithWhereUniqueWithoutUserInput = {
    where: exportsWhereUniqueInput
    data: XOR<exportsUpdateWithoutUserInput, exportsUncheckedUpdateWithoutUserInput>
  }

  export type exportsUpdateManyWithWhereWithoutUserInput = {
    where: exportsScalarWhereInput
    data: XOR<exportsUpdateManyMutationInput, exportsUncheckedUpdateManyWithoutUserInput>
  }

  export type exportsScalarWhereInput = {
    AND?: exportsScalarWhereInput | exportsScalarWhereInput[]
    OR?: exportsScalarWhereInput[]
    NOT?: exportsScalarWhereInput | exportsScalarWhereInput[]
    id?: IntFilter<"exports"> | number
    user_id?: IntFilter<"exports"> | number
    file_type?: StringNullableFilter<"exports"> | string | null
    file_path?: StringNullableFilter<"exports"> | string | null
    created_at?: DateTimeFilter<"exports"> | Date | string
  }

  export type suggestionsUpsertWithWhereUniqueWithoutUserInput = {
    where: suggestionsWhereUniqueInput
    update: XOR<suggestionsUpdateWithoutUserInput, suggestionsUncheckedUpdateWithoutUserInput>
    create: XOR<suggestionsCreateWithoutUserInput, suggestionsUncheckedCreateWithoutUserInput>
  }

  export type suggestionsUpdateWithWhereUniqueWithoutUserInput = {
    where: suggestionsWhereUniqueInput
    data: XOR<suggestionsUpdateWithoutUserInput, suggestionsUncheckedUpdateWithoutUserInput>
  }

  export type suggestionsUpdateManyWithWhereWithoutUserInput = {
    where: suggestionsScalarWhereInput
    data: XOR<suggestionsUpdateManyMutationInput, suggestionsUncheckedUpdateManyWithoutUserInput>
  }

  export type suggestionsScalarWhereInput = {
    AND?: suggestionsScalarWhereInput | suggestionsScalarWhereInput[]
    OR?: suggestionsScalarWhereInput[]
    NOT?: suggestionsScalarWhereInput | suggestionsScalarWhereInput[]
    id?: IntFilter<"suggestions"> | number
    user_id?: IntFilter<"suggestions"> | number
    content?: StringNullableFilter<"suggestions"> | string | null
    source?: StringNullableFilter<"suggestions"> | string | null
    created_at?: DateTimeFilter<"suggestions"> | Date | string
  }

  export type access_logsUpsertWithWhereUniqueWithoutUserInput = {
    where: access_logsWhereUniqueInput
    update: XOR<access_logsUpdateWithoutUserInput, access_logsUncheckedUpdateWithoutUserInput>
    create: XOR<access_logsCreateWithoutUserInput, access_logsUncheckedCreateWithoutUserInput>
  }

  export type access_logsUpdateWithWhereUniqueWithoutUserInput = {
    where: access_logsWhereUniqueInput
    data: XOR<access_logsUpdateWithoutUserInput, access_logsUncheckedUpdateWithoutUserInput>
  }

  export type access_logsUpdateManyWithWhereWithoutUserInput = {
    where: access_logsScalarWhereInput
    data: XOR<access_logsUpdateManyMutationInput, access_logsUncheckedUpdateManyWithoutUserInput>
  }

  export type access_logsScalarWhereInput = {
    AND?: access_logsScalarWhereInput | access_logsScalarWhereInput[]
    OR?: access_logsScalarWhereInput[]
    NOT?: access_logsScalarWhereInput | access_logsScalarWhereInput[]
    id?: IntFilter<"access_logs"> | number
    user_id?: IntNullableFilter<"access_logs"> | number | null
    action?: StringNullableFilter<"access_logs"> | string | null
    ip_address?: StringNullableFilter<"access_logs"> | string | null
    created_at?: DateTimeFilter<"access_logs"> | Date | string
  }

  export type ai_chat_sessionsUpsertWithWhereUniqueWithoutUserInput = {
    where: ai_chat_sessionsWhereUniqueInput
    update: XOR<ai_chat_sessionsUpdateWithoutUserInput, ai_chat_sessionsUncheckedUpdateWithoutUserInput>
    create: XOR<ai_chat_sessionsCreateWithoutUserInput, ai_chat_sessionsUncheckedCreateWithoutUserInput>
  }

  export type ai_chat_sessionsUpdateWithWhereUniqueWithoutUserInput = {
    where: ai_chat_sessionsWhereUniqueInput
    data: XOR<ai_chat_sessionsUpdateWithoutUserInput, ai_chat_sessionsUncheckedUpdateWithoutUserInput>
  }

  export type ai_chat_sessionsUpdateManyWithWhereWithoutUserInput = {
    where: ai_chat_sessionsScalarWhereInput
    data: XOR<ai_chat_sessionsUpdateManyMutationInput, ai_chat_sessionsUncheckedUpdateManyWithoutUserInput>
  }

  export type ai_chat_sessionsScalarWhereInput = {
    AND?: ai_chat_sessionsScalarWhereInput | ai_chat_sessionsScalarWhereInput[]
    OR?: ai_chat_sessionsScalarWhereInput[]
    NOT?: ai_chat_sessionsScalarWhereInput | ai_chat_sessionsScalarWhereInput[]
    id?: IntFilter<"ai_chat_sessions"> | number
    user_id?: IntFilter<"ai_chat_sessions"> | number
    session_token?: StringFilter<"ai_chat_sessions"> | string
    status?: StringFilter<"ai_chat_sessions"> | string
    context_data?: JsonNullableFilter<"ai_chat_sessions">
    created_at?: DateTimeFilter<"ai_chat_sessions"> | Date | string
    updated_at?: DateTimeFilter<"ai_chat_sessions"> | Date | string
  }

  export type ai_interactionsUpsertWithWhereUniqueWithoutUserInput = {
    where: ai_interactionsWhereUniqueInput
    update: XOR<ai_interactionsUpdateWithoutUserInput, ai_interactionsUncheckedUpdateWithoutUserInput>
    create: XOR<ai_interactionsCreateWithoutUserInput, ai_interactionsUncheckedCreateWithoutUserInput>
  }

  export type ai_interactionsUpdateWithWhereUniqueWithoutUserInput = {
    where: ai_interactionsWhereUniqueInput
    data: XOR<ai_interactionsUpdateWithoutUserInput, ai_interactionsUncheckedUpdateWithoutUserInput>
  }

  export type ai_interactionsUpdateManyWithWhereWithoutUserInput = {
    where: ai_interactionsScalarWhereInput
    data: XOR<ai_interactionsUpdateManyMutationInput, ai_interactionsUncheckedUpdateManyWithoutUserInput>
  }

  export type ai_interactionsScalarWhereInput = {
    AND?: ai_interactionsScalarWhereInput | ai_interactionsScalarWhereInput[]
    OR?: ai_interactionsScalarWhereInput[]
    NOT?: ai_interactionsScalarWhereInput | ai_interactionsScalarWhereInput[]
    id?: IntFilter<"ai_interactions"> | number
    session_id?: IntFilter<"ai_interactions"> | number
    user_id?: IntFilter<"ai_interactions"> | number
    interaction_type?: StringFilter<"ai_interactions"> | string
    input_text?: StringFilter<"ai_interactions"> | string
    input_language?: StringFilter<"ai_interactions"> | string
    processed_query?: StringNullableFilter<"ai_interactions"> | string | null
    ai_response?: JsonNullableFilter<"ai_interactions">
    execution_status?: StringFilter<"ai_interactions"> | string
    execution_time_ms?: IntNullableFilter<"ai_interactions"> | number | null
    confidence_score?: FloatNullableFilter<"ai_interactions"> | number | null
    error_message?: StringNullableFilter<"ai_interactions"> | string | null
    fallback_used?: BoolFilter<"ai_interactions"> | boolean
    version?: StringFilter<"ai_interactions"> | string
    metadata?: JsonNullableFilter<"ai_interactions">
    created_at?: DateTimeFilter<"ai_interactions"> | Date | string
  }

  export type ai_insightsUpsertWithWhereUniqueWithoutUserInput = {
    where: ai_insightsWhereUniqueInput
    update: XOR<ai_insightsUpdateWithoutUserInput, ai_insightsUncheckedUpdateWithoutUserInput>
    create: XOR<ai_insightsCreateWithoutUserInput, ai_insightsUncheckedCreateWithoutUserInput>
  }

  export type ai_insightsUpdateWithWhereUniqueWithoutUserInput = {
    where: ai_insightsWhereUniqueInput
    data: XOR<ai_insightsUpdateWithoutUserInput, ai_insightsUncheckedUpdateWithoutUserInput>
  }

  export type ai_insightsUpdateManyWithWhereWithoutUserInput = {
    where: ai_insightsScalarWhereInput
    data: XOR<ai_insightsUpdateManyMutationInput, ai_insightsUncheckedUpdateManyWithoutUserInput>
  }

  export type ai_insightsScalarWhereInput = {
    AND?: ai_insightsScalarWhereInput | ai_insightsScalarWhereInput[]
    OR?: ai_insightsScalarWhereInput[]
    NOT?: ai_insightsScalarWhereInput | ai_insightsScalarWhereInput[]
    id?: IntFilter<"ai_insights"> | number
    interaction_id?: IntNullableFilter<"ai_insights"> | number | null
    user_id?: IntFilter<"ai_insights"> | number
    insight_type?: StringFilter<"ai_insights"> | string
    title?: StringFilter<"ai_insights"> | string
    description?: StringFilter<"ai_insights"> | string
    data_analysis?: JsonFilter<"ai_insights">
    confidence_level?: StringFilter<"ai_insights"> | string
    impact_score?: FloatNullableFilter<"ai_insights"> | number | null
    status?: StringFilter<"ai_insights"> | string
    expires_at?: DateTimeNullableFilter<"ai_insights"> | Date | string | null
    created_at?: DateTimeFilter<"ai_insights"> | Date | string
  }

  export type usersCreateWithoutQueriesInput = {
    name: string
    email: string
    password_hash: string
    role?: string | null
    created_at?: Date | string
    history?: historyCreateNestedManyWithoutUserInput
    exports?: exportsCreateNestedManyWithoutUserInput
    suggestions?: suggestionsCreateNestedManyWithoutUserInput
    access_logs?: access_logsCreateNestedManyWithoutUserInput
    ai_chat_sessions?: ai_chat_sessionsCreateNestedManyWithoutUserInput
    ai_interactions?: ai_interactionsCreateNestedManyWithoutUserInput
    ai_insights?: ai_insightsCreateNestedManyWithoutUserInput
  }

  export type usersUncheckedCreateWithoutQueriesInput = {
    id?: number
    name: string
    email: string
    password_hash: string
    role?: string | null
    created_at?: Date | string
    history?: historyUncheckedCreateNestedManyWithoutUserInput
    exports?: exportsUncheckedCreateNestedManyWithoutUserInput
    suggestions?: suggestionsUncheckedCreateNestedManyWithoutUserInput
    access_logs?: access_logsUncheckedCreateNestedManyWithoutUserInput
    ai_chat_sessions?: ai_chat_sessionsUncheckedCreateNestedManyWithoutUserInput
    ai_interactions?: ai_interactionsUncheckedCreateNestedManyWithoutUserInput
    ai_insights?: ai_insightsUncheckedCreateNestedManyWithoutUserInput
  }

  export type usersCreateOrConnectWithoutQueriesInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutQueriesInput, usersUncheckedCreateWithoutQueriesInput>
  }

  export type resultsCreateWithoutQueryInput = {
    result_type?: string | null
    content?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
  }

  export type resultsUncheckedCreateWithoutQueryInput = {
    id?: number
    result_type?: string | null
    content?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
  }

  export type resultsCreateOrConnectWithoutQueryInput = {
    where: resultsWhereUniqueInput
    create: XOR<resultsCreateWithoutQueryInput, resultsUncheckedCreateWithoutQueryInput>
  }

  export type resultsCreateManyQueryInputEnvelope = {
    data: resultsCreateManyQueryInput | resultsCreateManyQueryInput[]
    skipDuplicates?: boolean
  }

  export type historyCreateWithoutQueryInput = {
    success?: boolean | null
    execution_time?: number | null
    created_at?: Date | string
    user: usersCreateNestedOneWithoutHistoryInput
  }

  export type historyUncheckedCreateWithoutQueryInput = {
    id?: number
    user_id: number
    success?: boolean | null
    execution_time?: number | null
    created_at?: Date | string
  }

  export type historyCreateOrConnectWithoutQueryInput = {
    where: historyWhereUniqueInput
    create: XOR<historyCreateWithoutQueryInput, historyUncheckedCreateWithoutQueryInput>
  }

  export type historyCreateManyQueryInputEnvelope = {
    data: historyCreateManyQueryInput | historyCreateManyQueryInput[]
    skipDuplicates?: boolean
  }

  export type usersUpsertWithoutQueriesInput = {
    update: XOR<usersUpdateWithoutQueriesInput, usersUncheckedUpdateWithoutQueriesInput>
    create: XOR<usersCreateWithoutQueriesInput, usersUncheckedCreateWithoutQueriesInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutQueriesInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutQueriesInput, usersUncheckedUpdateWithoutQueriesInput>
  }

  export type usersUpdateWithoutQueriesInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    history?: historyUpdateManyWithoutUserNestedInput
    exports?: exportsUpdateManyWithoutUserNestedInput
    suggestions?: suggestionsUpdateManyWithoutUserNestedInput
    access_logs?: access_logsUpdateManyWithoutUserNestedInput
    ai_chat_sessions?: ai_chat_sessionsUpdateManyWithoutUserNestedInput
    ai_interactions?: ai_interactionsUpdateManyWithoutUserNestedInput
    ai_insights?: ai_insightsUpdateManyWithoutUserNestedInput
  }

  export type usersUncheckedUpdateWithoutQueriesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    history?: historyUncheckedUpdateManyWithoutUserNestedInput
    exports?: exportsUncheckedUpdateManyWithoutUserNestedInput
    suggestions?: suggestionsUncheckedUpdateManyWithoutUserNestedInput
    access_logs?: access_logsUncheckedUpdateManyWithoutUserNestedInput
    ai_chat_sessions?: ai_chat_sessionsUncheckedUpdateManyWithoutUserNestedInput
    ai_interactions?: ai_interactionsUncheckedUpdateManyWithoutUserNestedInput
    ai_insights?: ai_insightsUncheckedUpdateManyWithoutUserNestedInput
  }

  export type resultsUpsertWithWhereUniqueWithoutQueryInput = {
    where: resultsWhereUniqueInput
    update: XOR<resultsUpdateWithoutQueryInput, resultsUncheckedUpdateWithoutQueryInput>
    create: XOR<resultsCreateWithoutQueryInput, resultsUncheckedCreateWithoutQueryInput>
  }

  export type resultsUpdateWithWhereUniqueWithoutQueryInput = {
    where: resultsWhereUniqueInput
    data: XOR<resultsUpdateWithoutQueryInput, resultsUncheckedUpdateWithoutQueryInput>
  }

  export type resultsUpdateManyWithWhereWithoutQueryInput = {
    where: resultsScalarWhereInput
    data: XOR<resultsUpdateManyMutationInput, resultsUncheckedUpdateManyWithoutQueryInput>
  }

  export type resultsScalarWhereInput = {
    AND?: resultsScalarWhereInput | resultsScalarWhereInput[]
    OR?: resultsScalarWhereInput[]
    NOT?: resultsScalarWhereInput | resultsScalarWhereInput[]
    id?: IntFilter<"results"> | number
    query_id?: IntFilter<"results"> | number
    result_type?: StringNullableFilter<"results"> | string | null
    content?: JsonNullableFilter<"results">
    created_at?: DateTimeFilter<"results"> | Date | string
  }

  export type historyUpsertWithWhereUniqueWithoutQueryInput = {
    where: historyWhereUniqueInput
    update: XOR<historyUpdateWithoutQueryInput, historyUncheckedUpdateWithoutQueryInput>
    create: XOR<historyCreateWithoutQueryInput, historyUncheckedCreateWithoutQueryInput>
  }

  export type historyUpdateWithWhereUniqueWithoutQueryInput = {
    where: historyWhereUniqueInput
    data: XOR<historyUpdateWithoutQueryInput, historyUncheckedUpdateWithoutQueryInput>
  }

  export type historyUpdateManyWithWhereWithoutQueryInput = {
    where: historyScalarWhereInput
    data: XOR<historyUpdateManyMutationInput, historyUncheckedUpdateManyWithoutQueryInput>
  }

  export type queriesCreateWithoutResultsInput = {
    question_text?: string | null
    created_at?: Date | string
    user: usersCreateNestedOneWithoutQueriesInput
    history?: historyCreateNestedManyWithoutQueryInput
  }

  export type queriesUncheckedCreateWithoutResultsInput = {
    id?: number
    user_id: number
    question_text?: string | null
    created_at?: Date | string
    history?: historyUncheckedCreateNestedManyWithoutQueryInput
  }

  export type queriesCreateOrConnectWithoutResultsInput = {
    where: queriesWhereUniqueInput
    create: XOR<queriesCreateWithoutResultsInput, queriesUncheckedCreateWithoutResultsInput>
  }

  export type queriesUpsertWithoutResultsInput = {
    update: XOR<queriesUpdateWithoutResultsInput, queriesUncheckedUpdateWithoutResultsInput>
    create: XOR<queriesCreateWithoutResultsInput, queriesUncheckedCreateWithoutResultsInput>
    where?: queriesWhereInput
  }

  export type queriesUpdateToOneWithWhereWithoutResultsInput = {
    where?: queriesWhereInput
    data: XOR<queriesUpdateWithoutResultsInput, queriesUncheckedUpdateWithoutResultsInput>
  }

  export type queriesUpdateWithoutResultsInput = {
    question_text?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: usersUpdateOneRequiredWithoutQueriesNestedInput
    history?: historyUpdateManyWithoutQueryNestedInput
  }

  export type queriesUncheckedUpdateWithoutResultsInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    question_text?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    history?: historyUncheckedUpdateManyWithoutQueryNestedInput
  }

  export type usersCreateWithoutHistoryInput = {
    name: string
    email: string
    password_hash: string
    role?: string | null
    created_at?: Date | string
    queries?: queriesCreateNestedManyWithoutUserInput
    exports?: exportsCreateNestedManyWithoutUserInput
    suggestions?: suggestionsCreateNestedManyWithoutUserInput
    access_logs?: access_logsCreateNestedManyWithoutUserInput
    ai_chat_sessions?: ai_chat_sessionsCreateNestedManyWithoutUserInput
    ai_interactions?: ai_interactionsCreateNestedManyWithoutUserInput
    ai_insights?: ai_insightsCreateNestedManyWithoutUserInput
  }

  export type usersUncheckedCreateWithoutHistoryInput = {
    id?: number
    name: string
    email: string
    password_hash: string
    role?: string | null
    created_at?: Date | string
    queries?: queriesUncheckedCreateNestedManyWithoutUserInput
    exports?: exportsUncheckedCreateNestedManyWithoutUserInput
    suggestions?: suggestionsUncheckedCreateNestedManyWithoutUserInput
    access_logs?: access_logsUncheckedCreateNestedManyWithoutUserInput
    ai_chat_sessions?: ai_chat_sessionsUncheckedCreateNestedManyWithoutUserInput
    ai_interactions?: ai_interactionsUncheckedCreateNestedManyWithoutUserInput
    ai_insights?: ai_insightsUncheckedCreateNestedManyWithoutUserInput
  }

  export type usersCreateOrConnectWithoutHistoryInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutHistoryInput, usersUncheckedCreateWithoutHistoryInput>
  }

  export type queriesCreateWithoutHistoryInput = {
    question_text?: string | null
    created_at?: Date | string
    user: usersCreateNestedOneWithoutQueriesInput
    results?: resultsCreateNestedManyWithoutQueryInput
  }

  export type queriesUncheckedCreateWithoutHistoryInput = {
    id?: number
    user_id: number
    question_text?: string | null
    created_at?: Date | string
    results?: resultsUncheckedCreateNestedManyWithoutQueryInput
  }

  export type queriesCreateOrConnectWithoutHistoryInput = {
    where: queriesWhereUniqueInput
    create: XOR<queriesCreateWithoutHistoryInput, queriesUncheckedCreateWithoutHistoryInput>
  }

  export type usersUpsertWithoutHistoryInput = {
    update: XOR<usersUpdateWithoutHistoryInput, usersUncheckedUpdateWithoutHistoryInput>
    create: XOR<usersCreateWithoutHistoryInput, usersUncheckedCreateWithoutHistoryInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutHistoryInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutHistoryInput, usersUncheckedUpdateWithoutHistoryInput>
  }

  export type usersUpdateWithoutHistoryInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    queries?: queriesUpdateManyWithoutUserNestedInput
    exports?: exportsUpdateManyWithoutUserNestedInput
    suggestions?: suggestionsUpdateManyWithoutUserNestedInput
    access_logs?: access_logsUpdateManyWithoutUserNestedInput
    ai_chat_sessions?: ai_chat_sessionsUpdateManyWithoutUserNestedInput
    ai_interactions?: ai_interactionsUpdateManyWithoutUserNestedInput
    ai_insights?: ai_insightsUpdateManyWithoutUserNestedInput
  }

  export type usersUncheckedUpdateWithoutHistoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    queries?: queriesUncheckedUpdateManyWithoutUserNestedInput
    exports?: exportsUncheckedUpdateManyWithoutUserNestedInput
    suggestions?: suggestionsUncheckedUpdateManyWithoutUserNestedInput
    access_logs?: access_logsUncheckedUpdateManyWithoutUserNestedInput
    ai_chat_sessions?: ai_chat_sessionsUncheckedUpdateManyWithoutUserNestedInput
    ai_interactions?: ai_interactionsUncheckedUpdateManyWithoutUserNestedInput
    ai_insights?: ai_insightsUncheckedUpdateManyWithoutUserNestedInput
  }

  export type queriesUpsertWithoutHistoryInput = {
    update: XOR<queriesUpdateWithoutHistoryInput, queriesUncheckedUpdateWithoutHistoryInput>
    create: XOR<queriesCreateWithoutHistoryInput, queriesUncheckedCreateWithoutHistoryInput>
    where?: queriesWhereInput
  }

  export type queriesUpdateToOneWithWhereWithoutHistoryInput = {
    where?: queriesWhereInput
    data: XOR<queriesUpdateWithoutHistoryInput, queriesUncheckedUpdateWithoutHistoryInput>
  }

  export type queriesUpdateWithoutHistoryInput = {
    question_text?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: usersUpdateOneRequiredWithoutQueriesNestedInput
    results?: resultsUpdateManyWithoutQueryNestedInput
  }

  export type queriesUncheckedUpdateWithoutHistoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    question_text?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    results?: resultsUncheckedUpdateManyWithoutQueryNestedInput
  }

  export type usersCreateWithoutExportsInput = {
    name: string
    email: string
    password_hash: string
    role?: string | null
    created_at?: Date | string
    queries?: queriesCreateNestedManyWithoutUserInput
    history?: historyCreateNestedManyWithoutUserInput
    suggestions?: suggestionsCreateNestedManyWithoutUserInput
    access_logs?: access_logsCreateNestedManyWithoutUserInput
    ai_chat_sessions?: ai_chat_sessionsCreateNestedManyWithoutUserInput
    ai_interactions?: ai_interactionsCreateNestedManyWithoutUserInput
    ai_insights?: ai_insightsCreateNestedManyWithoutUserInput
  }

  export type usersUncheckedCreateWithoutExportsInput = {
    id?: number
    name: string
    email: string
    password_hash: string
    role?: string | null
    created_at?: Date | string
    queries?: queriesUncheckedCreateNestedManyWithoutUserInput
    history?: historyUncheckedCreateNestedManyWithoutUserInput
    suggestions?: suggestionsUncheckedCreateNestedManyWithoutUserInput
    access_logs?: access_logsUncheckedCreateNestedManyWithoutUserInput
    ai_chat_sessions?: ai_chat_sessionsUncheckedCreateNestedManyWithoutUserInput
    ai_interactions?: ai_interactionsUncheckedCreateNestedManyWithoutUserInput
    ai_insights?: ai_insightsUncheckedCreateNestedManyWithoutUserInput
  }

  export type usersCreateOrConnectWithoutExportsInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutExportsInput, usersUncheckedCreateWithoutExportsInput>
  }

  export type usersUpsertWithoutExportsInput = {
    update: XOR<usersUpdateWithoutExportsInput, usersUncheckedUpdateWithoutExportsInput>
    create: XOR<usersCreateWithoutExportsInput, usersUncheckedCreateWithoutExportsInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutExportsInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutExportsInput, usersUncheckedUpdateWithoutExportsInput>
  }

  export type usersUpdateWithoutExportsInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    queries?: queriesUpdateManyWithoutUserNestedInput
    history?: historyUpdateManyWithoutUserNestedInput
    suggestions?: suggestionsUpdateManyWithoutUserNestedInput
    access_logs?: access_logsUpdateManyWithoutUserNestedInput
    ai_chat_sessions?: ai_chat_sessionsUpdateManyWithoutUserNestedInput
    ai_interactions?: ai_interactionsUpdateManyWithoutUserNestedInput
    ai_insights?: ai_insightsUpdateManyWithoutUserNestedInput
  }

  export type usersUncheckedUpdateWithoutExportsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    queries?: queriesUncheckedUpdateManyWithoutUserNestedInput
    history?: historyUncheckedUpdateManyWithoutUserNestedInput
    suggestions?: suggestionsUncheckedUpdateManyWithoutUserNestedInput
    access_logs?: access_logsUncheckedUpdateManyWithoutUserNestedInput
    ai_chat_sessions?: ai_chat_sessionsUncheckedUpdateManyWithoutUserNestedInput
    ai_interactions?: ai_interactionsUncheckedUpdateManyWithoutUserNestedInput
    ai_insights?: ai_insightsUncheckedUpdateManyWithoutUserNestedInput
  }

  export type usersCreateWithoutSuggestionsInput = {
    name: string
    email: string
    password_hash: string
    role?: string | null
    created_at?: Date | string
    queries?: queriesCreateNestedManyWithoutUserInput
    history?: historyCreateNestedManyWithoutUserInput
    exports?: exportsCreateNestedManyWithoutUserInput
    access_logs?: access_logsCreateNestedManyWithoutUserInput
    ai_chat_sessions?: ai_chat_sessionsCreateNestedManyWithoutUserInput
    ai_interactions?: ai_interactionsCreateNestedManyWithoutUserInput
    ai_insights?: ai_insightsCreateNestedManyWithoutUserInput
  }

  export type usersUncheckedCreateWithoutSuggestionsInput = {
    id?: number
    name: string
    email: string
    password_hash: string
    role?: string | null
    created_at?: Date | string
    queries?: queriesUncheckedCreateNestedManyWithoutUserInput
    history?: historyUncheckedCreateNestedManyWithoutUserInput
    exports?: exportsUncheckedCreateNestedManyWithoutUserInput
    access_logs?: access_logsUncheckedCreateNestedManyWithoutUserInput
    ai_chat_sessions?: ai_chat_sessionsUncheckedCreateNestedManyWithoutUserInput
    ai_interactions?: ai_interactionsUncheckedCreateNestedManyWithoutUserInput
    ai_insights?: ai_insightsUncheckedCreateNestedManyWithoutUserInput
  }

  export type usersCreateOrConnectWithoutSuggestionsInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutSuggestionsInput, usersUncheckedCreateWithoutSuggestionsInput>
  }

  export type usersUpsertWithoutSuggestionsInput = {
    update: XOR<usersUpdateWithoutSuggestionsInput, usersUncheckedUpdateWithoutSuggestionsInput>
    create: XOR<usersCreateWithoutSuggestionsInput, usersUncheckedCreateWithoutSuggestionsInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutSuggestionsInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutSuggestionsInput, usersUncheckedUpdateWithoutSuggestionsInput>
  }

  export type usersUpdateWithoutSuggestionsInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    queries?: queriesUpdateManyWithoutUserNestedInput
    history?: historyUpdateManyWithoutUserNestedInput
    exports?: exportsUpdateManyWithoutUserNestedInput
    access_logs?: access_logsUpdateManyWithoutUserNestedInput
    ai_chat_sessions?: ai_chat_sessionsUpdateManyWithoutUserNestedInput
    ai_interactions?: ai_interactionsUpdateManyWithoutUserNestedInput
    ai_insights?: ai_insightsUpdateManyWithoutUserNestedInput
  }

  export type usersUncheckedUpdateWithoutSuggestionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    queries?: queriesUncheckedUpdateManyWithoutUserNestedInput
    history?: historyUncheckedUpdateManyWithoutUserNestedInput
    exports?: exportsUncheckedUpdateManyWithoutUserNestedInput
    access_logs?: access_logsUncheckedUpdateManyWithoutUserNestedInput
    ai_chat_sessions?: ai_chat_sessionsUncheckedUpdateManyWithoutUserNestedInput
    ai_interactions?: ai_interactionsUncheckedUpdateManyWithoutUserNestedInput
    ai_insights?: ai_insightsUncheckedUpdateManyWithoutUserNestedInput
  }

  export type usersCreateWithoutAccess_logsInput = {
    name: string
    email: string
    password_hash: string
    role?: string | null
    created_at?: Date | string
    queries?: queriesCreateNestedManyWithoutUserInput
    history?: historyCreateNestedManyWithoutUserInput
    exports?: exportsCreateNestedManyWithoutUserInput
    suggestions?: suggestionsCreateNestedManyWithoutUserInput
    ai_chat_sessions?: ai_chat_sessionsCreateNestedManyWithoutUserInput
    ai_interactions?: ai_interactionsCreateNestedManyWithoutUserInput
    ai_insights?: ai_insightsCreateNestedManyWithoutUserInput
  }

  export type usersUncheckedCreateWithoutAccess_logsInput = {
    id?: number
    name: string
    email: string
    password_hash: string
    role?: string | null
    created_at?: Date | string
    queries?: queriesUncheckedCreateNestedManyWithoutUserInput
    history?: historyUncheckedCreateNestedManyWithoutUserInput
    exports?: exportsUncheckedCreateNestedManyWithoutUserInput
    suggestions?: suggestionsUncheckedCreateNestedManyWithoutUserInput
    ai_chat_sessions?: ai_chat_sessionsUncheckedCreateNestedManyWithoutUserInput
    ai_interactions?: ai_interactionsUncheckedCreateNestedManyWithoutUserInput
    ai_insights?: ai_insightsUncheckedCreateNestedManyWithoutUserInput
  }

  export type usersCreateOrConnectWithoutAccess_logsInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutAccess_logsInput, usersUncheckedCreateWithoutAccess_logsInput>
  }

  export type usersUpsertWithoutAccess_logsInput = {
    update: XOR<usersUpdateWithoutAccess_logsInput, usersUncheckedUpdateWithoutAccess_logsInput>
    create: XOR<usersCreateWithoutAccess_logsInput, usersUncheckedCreateWithoutAccess_logsInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutAccess_logsInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutAccess_logsInput, usersUncheckedUpdateWithoutAccess_logsInput>
  }

  export type usersUpdateWithoutAccess_logsInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    queries?: queriesUpdateManyWithoutUserNestedInput
    history?: historyUpdateManyWithoutUserNestedInput
    exports?: exportsUpdateManyWithoutUserNestedInput
    suggestions?: suggestionsUpdateManyWithoutUserNestedInput
    ai_chat_sessions?: ai_chat_sessionsUpdateManyWithoutUserNestedInput
    ai_interactions?: ai_interactionsUpdateManyWithoutUserNestedInput
    ai_insights?: ai_insightsUpdateManyWithoutUserNestedInput
  }

  export type usersUncheckedUpdateWithoutAccess_logsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    queries?: queriesUncheckedUpdateManyWithoutUserNestedInput
    history?: historyUncheckedUpdateManyWithoutUserNestedInput
    exports?: exportsUncheckedUpdateManyWithoutUserNestedInput
    suggestions?: suggestionsUncheckedUpdateManyWithoutUserNestedInput
    ai_chat_sessions?: ai_chat_sessionsUncheckedUpdateManyWithoutUserNestedInput
    ai_interactions?: ai_interactionsUncheckedUpdateManyWithoutUserNestedInput
    ai_insights?: ai_insightsUncheckedUpdateManyWithoutUserNestedInput
  }

  export type usersCreateWithoutAi_chat_sessionsInput = {
    name: string
    email: string
    password_hash: string
    role?: string | null
    created_at?: Date | string
    queries?: queriesCreateNestedManyWithoutUserInput
    history?: historyCreateNestedManyWithoutUserInput
    exports?: exportsCreateNestedManyWithoutUserInput
    suggestions?: suggestionsCreateNestedManyWithoutUserInput
    access_logs?: access_logsCreateNestedManyWithoutUserInput
    ai_interactions?: ai_interactionsCreateNestedManyWithoutUserInput
    ai_insights?: ai_insightsCreateNestedManyWithoutUserInput
  }

  export type usersUncheckedCreateWithoutAi_chat_sessionsInput = {
    id?: number
    name: string
    email: string
    password_hash: string
    role?: string | null
    created_at?: Date | string
    queries?: queriesUncheckedCreateNestedManyWithoutUserInput
    history?: historyUncheckedCreateNestedManyWithoutUserInput
    exports?: exportsUncheckedCreateNestedManyWithoutUserInput
    suggestions?: suggestionsUncheckedCreateNestedManyWithoutUserInput
    access_logs?: access_logsUncheckedCreateNestedManyWithoutUserInput
    ai_interactions?: ai_interactionsUncheckedCreateNestedManyWithoutUserInput
    ai_insights?: ai_insightsUncheckedCreateNestedManyWithoutUserInput
  }

  export type usersCreateOrConnectWithoutAi_chat_sessionsInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutAi_chat_sessionsInput, usersUncheckedCreateWithoutAi_chat_sessionsInput>
  }

  export type ai_interactionsCreateWithoutSessionInput = {
    interaction_type: string
    input_text: string
    input_language?: string
    processed_query?: string | null
    ai_response?: NullableJsonNullValueInput | InputJsonValue
    execution_status?: string
    execution_time_ms?: number | null
    confidence_score?: number | null
    error_message?: string | null
    fallback_used?: boolean
    version?: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    user: usersCreateNestedOneWithoutAi_interactionsInput
    insights?: ai_insightsCreateNestedManyWithoutInteractionInput
  }

  export type ai_interactionsUncheckedCreateWithoutSessionInput = {
    id?: number
    user_id: number
    interaction_type: string
    input_text: string
    input_language?: string
    processed_query?: string | null
    ai_response?: NullableJsonNullValueInput | InputJsonValue
    execution_status?: string
    execution_time_ms?: number | null
    confidence_score?: number | null
    error_message?: string | null
    fallback_used?: boolean
    version?: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    insights?: ai_insightsUncheckedCreateNestedManyWithoutInteractionInput
  }

  export type ai_interactionsCreateOrConnectWithoutSessionInput = {
    where: ai_interactionsWhereUniqueInput
    create: XOR<ai_interactionsCreateWithoutSessionInput, ai_interactionsUncheckedCreateWithoutSessionInput>
  }

  export type ai_interactionsCreateManySessionInputEnvelope = {
    data: ai_interactionsCreateManySessionInput | ai_interactionsCreateManySessionInput[]
    skipDuplicates?: boolean
  }

  export type usersUpsertWithoutAi_chat_sessionsInput = {
    update: XOR<usersUpdateWithoutAi_chat_sessionsInput, usersUncheckedUpdateWithoutAi_chat_sessionsInput>
    create: XOR<usersCreateWithoutAi_chat_sessionsInput, usersUncheckedCreateWithoutAi_chat_sessionsInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutAi_chat_sessionsInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutAi_chat_sessionsInput, usersUncheckedUpdateWithoutAi_chat_sessionsInput>
  }

  export type usersUpdateWithoutAi_chat_sessionsInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    queries?: queriesUpdateManyWithoutUserNestedInput
    history?: historyUpdateManyWithoutUserNestedInput
    exports?: exportsUpdateManyWithoutUserNestedInput
    suggestions?: suggestionsUpdateManyWithoutUserNestedInput
    access_logs?: access_logsUpdateManyWithoutUserNestedInput
    ai_interactions?: ai_interactionsUpdateManyWithoutUserNestedInput
    ai_insights?: ai_insightsUpdateManyWithoutUserNestedInput
  }

  export type usersUncheckedUpdateWithoutAi_chat_sessionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    queries?: queriesUncheckedUpdateManyWithoutUserNestedInput
    history?: historyUncheckedUpdateManyWithoutUserNestedInput
    exports?: exportsUncheckedUpdateManyWithoutUserNestedInput
    suggestions?: suggestionsUncheckedUpdateManyWithoutUserNestedInput
    access_logs?: access_logsUncheckedUpdateManyWithoutUserNestedInput
    ai_interactions?: ai_interactionsUncheckedUpdateManyWithoutUserNestedInput
    ai_insights?: ai_insightsUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ai_interactionsUpsertWithWhereUniqueWithoutSessionInput = {
    where: ai_interactionsWhereUniqueInput
    update: XOR<ai_interactionsUpdateWithoutSessionInput, ai_interactionsUncheckedUpdateWithoutSessionInput>
    create: XOR<ai_interactionsCreateWithoutSessionInput, ai_interactionsUncheckedCreateWithoutSessionInput>
  }

  export type ai_interactionsUpdateWithWhereUniqueWithoutSessionInput = {
    where: ai_interactionsWhereUniqueInput
    data: XOR<ai_interactionsUpdateWithoutSessionInput, ai_interactionsUncheckedUpdateWithoutSessionInput>
  }

  export type ai_interactionsUpdateManyWithWhereWithoutSessionInput = {
    where: ai_interactionsScalarWhereInput
    data: XOR<ai_interactionsUpdateManyMutationInput, ai_interactionsUncheckedUpdateManyWithoutSessionInput>
  }

  export type ai_chat_sessionsCreateWithoutInteractionsInput = {
    session_token: string
    status?: string
    context_data?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
    user: usersCreateNestedOneWithoutAi_chat_sessionsInput
  }

  export type ai_chat_sessionsUncheckedCreateWithoutInteractionsInput = {
    id?: number
    user_id: number
    session_token: string
    status?: string
    context_data?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ai_chat_sessionsCreateOrConnectWithoutInteractionsInput = {
    where: ai_chat_sessionsWhereUniqueInput
    create: XOR<ai_chat_sessionsCreateWithoutInteractionsInput, ai_chat_sessionsUncheckedCreateWithoutInteractionsInput>
  }

  export type usersCreateWithoutAi_interactionsInput = {
    name: string
    email: string
    password_hash: string
    role?: string | null
    created_at?: Date | string
    queries?: queriesCreateNestedManyWithoutUserInput
    history?: historyCreateNestedManyWithoutUserInput
    exports?: exportsCreateNestedManyWithoutUserInput
    suggestions?: suggestionsCreateNestedManyWithoutUserInput
    access_logs?: access_logsCreateNestedManyWithoutUserInput
    ai_chat_sessions?: ai_chat_sessionsCreateNestedManyWithoutUserInput
    ai_insights?: ai_insightsCreateNestedManyWithoutUserInput
  }

  export type usersUncheckedCreateWithoutAi_interactionsInput = {
    id?: number
    name: string
    email: string
    password_hash: string
    role?: string | null
    created_at?: Date | string
    queries?: queriesUncheckedCreateNestedManyWithoutUserInput
    history?: historyUncheckedCreateNestedManyWithoutUserInput
    exports?: exportsUncheckedCreateNestedManyWithoutUserInput
    suggestions?: suggestionsUncheckedCreateNestedManyWithoutUserInput
    access_logs?: access_logsUncheckedCreateNestedManyWithoutUserInput
    ai_chat_sessions?: ai_chat_sessionsUncheckedCreateNestedManyWithoutUserInput
    ai_insights?: ai_insightsUncheckedCreateNestedManyWithoutUserInput
  }

  export type usersCreateOrConnectWithoutAi_interactionsInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutAi_interactionsInput, usersUncheckedCreateWithoutAi_interactionsInput>
  }

  export type ai_insightsCreateWithoutInteractionInput = {
    insight_type: string
    title: string
    description: string
    data_analysis: JsonNullValueInput | InputJsonValue
    confidence_level: string
    impact_score?: number | null
    status?: string
    expires_at?: Date | string | null
    created_at?: Date | string
    user: usersCreateNestedOneWithoutAi_insightsInput
  }

  export type ai_insightsUncheckedCreateWithoutInteractionInput = {
    id?: number
    user_id: number
    insight_type: string
    title: string
    description: string
    data_analysis: JsonNullValueInput | InputJsonValue
    confidence_level: string
    impact_score?: number | null
    status?: string
    expires_at?: Date | string | null
    created_at?: Date | string
  }

  export type ai_insightsCreateOrConnectWithoutInteractionInput = {
    where: ai_insightsWhereUniqueInput
    create: XOR<ai_insightsCreateWithoutInteractionInput, ai_insightsUncheckedCreateWithoutInteractionInput>
  }

  export type ai_insightsCreateManyInteractionInputEnvelope = {
    data: ai_insightsCreateManyInteractionInput | ai_insightsCreateManyInteractionInput[]
    skipDuplicates?: boolean
  }

  export type ai_chat_sessionsUpsertWithoutInteractionsInput = {
    update: XOR<ai_chat_sessionsUpdateWithoutInteractionsInput, ai_chat_sessionsUncheckedUpdateWithoutInteractionsInput>
    create: XOR<ai_chat_sessionsCreateWithoutInteractionsInput, ai_chat_sessionsUncheckedCreateWithoutInteractionsInput>
    where?: ai_chat_sessionsWhereInput
  }

  export type ai_chat_sessionsUpdateToOneWithWhereWithoutInteractionsInput = {
    where?: ai_chat_sessionsWhereInput
    data: XOR<ai_chat_sessionsUpdateWithoutInteractionsInput, ai_chat_sessionsUncheckedUpdateWithoutInteractionsInput>
  }

  export type ai_chat_sessionsUpdateWithoutInteractionsInput = {
    session_token?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    context_data?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: usersUpdateOneRequiredWithoutAi_chat_sessionsNestedInput
  }

  export type ai_chat_sessionsUncheckedUpdateWithoutInteractionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    session_token?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    context_data?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type usersUpsertWithoutAi_interactionsInput = {
    update: XOR<usersUpdateWithoutAi_interactionsInput, usersUncheckedUpdateWithoutAi_interactionsInput>
    create: XOR<usersCreateWithoutAi_interactionsInput, usersUncheckedCreateWithoutAi_interactionsInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutAi_interactionsInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutAi_interactionsInput, usersUncheckedUpdateWithoutAi_interactionsInput>
  }

  export type usersUpdateWithoutAi_interactionsInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    queries?: queriesUpdateManyWithoutUserNestedInput
    history?: historyUpdateManyWithoutUserNestedInput
    exports?: exportsUpdateManyWithoutUserNestedInput
    suggestions?: suggestionsUpdateManyWithoutUserNestedInput
    access_logs?: access_logsUpdateManyWithoutUserNestedInput
    ai_chat_sessions?: ai_chat_sessionsUpdateManyWithoutUserNestedInput
    ai_insights?: ai_insightsUpdateManyWithoutUserNestedInput
  }

  export type usersUncheckedUpdateWithoutAi_interactionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    queries?: queriesUncheckedUpdateManyWithoutUserNestedInput
    history?: historyUncheckedUpdateManyWithoutUserNestedInput
    exports?: exportsUncheckedUpdateManyWithoutUserNestedInput
    suggestions?: suggestionsUncheckedUpdateManyWithoutUserNestedInput
    access_logs?: access_logsUncheckedUpdateManyWithoutUserNestedInput
    ai_chat_sessions?: ai_chat_sessionsUncheckedUpdateManyWithoutUserNestedInput
    ai_insights?: ai_insightsUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ai_insightsUpsertWithWhereUniqueWithoutInteractionInput = {
    where: ai_insightsWhereUniqueInput
    update: XOR<ai_insightsUpdateWithoutInteractionInput, ai_insightsUncheckedUpdateWithoutInteractionInput>
    create: XOR<ai_insightsCreateWithoutInteractionInput, ai_insightsUncheckedCreateWithoutInteractionInput>
  }

  export type ai_insightsUpdateWithWhereUniqueWithoutInteractionInput = {
    where: ai_insightsWhereUniqueInput
    data: XOR<ai_insightsUpdateWithoutInteractionInput, ai_insightsUncheckedUpdateWithoutInteractionInput>
  }

  export type ai_insightsUpdateManyWithWhereWithoutInteractionInput = {
    where: ai_insightsScalarWhereInput
    data: XOR<ai_insightsUpdateManyMutationInput, ai_insightsUncheckedUpdateManyWithoutInteractionInput>
  }

  export type ai_interactionsCreateWithoutInsightsInput = {
    interaction_type: string
    input_text: string
    input_language?: string
    processed_query?: string | null
    ai_response?: NullableJsonNullValueInput | InputJsonValue
    execution_status?: string
    execution_time_ms?: number | null
    confidence_score?: number | null
    error_message?: string | null
    fallback_used?: boolean
    version?: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    session: ai_chat_sessionsCreateNestedOneWithoutInteractionsInput
    user: usersCreateNestedOneWithoutAi_interactionsInput
  }

  export type ai_interactionsUncheckedCreateWithoutInsightsInput = {
    id?: number
    session_id: number
    user_id: number
    interaction_type: string
    input_text: string
    input_language?: string
    processed_query?: string | null
    ai_response?: NullableJsonNullValueInput | InputJsonValue
    execution_status?: string
    execution_time_ms?: number | null
    confidence_score?: number | null
    error_message?: string | null
    fallback_used?: boolean
    version?: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
  }

  export type ai_interactionsCreateOrConnectWithoutInsightsInput = {
    where: ai_interactionsWhereUniqueInput
    create: XOR<ai_interactionsCreateWithoutInsightsInput, ai_interactionsUncheckedCreateWithoutInsightsInput>
  }

  export type usersCreateWithoutAi_insightsInput = {
    name: string
    email: string
    password_hash: string
    role?: string | null
    created_at?: Date | string
    queries?: queriesCreateNestedManyWithoutUserInput
    history?: historyCreateNestedManyWithoutUserInput
    exports?: exportsCreateNestedManyWithoutUserInput
    suggestions?: suggestionsCreateNestedManyWithoutUserInput
    access_logs?: access_logsCreateNestedManyWithoutUserInput
    ai_chat_sessions?: ai_chat_sessionsCreateNestedManyWithoutUserInput
    ai_interactions?: ai_interactionsCreateNestedManyWithoutUserInput
  }

  export type usersUncheckedCreateWithoutAi_insightsInput = {
    id?: number
    name: string
    email: string
    password_hash: string
    role?: string | null
    created_at?: Date | string
    queries?: queriesUncheckedCreateNestedManyWithoutUserInput
    history?: historyUncheckedCreateNestedManyWithoutUserInput
    exports?: exportsUncheckedCreateNestedManyWithoutUserInput
    suggestions?: suggestionsUncheckedCreateNestedManyWithoutUserInput
    access_logs?: access_logsUncheckedCreateNestedManyWithoutUserInput
    ai_chat_sessions?: ai_chat_sessionsUncheckedCreateNestedManyWithoutUserInput
    ai_interactions?: ai_interactionsUncheckedCreateNestedManyWithoutUserInput
  }

  export type usersCreateOrConnectWithoutAi_insightsInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutAi_insightsInput, usersUncheckedCreateWithoutAi_insightsInput>
  }

  export type ai_interactionsUpsertWithoutInsightsInput = {
    update: XOR<ai_interactionsUpdateWithoutInsightsInput, ai_interactionsUncheckedUpdateWithoutInsightsInput>
    create: XOR<ai_interactionsCreateWithoutInsightsInput, ai_interactionsUncheckedCreateWithoutInsightsInput>
    where?: ai_interactionsWhereInput
  }

  export type ai_interactionsUpdateToOneWithWhereWithoutInsightsInput = {
    where?: ai_interactionsWhereInput
    data: XOR<ai_interactionsUpdateWithoutInsightsInput, ai_interactionsUncheckedUpdateWithoutInsightsInput>
  }

  export type ai_interactionsUpdateWithoutInsightsInput = {
    interaction_type?: StringFieldUpdateOperationsInput | string
    input_text?: StringFieldUpdateOperationsInput | string
    input_language?: StringFieldUpdateOperationsInput | string
    processed_query?: NullableStringFieldUpdateOperationsInput | string | null
    ai_response?: NullableJsonNullValueInput | InputJsonValue
    execution_status?: StringFieldUpdateOperationsInput | string
    execution_time_ms?: NullableIntFieldUpdateOperationsInput | number | null
    confidence_score?: NullableFloatFieldUpdateOperationsInput | number | null
    error_message?: NullableStringFieldUpdateOperationsInput | string | null
    fallback_used?: BoolFieldUpdateOperationsInput | boolean
    version?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    session?: ai_chat_sessionsUpdateOneRequiredWithoutInteractionsNestedInput
    user?: usersUpdateOneRequiredWithoutAi_interactionsNestedInput
  }

  export type ai_interactionsUncheckedUpdateWithoutInsightsInput = {
    id?: IntFieldUpdateOperationsInput | number
    session_id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    interaction_type?: StringFieldUpdateOperationsInput | string
    input_text?: StringFieldUpdateOperationsInput | string
    input_language?: StringFieldUpdateOperationsInput | string
    processed_query?: NullableStringFieldUpdateOperationsInput | string | null
    ai_response?: NullableJsonNullValueInput | InputJsonValue
    execution_status?: StringFieldUpdateOperationsInput | string
    execution_time_ms?: NullableIntFieldUpdateOperationsInput | number | null
    confidence_score?: NullableFloatFieldUpdateOperationsInput | number | null
    error_message?: NullableStringFieldUpdateOperationsInput | string | null
    fallback_used?: BoolFieldUpdateOperationsInput | boolean
    version?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type usersUpsertWithoutAi_insightsInput = {
    update: XOR<usersUpdateWithoutAi_insightsInput, usersUncheckedUpdateWithoutAi_insightsInput>
    create: XOR<usersCreateWithoutAi_insightsInput, usersUncheckedCreateWithoutAi_insightsInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutAi_insightsInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutAi_insightsInput, usersUncheckedUpdateWithoutAi_insightsInput>
  }

  export type usersUpdateWithoutAi_insightsInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    queries?: queriesUpdateManyWithoutUserNestedInput
    history?: historyUpdateManyWithoutUserNestedInput
    exports?: exportsUpdateManyWithoutUserNestedInput
    suggestions?: suggestionsUpdateManyWithoutUserNestedInput
    access_logs?: access_logsUpdateManyWithoutUserNestedInput
    ai_chat_sessions?: ai_chat_sessionsUpdateManyWithoutUserNestedInput
    ai_interactions?: ai_interactionsUpdateManyWithoutUserNestedInput
  }

  export type usersUncheckedUpdateWithoutAi_insightsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    queries?: queriesUncheckedUpdateManyWithoutUserNestedInput
    history?: historyUncheckedUpdateManyWithoutUserNestedInput
    exports?: exportsUncheckedUpdateManyWithoutUserNestedInput
    suggestions?: suggestionsUncheckedUpdateManyWithoutUserNestedInput
    access_logs?: access_logsUncheckedUpdateManyWithoutUserNestedInput
    ai_chat_sessions?: ai_chat_sessionsUncheckedUpdateManyWithoutUserNestedInput
    ai_interactions?: ai_interactionsUncheckedUpdateManyWithoutUserNestedInput
  }

  export type queriesCreateManyUserInput = {
    id?: number
    question_text?: string | null
    created_at?: Date | string
  }

  export type historyCreateManyUserInput = {
    id?: number
    query_id?: number | null
    success?: boolean | null
    execution_time?: number | null
    created_at?: Date | string
  }

  export type exportsCreateManyUserInput = {
    id?: number
    file_type?: string | null
    file_path?: string | null
    created_at?: Date | string
  }

  export type suggestionsCreateManyUserInput = {
    id?: number
    content?: string | null
    source?: string | null
    created_at?: Date | string
  }

  export type access_logsCreateManyUserInput = {
    id?: number
    action?: string | null
    ip_address?: string | null
    created_at?: Date | string
  }

  export type ai_chat_sessionsCreateManyUserInput = {
    id?: number
    session_token: string
    status?: string
    context_data?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ai_interactionsCreateManyUserInput = {
    id?: number
    session_id: number
    interaction_type: string
    input_text: string
    input_language?: string
    processed_query?: string | null
    ai_response?: NullableJsonNullValueInput | InputJsonValue
    execution_status?: string
    execution_time_ms?: number | null
    confidence_score?: number | null
    error_message?: string | null
    fallback_used?: boolean
    version?: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
  }

  export type ai_insightsCreateManyUserInput = {
    id?: number
    interaction_id?: number | null
    insight_type: string
    title: string
    description: string
    data_analysis: JsonNullValueInput | InputJsonValue
    confidence_level: string
    impact_score?: number | null
    status?: string
    expires_at?: Date | string | null
    created_at?: Date | string
  }

  export type queriesUpdateWithoutUserInput = {
    question_text?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    results?: resultsUpdateManyWithoutQueryNestedInput
    history?: historyUpdateManyWithoutQueryNestedInput
  }

  export type queriesUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    question_text?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    results?: resultsUncheckedUpdateManyWithoutQueryNestedInput
    history?: historyUncheckedUpdateManyWithoutQueryNestedInput
  }

  export type queriesUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    question_text?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type historyUpdateWithoutUserInput = {
    success?: NullableBoolFieldUpdateOperationsInput | boolean | null
    execution_time?: NullableFloatFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    query?: queriesUpdateOneWithoutHistoryNestedInput
  }

  export type historyUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    query_id?: NullableIntFieldUpdateOperationsInput | number | null
    success?: NullableBoolFieldUpdateOperationsInput | boolean | null
    execution_time?: NullableFloatFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type historyUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    query_id?: NullableIntFieldUpdateOperationsInput | number | null
    success?: NullableBoolFieldUpdateOperationsInput | boolean | null
    execution_time?: NullableFloatFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type exportsUpdateWithoutUserInput = {
    file_type?: NullableStringFieldUpdateOperationsInput | string | null
    file_path?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type exportsUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    file_type?: NullableStringFieldUpdateOperationsInput | string | null
    file_path?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type exportsUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    file_type?: NullableStringFieldUpdateOperationsInput | string | null
    file_path?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type suggestionsUpdateWithoutUserInput = {
    content?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type suggestionsUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    content?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type suggestionsUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    content?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type access_logsUpdateWithoutUserInput = {
    action?: NullableStringFieldUpdateOperationsInput | string | null
    ip_address?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type access_logsUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    action?: NullableStringFieldUpdateOperationsInput | string | null
    ip_address?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type access_logsUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    action?: NullableStringFieldUpdateOperationsInput | string | null
    ip_address?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ai_chat_sessionsUpdateWithoutUserInput = {
    session_token?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    context_data?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    interactions?: ai_interactionsUpdateManyWithoutSessionNestedInput
  }

  export type ai_chat_sessionsUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    session_token?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    context_data?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    interactions?: ai_interactionsUncheckedUpdateManyWithoutSessionNestedInput
  }

  export type ai_chat_sessionsUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    session_token?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    context_data?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ai_interactionsUpdateWithoutUserInput = {
    interaction_type?: StringFieldUpdateOperationsInput | string
    input_text?: StringFieldUpdateOperationsInput | string
    input_language?: StringFieldUpdateOperationsInput | string
    processed_query?: NullableStringFieldUpdateOperationsInput | string | null
    ai_response?: NullableJsonNullValueInput | InputJsonValue
    execution_status?: StringFieldUpdateOperationsInput | string
    execution_time_ms?: NullableIntFieldUpdateOperationsInput | number | null
    confidence_score?: NullableFloatFieldUpdateOperationsInput | number | null
    error_message?: NullableStringFieldUpdateOperationsInput | string | null
    fallback_used?: BoolFieldUpdateOperationsInput | boolean
    version?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    session?: ai_chat_sessionsUpdateOneRequiredWithoutInteractionsNestedInput
    insights?: ai_insightsUpdateManyWithoutInteractionNestedInput
  }

  export type ai_interactionsUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    session_id?: IntFieldUpdateOperationsInput | number
    interaction_type?: StringFieldUpdateOperationsInput | string
    input_text?: StringFieldUpdateOperationsInput | string
    input_language?: StringFieldUpdateOperationsInput | string
    processed_query?: NullableStringFieldUpdateOperationsInput | string | null
    ai_response?: NullableJsonNullValueInput | InputJsonValue
    execution_status?: StringFieldUpdateOperationsInput | string
    execution_time_ms?: NullableIntFieldUpdateOperationsInput | number | null
    confidence_score?: NullableFloatFieldUpdateOperationsInput | number | null
    error_message?: NullableStringFieldUpdateOperationsInput | string | null
    fallback_used?: BoolFieldUpdateOperationsInput | boolean
    version?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    insights?: ai_insightsUncheckedUpdateManyWithoutInteractionNestedInput
  }

  export type ai_interactionsUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    session_id?: IntFieldUpdateOperationsInput | number
    interaction_type?: StringFieldUpdateOperationsInput | string
    input_text?: StringFieldUpdateOperationsInput | string
    input_language?: StringFieldUpdateOperationsInput | string
    processed_query?: NullableStringFieldUpdateOperationsInput | string | null
    ai_response?: NullableJsonNullValueInput | InputJsonValue
    execution_status?: StringFieldUpdateOperationsInput | string
    execution_time_ms?: NullableIntFieldUpdateOperationsInput | number | null
    confidence_score?: NullableFloatFieldUpdateOperationsInput | number | null
    error_message?: NullableStringFieldUpdateOperationsInput | string | null
    fallback_used?: BoolFieldUpdateOperationsInput | boolean
    version?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ai_insightsUpdateWithoutUserInput = {
    insight_type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    data_analysis?: JsonNullValueInput | InputJsonValue
    confidence_level?: StringFieldUpdateOperationsInput | string
    impact_score?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    expires_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    interaction?: ai_interactionsUpdateOneWithoutInsightsNestedInput
  }

  export type ai_insightsUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    interaction_id?: NullableIntFieldUpdateOperationsInput | number | null
    insight_type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    data_analysis?: JsonNullValueInput | InputJsonValue
    confidence_level?: StringFieldUpdateOperationsInput | string
    impact_score?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    expires_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ai_insightsUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    interaction_id?: NullableIntFieldUpdateOperationsInput | number | null
    insight_type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    data_analysis?: JsonNullValueInput | InputJsonValue
    confidence_level?: StringFieldUpdateOperationsInput | string
    impact_score?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    expires_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type resultsCreateManyQueryInput = {
    id?: number
    result_type?: string | null
    content?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
  }

  export type historyCreateManyQueryInput = {
    id?: number
    user_id: number
    success?: boolean | null
    execution_time?: number | null
    created_at?: Date | string
  }

  export type resultsUpdateWithoutQueryInput = {
    result_type?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type resultsUncheckedUpdateWithoutQueryInput = {
    id?: IntFieldUpdateOperationsInput | number
    result_type?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type resultsUncheckedUpdateManyWithoutQueryInput = {
    id?: IntFieldUpdateOperationsInput | number
    result_type?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type historyUpdateWithoutQueryInput = {
    success?: NullableBoolFieldUpdateOperationsInput | boolean | null
    execution_time?: NullableFloatFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: usersUpdateOneRequiredWithoutHistoryNestedInput
  }

  export type historyUncheckedUpdateWithoutQueryInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    success?: NullableBoolFieldUpdateOperationsInput | boolean | null
    execution_time?: NullableFloatFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type historyUncheckedUpdateManyWithoutQueryInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    success?: NullableBoolFieldUpdateOperationsInput | boolean | null
    execution_time?: NullableFloatFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ai_interactionsCreateManySessionInput = {
    id?: number
    user_id: number
    interaction_type: string
    input_text: string
    input_language?: string
    processed_query?: string | null
    ai_response?: NullableJsonNullValueInput | InputJsonValue
    execution_status?: string
    execution_time_ms?: number | null
    confidence_score?: number | null
    error_message?: string | null
    fallback_used?: boolean
    version?: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
  }

  export type ai_interactionsUpdateWithoutSessionInput = {
    interaction_type?: StringFieldUpdateOperationsInput | string
    input_text?: StringFieldUpdateOperationsInput | string
    input_language?: StringFieldUpdateOperationsInput | string
    processed_query?: NullableStringFieldUpdateOperationsInput | string | null
    ai_response?: NullableJsonNullValueInput | InputJsonValue
    execution_status?: StringFieldUpdateOperationsInput | string
    execution_time_ms?: NullableIntFieldUpdateOperationsInput | number | null
    confidence_score?: NullableFloatFieldUpdateOperationsInput | number | null
    error_message?: NullableStringFieldUpdateOperationsInput | string | null
    fallback_used?: BoolFieldUpdateOperationsInput | boolean
    version?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: usersUpdateOneRequiredWithoutAi_interactionsNestedInput
    insights?: ai_insightsUpdateManyWithoutInteractionNestedInput
  }

  export type ai_interactionsUncheckedUpdateWithoutSessionInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    interaction_type?: StringFieldUpdateOperationsInput | string
    input_text?: StringFieldUpdateOperationsInput | string
    input_language?: StringFieldUpdateOperationsInput | string
    processed_query?: NullableStringFieldUpdateOperationsInput | string | null
    ai_response?: NullableJsonNullValueInput | InputJsonValue
    execution_status?: StringFieldUpdateOperationsInput | string
    execution_time_ms?: NullableIntFieldUpdateOperationsInput | number | null
    confidence_score?: NullableFloatFieldUpdateOperationsInput | number | null
    error_message?: NullableStringFieldUpdateOperationsInput | string | null
    fallback_used?: BoolFieldUpdateOperationsInput | boolean
    version?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    insights?: ai_insightsUncheckedUpdateManyWithoutInteractionNestedInput
  }

  export type ai_interactionsUncheckedUpdateManyWithoutSessionInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    interaction_type?: StringFieldUpdateOperationsInput | string
    input_text?: StringFieldUpdateOperationsInput | string
    input_language?: StringFieldUpdateOperationsInput | string
    processed_query?: NullableStringFieldUpdateOperationsInput | string | null
    ai_response?: NullableJsonNullValueInput | InputJsonValue
    execution_status?: StringFieldUpdateOperationsInput | string
    execution_time_ms?: NullableIntFieldUpdateOperationsInput | number | null
    confidence_score?: NullableFloatFieldUpdateOperationsInput | number | null
    error_message?: NullableStringFieldUpdateOperationsInput | string | null
    fallback_used?: BoolFieldUpdateOperationsInput | boolean
    version?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ai_insightsCreateManyInteractionInput = {
    id?: number
    user_id: number
    insight_type: string
    title: string
    description: string
    data_analysis: JsonNullValueInput | InputJsonValue
    confidence_level: string
    impact_score?: number | null
    status?: string
    expires_at?: Date | string | null
    created_at?: Date | string
  }

  export type ai_insightsUpdateWithoutInteractionInput = {
    insight_type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    data_analysis?: JsonNullValueInput | InputJsonValue
    confidence_level?: StringFieldUpdateOperationsInput | string
    impact_score?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    expires_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: usersUpdateOneRequiredWithoutAi_insightsNestedInput
  }

  export type ai_insightsUncheckedUpdateWithoutInteractionInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    insight_type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    data_analysis?: JsonNullValueInput | InputJsonValue
    confidence_level?: StringFieldUpdateOperationsInput | string
    impact_score?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    expires_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ai_insightsUncheckedUpdateManyWithoutInteractionInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    insight_type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    data_analysis?: JsonNullValueInput | InputJsonValue
    confidence_level?: StringFieldUpdateOperationsInput | string
    impact_score?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    expires_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}